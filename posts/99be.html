<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>常见面试题（开胃菜） | 孔乙己的长衫</title><meta name="author" content="admin741,1957875100@qq.com"><meta name="copyright" content="admin741"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="1.Vue3.0性能提升主要是体现在哪些方面1.响应式系统12345678910111213141516171819202122232425262728293031323334- Vue.js 2.x 中响应式系统的核心是 Object.defineProperty，劫持整个对象，然后进行深度遍历所有属性，给每个属性添加&#96;getter&#96;和&#96;setter&#96;，实现响应式- Vue.js 3.x 中使用">
<meta property="og:type" content="article">
<meta property="og:title" content="常见面试题（开胃菜）">
<meta property="og:url" content="https://admin741-cl.github.io/posts/99be.html">
<meta property="og:site_name" content="孔乙己的长衫">
<meta property="og:description" content="1.Vue3.0性能提升主要是体现在哪些方面1.响应式系统12345678910111213141516171819202122232425262728293031323334- Vue.js 2.x 中响应式系统的核心是 Object.defineProperty，劫持整个对象，然后进行深度遍历所有属性，给每个属性添加&#96;getter&#96;和&#96;setter&#96;，实现响应式- Vue.js 3.x 中使用">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/blog-construct/banner.jpg">
<meta property="article:published_time" content="2022-05-08T04:33:33.000Z">
<meta property="article:modified_time" content="2023-06-17T02:36:39.157Z">
<meta property="article:author" content="admin741">
<meta property="article:tag" content="孔乙己-admin741">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/blog-construct/banner.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://admin741-cl.github.io/posts/99be.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="manifest" href="/manifest.json"/><meta name="msapplication-TileColor" content="#3b70fc"/><link rel="apple-touch-icon" sizes="180x180" href="/img/siteicon/128.png"/><link rel="icon" type="image/png" sizes="32x32" href="/img/siteicon/32.png"/><link rel="icon" type="image/png" sizes="16x16" href="/img/siteicon/16.png"/><link rel="mask-icon" href="/img/siteicon/128.png" color="#5bbad5"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '常见面试题（开胃菜）',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-06-17 10:36:39'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-categories-card@1.0.0/lib/categorybar.css"><link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/clock.min.css" /><link rel="stylesheet" href="https://npm.elemecdn.com/anzhiyu-blog@2.0.4/css/runtime/runtime.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-wowjs/lib/animate.min.css" media="print" onload="this.media='screen'"><link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-swiper-anzhiyu@1.0.4/lib/swiper.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-swiper-anzhiyu@1.0.4/lib/swiperstyle.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-tag-plugins-plus@latest/lib/assets/font-awesome-animation.min.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-tag-plugins-plus@latest/lib/tag_plugins.css" media="defer" onload="this.media='all'"><script src="https://cdn.cbd.int/hexo-butterfly-tag-plugins-plus@latest/lib/assets/carousel-touch.js"></script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="孔乙己的长衫" type="application/atom+xml">
</head><body><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><div class="loading-img"></div><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',()=> { preloader.endLoading() })

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><script>window.paceOptions = {
  restartOnPushState: false
}

document.addEventListener('pjax:send', () => {
  Pace.restart()
})
</script><link rel="stylesheet" href="/css/progress_bar.css"/><script src="https://cdn.jsdelivr.net/npm/pace-js/pace.min.js"></script><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/404.jpg'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">7</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">2</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/bangumis/index.html"><i class="fa-fw fas fa-home"></i><span> 追番</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fas fa-envelope"></i><span> 留言板</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://w.wallhaven.cc/full/2y/wallhaven-2y95y6.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="孔乙己的长衫"><span class="site-name">孔乙己的长衫</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/bangumis/index.html"><i class="fa-fw fas fa-home"></i><span> 追番</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fas fa-envelope"></i><span> 留言板</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">常见面试题（开胃菜）</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-05-08T04:33:33.000Z" title="发表于 2022-05-08 12:33:33">2022-05-08</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-06-17T02:36:39.157Z" title="更新于 2023-06-17 10:36:39">2023-06-17</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="常见面试题（开胃菜）"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section><div id="post-top-cover"><img class="nolazyload" id="post-top-bg" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="background-image: url('https://w.wallhaven.cc/full/2y/wallhaven-2y95y6.jpg')"></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="1-Vue3-0性能提升主要是体现在哪些方面"><a href="#1-Vue3-0性能提升主要是体现在哪些方面" class="headerlink" title="1.Vue3.0性能提升主要是体现在哪些方面"></a>1.Vue3.0性能提升主要是体现在哪些方面</h1><h2 id="1-响应式系统"><a href="#1-响应式系统" class="headerlink" title="1.响应式系统"></a>1.响应式系统</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">- <span class="title class_">Vue</span>.<span class="property">js</span> <span class="number">2.</span>x 中响应式系统的核心是 <span class="title class_">Object</span>.<span class="property">defineProperty</span>，劫持整个对象，然后进行深度遍历所有属性，给每个属性添加<span class="string">`getter`</span>和<span class="string">`setter`</span>，实现响应式</span><br><span class="line">- <span class="title class_">Vue</span>.<span class="property">js</span> <span class="number">3.</span>x 中使用 <span class="title class_">Proxy</span> 对象重写响应式系统</span><br><span class="line">	- 可以监听动态新增的属性</span><br><span class="line">	- 可以监听删除的属性</span><br><span class="line">	- 可以监听数组的索引和length属性 </span><br><span class="line"></span><br><span class="line">* 实现原理:</span><br><span class="line"></span><br><span class="line">  * 通过<span class="title class_">Proxy</span>（代理）: 拦截对象中任意属性的变化, 包括：属性值的读写、属性的添加、属性的删除等。</span><br><span class="line"></span><br><span class="line">  * 通过<span class="title class_">Reflect</span>（反射）: 对源对象的属性进行操作。</span><br><span class="line"></span><br><span class="line">  * <span class="variable constant_">MDN</span>文档中描述的<span class="title class_">Proxy</span>与<span class="title class_">Reflect</span>：</span><br><span class="line"></span><br><span class="line">    * <span class="title class_">Proxy</span>：[<span class="title class_">Proxy</span> - <span class="title class_">JavaScript</span> | <span class="variable constant_">MDN</span>](<span class="attr">https</span>:<span class="comment">//developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy &quot;Proxy - JavaScript | MDN&quot;)</span></span><br><span class="line"></span><br><span class="line">    * <span class="title class_">Reflect</span>：[<span class="title class_">Reflect</span> - <span class="title class_">JavaScript</span> | <span class="variable constant_">MDN</span>](<span class="attr">https</span>:<span class="comment">//developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect &quot;Reflect - JavaScript | MDN&quot;)</span></span><br><span class="line">                                           </span><br><span class="line">       <span class="keyword">new</span> <span class="title class_">Proxy</span>(data, &#123;</span><br><span class="line">          <span class="comment">// 拦截读取属性值</span></span><br><span class="line">          get (target, prop) &#123;</span><br><span class="line">              <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(target, prop)</span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="comment">// 拦截设置属性值或添加新属性</span></span><br><span class="line">          set (target, prop, value) &#123;</span><br><span class="line">              <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">set</span>(target, prop, value)</span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="comment">// 拦截删除属性</span></span><br><span class="line">          deleteProperty (target, prop) &#123;</span><br><span class="line">              <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">deleteProperty</span>(target, prop)</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">  </span><br><span class="line">      proxy.<span class="property">name</span> = <span class="string">&#x27;tom&#x27;</span>   ![]</span><br></pre></td></tr></table></figure>
<h2 id="2-编译阶段"><a href="#2-编译阶段" class="headerlink" title="2.编译阶段"></a>2.编译阶段</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> Vue.js 2.x 通过标记静态节点，优化 diff 的过程</span><br><span class="line"><span class="bullet">-</span> Vue.js 3.x </span><br><span class="line"><span class="bullet">  *</span>   vue.js 3.x中标记和提升所有的静态节点，diff的时候只需要对比动态节点内容；</span><br><span class="line"><span class="bullet">  *</span>   Fragments（升级vetur插件): template中不需要唯一根节点，可以直接放文本或者同级标签</span><br><span class="line"><span class="bullet">  *</span>   静态提升(hoistStatic),当使用 hoistStatic 时,所有静态的节点都被提升到 render 方法之外.只会在应用启动的时候被创建一次,之后使用只需要应用提取的静态节点，随着每次的渲染被不停的复用。</span><br><span class="line"><span class="bullet">  *</span>   patch flag, 在动态标签末尾加上相应的标记,只能带 patchFlag 的节点才被认为是动态的元素,会被追踪属性的修改,能快速的找到动态节点,而不用逐个逐层遍历，提高了虚拟dom diff的性能。</span><br><span class="line"><span class="bullet">  *</span>   缓存事件处理函数cacheHandler,避免每次触发都要重新生成全新的function去更新之前的函数</span><br></pre></td></tr></table></figure>
<h2 id="3-源码体积"><a href="#3-源码体积" class="headerlink" title="3.源码体积"></a>3.源码体积</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> 相比Vue2，Vue3整体体积变小了，除了移出一些不常用的AP</span><br><span class="line"><span class="bullet">-</span> tree shanking</span><br><span class="line"><span class="bullet">  -</span> 任何一个函数，如ref、reavtived、computed等，仅仅在用到的时候才打包</span><br><span class="line"><span class="bullet">  -</span> 通过编译阶段的静态分析，找到没有引入的模块并打上标记,将这些模块都给摇掉</span><br></pre></td></tr></table></figure>
<h1 id="2-vue3有哪些新的组件"><a href="#2-vue3有哪些新的组件" class="headerlink" title="2.vue3有哪些新的组件"></a>2.vue3有哪些新的组件</h1><h2 id="1-Fragment"><a href="#1-Fragment" class="headerlink" title="1.Fragment"></a>1.Fragment</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">*</span>   在Vue2中: 组件必须有一个根标签</span><br><span class="line"></span><br><span class="line"><span class="bullet">*</span>   在Vue3中: 组件可以没有根标签, 内部会将多个标签包含在一个Fragment虚拟元素中</span><br><span class="line"></span><br><span class="line"><span class="bullet">*</span>   好处: 减少标签层级, 减小内存占用 </span><br></pre></td></tr></table></figure>
<h2 id="2-Teleport"><a href="#2-Teleport" class="headerlink" title="2.Teleport"></a>2.Teleport</h2><p>什么是Teleport？—— <code>Teleport</code> 是一种能够将我们的<strong>组件html结构</strong>移动到指定位置的技术。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">teleport</span> <span class="attr">to</span>=<span class="string">&quot;移动位置&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-if</span>=<span class="string">&quot;isShow&quot;</span> <span class="attr">class</span>=<span class="string">&quot;mask&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;dialog&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">h3</span>&gt;</span>我是一个弹窗<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;isShow = false&quot;</span>&gt;</span>关闭弹窗<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">teleport</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="3-Suspense"><a href="#3-Suspense" class="headerlink" title="3.Suspense"></a>3.Suspense</h2><ul>
<li><p>等待异步组件时渲染一些额外内容，让应用有更好的用户体验</p>
</li>
<li><p>使用步骤：</p>
<ul>
<li><p>异步引入组件</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;defineAsyncComponent&#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Child</span> = <span class="title function_">defineAsyncComponent</span>(<span class="function">()=&gt;</span><span class="keyword">import</span>(<span class="string">&#x27;./components/Child.vue&#x27;</span>))</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用<code>Suspense</code>包裹组件，并配置好<code>default</code> 与 <code>fallback</code></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h3</span>&gt;</span>我是App组件<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Suspense</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:default</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">Child</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:fallback</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">h3</span>&gt;</span>加载中.....<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">Suspense</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h1 id="3-Vue2-0-和-Vue3-0-有什么区别"><a href="#3-Vue2-0-和-Vue3-0-有什么区别" class="headerlink" title="3.Vue2.0 和 Vue3.0 有什么区别"></a>3.Vue2.0 和 Vue3.0 有什么区别</h1><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">1.</span> 响应式系统的重新配置，使用proxy替换Object.defineProperty</span><br><span class="line"><span class="bullet">2.</span> typescript支持</span><br><span class="line"><span class="bullet">3.</span> 新增组合API，更好的逻辑重用和代码组织</span><br><span class="line"><span class="bullet">4.</span> v-if和v-for的优先级</span><br><span class="line"><span class="bullet">5.</span> 静态元素提升</span><br><span class="line"><span class="bullet">6.</span> 虚拟节点静态标记</span><br><span class="line"><span class="bullet">7.</span> 生命周期变化</span><br><span class="line"><span class="bullet">8.</span> 打包体积优化</span><br><span class="line"><span class="bullet">9.</span> ssr渲染性能提升</span><br><span class="line"><span class="bullet">10.</span> 支持多个根节点</span><br></pre></td></tr></table></figure>
<h1 id="4-Vue-生命周期"><a href="#4-Vue-生命周期" class="headerlink" title="4.Vue 生命周期"></a>4.Vue 生命周期</h1><h2 id="1-vue2-x的生命周期"><a href="#1-vue2-x的生命周期" class="headerlink" title="1.vue2.x的生命周期"></a>1.vue2.x的生命周期</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/68bee44057b94174b62cd1350936ec04~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="img"></p>
<h2 id="2-vue3-0的生命周期"><a href="#2-vue3-0的生命周期" class="headerlink" title="2.vue3.0的生命周期"></a>2.vue3.0的生命周期</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/93eb8366f638409b9035610c3e9adefc~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="img"></p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">*</span>   Vue3.0中可以继续使用Vue2.x中的生命周期钩子，但有有两个被更名：</span><br><span class="line"></span><br><span class="line"><span class="bullet">    *</span>   <span class="code">`beforeDestroy`</span>改名为 <span class="code">`beforeUnmount`</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">    *</span>   <span class="code">`destroyed`</span>改名为 <span class="code">`unmounted`</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">*</span>   Vue3.0也提供了 Composition API 形式的生命周期钩子，与Vue2.x中钩子对应关系如下：</span><br><span class="line"></span><br><span class="line"><span class="bullet">    *</span>   <span class="code">`beforeCreate`</span>===&gt;<span class="code">`setup()`</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">    *</span>   <span class="code">`created`</span>=======&gt;<span class="code">`setup()`</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">    *</span>   <span class="code">`beforeMount`</span> ===&gt;<span class="code">`onBeforeMount`</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">    *</span>   <span class="code">`mounted`</span>=======&gt;<span class="code">`onMounted`</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">    *</span>   <span class="code">`beforeUpdate`</span>===&gt;<span class="code">`onBeforeUpdate`</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">    *</span>   <span class="code">`updated`</span> =======&gt;<span class="code">`onUpdated`</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">    *</span>   <span class="code">`beforeUnmount`</span> ==&gt;<span class="code">`onBeforeUnmount`</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">    *</span>   <span class="code">`unmounted`</span> =====&gt;<span class="code">`onUnmounted`</span></span><br><span class="line"><span class="code">    </span></span><br><span class="line"><span class="code">    </span></span><br><span class="line"><span class="code">    </span></span><br><span class="line"><span class="code">Vue 实例有⼀个完整的⽣命周期，也就是从开始创建、初始化数据、编译模版、挂载Dom -&gt; 渲染、更新 -&gt; 渲染、卸载 等⼀系列过程，称这是Vue的⽣命周期。 </span></span><br><span class="line"><span class="code">1、beforeCreate（创建前） ：数据观测和初始化事件还未开始，此时 data 的响应式追踪、event/watcher 都还没有被设置，也就是说不能访问到data、computed、watch、methods上的方法和数据。 </span></span><br><span class="line"><span class="code">2、created（创建后） ：实例创建完成，实例上配置的 options 包括 data、computed、watch、methods 等都配置完成，但是此时渲染得节点还未挂载到 DOM，所以不能访问到 `$el` 属性。 </span></span><br><span class="line"><span class="code">3、beforeMount（挂载前） ：在挂载开始之前被调用，相关的render函数首次被调用。实例已完成以下的配置：编译模板，把data里面的数据和模板生成html。此时还没有挂载html到页面上。 </span></span><br><span class="line"><span class="code">4、mounted（挂载后） ：在el被新创建的 vm.$el 替换，并挂载到实例上去之后调用。实例已完成以下的配置：用上面编译好的html内容替换el属性指向的DOM对象。完成模板中的html渲染到html 页面中。此过程中进行ajax交互。 </span></span><br><span class="line"><span class="code">5、beforeUpdate（更新前） ：响应式数据更新时调用，此时虽然响应式数据更新了，但是对应的真实 DOM 还没有被渲染。 </span></span><br><span class="line"><span class="code">6、updated（更新后）：在由于数据更改导致的虚拟DOM重新渲染和打补丁之后调用。此时 DOM 已经根据响应式数据的变化更新了。调用时，组件 DOM已经更新，所以可以执行依赖于DOM的操作。然而在大多数情况下，应该避免在此期间更改状态，因为这可能会导致更新无限循环。该钩子在服务器端渲染期间不被调用。 </span></span><br><span class="line"><span class="code">7、beforeDestroy（销毁前） ：实例销毁之前调用。这一步，实例仍然完全可用，`this` 仍能获取到实例。</span></span><br><span class="line"><span class="code">8、destroyed（销毁后） ：实例销毁后调用，调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。该钩子在服务端渲染期间不被调用。 </span></span><br></pre></td></tr></table></figure>
<h1 id="5-都说-Composition-API-和-React-Hook-很像，请问他们的区别是什么"><a href="#5-都说-Composition-API-和-React-Hook-很像，请问他们的区别是什么" class="headerlink" title="5.都说 Composition API 和 React Hook 很像，请问他们的区别是什么"></a>5.都说 Composition API 和 React Hook 很像，请问他们的区别是什么</h1><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">从 React Hook 从实现的角度来看，React Hook 是基于 useState 的调用顺序来确定下一个 re 渲染时间状态从哪个 useState 开始，所以有以下几个限制</span><br><span class="line"></span><br><span class="line"><span class="bullet">*</span>   不在循环中、条件、调用嵌套函数 Hook</span><br><span class="line"><span class="bullet">*</span>   你必须确保它总是在你这边 React Top level 调用函数 Hook</span><br><span class="line"><span class="bullet">*</span>   使用效果、使用备忘录 依赖关系必须手动确定</span><br><span class="line"></span><br><span class="line">和 Composition API 是基于 Vue 的响应系统，和 React Hook 相比</span><br><span class="line"></span><br><span class="line"><span class="bullet">*</span>   在设置函数中，一个组件实例只调用一次设置，而 React Hook 每次重新渲染时，都需要调用 Hook，给 React 带来的 GC 比 Vue 更大的压力，性能也相对 Vue 对我来说也比较慢</span><br><span class="line"><span class="bullet">*</span>   Compositon API 你不必担心调用的顺序，它也可以在循环中、条件、在嵌套函数中使用</span><br><span class="line"><span class="bullet">*</span>   响应式系统自动实现依赖关系收集，而且组件的性能优化是由 Vue 内部完成的，而 React Hook 的依赖关系需要手动传递，并且依赖关系的顺序必须得到保证，让路 useEffect、useMemo 等等，否则组件性能会因为依赖关系不正确而下降。</span><br><span class="line"></span><br><span class="line">虽然Compoliton API看起来像React Hook来使用，但它的设计思路也是React Hook的参考。</span><br></pre></td></tr></table></figure>
<h1 id="6-Composition-Api-与Options-Api-有什么不同"><a href="#6-Composition-Api-与Options-Api-有什么不同" class="headerlink" title="6. Composition Api 与Options Api 有什么不同"></a>6. Composition Api 与Options Api 有什么不同</h1><h2 id="1-Options-Api"><a href="#1-Options-Api" class="headerlink" title="1.Options Api"></a>1.Options Api</h2><p><code>Options API</code>，即大家常说的选项API，即以<code>vue</code>为后缀的文件，通过定义<code>methods</code>，<code>computed</code>，<code>watch</code>，<code>data</code>等属性与方法，共同处理页面逻辑</p>
<p>如下图：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8d6769c3019e479c88121ed726398703~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="img"></p>
<p>可以看到<code>Options</code>代码编写方式，如果是组件状态，则写在<code>data</code>属性上，如果是方法，则写在<code>methods</code>属性上…</p>
<p>用组件的选项 (<code>data</code>、<code>computed</code>、<code>methods</code>、<code>watch</code>) 组织逻辑在大多数情况下都有效</p>
<p>然而，当组件变得复杂，导致对应属性的列表也会增长，这可能会导致组件难以阅读和理解</p>
<h2 id="2-Composition-Api"><a href="#2-Composition-Api" class="headerlink" title="2.Composition Api"></a>2.Composition Api</h2><p>在 Vue3 Composition API 中，组件根据逻辑功能来组织的，一个功能所定义的所有 API 会放在一起（更加的高内聚，低耦合）</p>
<p>即使项目很大，功能很多，我们都能快速的定位到这个功能所用到的所有 API</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/18337c0974434ae09ae141a116aff75b~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="img"></p>
<h2 id="3-对比"><a href="#3-对比" class="headerlink" title="3.对比"></a>3.对比</h2><p>下面对<code>Composition Api</code>与<code>Options Api</code>进行两大方面的比较</p>
<ul>
<li>逻辑组织</li>
<li>逻辑复用</li>
</ul>
<h3 id="逻辑组织"><a href="#逻辑组织" class="headerlink" title="逻辑组织"></a>逻辑组织</h3><h3 id="Options-API"><a href="#Options-API" class="headerlink" title="Options API"></a>Options API</h3><p>假设一个组件是一个大型组件，其内部有很多处理逻辑关注点（对应下图不用颜色）</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ba80a442eb69455fb3499f1493378a5f~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="img"></p>
<p>可以看到，这种碎片化使得理解和维护复杂组件变得困难</p>
<p>选项的分离掩盖了潜在的逻辑问题。此外，在处理单个逻辑关注点时，我们必须不断地“跳转”相关代码的选项块</p>
<h3 id="Compostion-API"><a href="#Compostion-API" class="headerlink" title="Compostion API"></a>Compostion API</h3><p>而<code>Compositon API</code>正是解决上述问题，将某个逻辑关注点相关的代码全都放在一个函数里，这样当需要修改一个功能时，就不再需要在文件中跳来跳去</p>
<p>下面举个简单例子，将处理<code>count</code>属性相关的代码放在同一个函数了</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function useCount() &#123;</span><br><span class="line">    let <span class="attr">count</span> = ref(<span class="number">10</span>)<span class="comment">;</span></span><br><span class="line">    let <span class="attr">double</span> = computed(() =&gt; &#123;</span><br><span class="line">        return count.value * 2<span class="comment">;</span></span><br><span class="line">    &#125;)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">    const <span class="attr">handleConut</span> = () =&gt; &#123;</span><br><span class="line">        <span class="attr">count.value</span> = count.value * <span class="number">2</span><span class="comment">;</span></span><br><span class="line">    &#125;<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">    console.log(count)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">    return &#123;</span><br><span class="line">        count,</span><br><span class="line">        double,</span><br><span class="line">        handleConut,</span><br><span class="line">    &#125;<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>组件上中使用<code>count</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineComponent</span>(&#123;</span><br><span class="line">    <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; count, double, handleConut &#125; = <span class="title function_">useCount</span>();</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            count,</span><br><span class="line">            double,</span><br><span class="line">            handleConut</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>再来一张图进行对比，可以很直观地感受到 <code>Composition API</code>在逻辑组织方面的优势，以后修改一个属性功能的时候，只需要跳到控制该属性的方法中即可</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ce453cd816a84cf2b7f295dbc3835314~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="img"></p>
<h3 id="逻辑复用"><a href="#逻辑复用" class="headerlink" title="逻辑复用"></a>逻辑复用</h3><p>在<code>Vue2</code>中，我们是用过<code>mixin</code>去复用相同的逻辑</p>
<p>下面举个例子，我们会另起一个<code>mixin.js</code>文件</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">MoveMixin</span> = &#123;</span><br><span class="line">  <span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">x</span>: <span class="number">0</span>,</span><br><span class="line">      <span class="attr">y</span>: <span class="number">0</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="attr">methods</span>: &#123;</span><br><span class="line">    <span class="title function_">handleKeyup</span>(<span class="params">e</span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(e.<span class="property">code</span>);</span><br><span class="line">      <span class="comment">// 上下左右 x y</span></span><br><span class="line">      <span class="keyword">switch</span> (e.<span class="property">code</span>) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;ArrowUp&quot;</span>:</span><br><span class="line">          <span class="variable language_">this</span>.<span class="property">y</span>--;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;ArrowDown&quot;</span>:</span><br><span class="line">          <span class="variable language_">this</span>.<span class="property">y</span>++;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;ArrowLeft&quot;</span>:</span><br><span class="line">          <span class="variable language_">this</span>.<span class="property">x</span>--;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;ArrowRight&quot;</span>:</span><br><span class="line">          <span class="variable language_">this</span>.<span class="property">x</span>++;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="title function_">mounted</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;keyup&quot;</span>, <span class="variable language_">this</span>.<span class="property">handleKeyup</span>);</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="title function_">unmounted</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">window</span>.<span class="title function_">removeEventListener</span>(<span class="string">&quot;keyup&quot;</span>, <span class="variable language_">this</span>.<span class="property">handleKeyup</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<p>然后在组件中使用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    Mouse position: x &#123;&#123; x &#125;&#125; / y &#123;&#123; y &#125;&#125;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">import mousePositionMixin from &#x27;./mouse&#x27;</span><br><span class="line">export default &#123;</span><br><span class="line">  mixins: [mousePositionMixin]</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<p>使用单个<code>mixin</code>似乎问题不大，但是当我们一个组件混入大量不同的 <code>mixins</code> 的时候</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mixins: [mousePositionMixin, fooMixin, barMixin, otherMixin]</span><br></pre></td></tr></table></figure>
<p>会存在两个非常明显的问题：</p>
<ul>
<li>命名冲突</li>
<li>数据来源不清晰</li>
</ul>
<p>现在通过<code>Compositon API</code>这种方式改写上面的代码</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; onMounted, onUnmounted, reactive &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">useMove</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> position = <span class="title function_">reactive</span>(&#123;</span><br><span class="line">    <span class="attr">x</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">y</span>: <span class="number">0</span>,</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">handleKeyup</span> = (<span class="params">e</span>) =&gt; &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(e.<span class="property">code</span>);</span><br><span class="line">    <span class="comment">// 上下左右 x y</span></span><br><span class="line">    <span class="keyword">switch</span> (e.<span class="property">code</span>) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;ArrowUp&quot;</span>:</span><br><span class="line">        <span class="comment">// y.value--;</span></span><br><span class="line">        position.<span class="property">y</span>--;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;ArrowDown&quot;</span>:</span><br><span class="line">        <span class="comment">// y.value++;</span></span><br><span class="line">        position.<span class="property">y</span>++;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;ArrowLeft&quot;</span>:</span><br><span class="line">        <span class="comment">// x.value--;</span></span><br><span class="line">        position.<span class="property">x</span>--;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;ArrowRight&quot;</span>:</span><br><span class="line">        <span class="comment">// x.value++;</span></span><br><span class="line">        position.<span class="property">x</span>++;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">onMounted</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;keyup&quot;</span>, handleKeyup);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="title function_">onUnmounted</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">window</span>.<span class="title function_">removeEventListener</span>(<span class="string">&quot;keyup&quot;</span>, handleKeyup);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123; position &#125;;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<p>在组件中使用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    Mouse position: x &#123;&#123; x &#125;&#125; / y &#123;&#123; y &#125;&#125;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import &#123; useMove &#125; from &quot;./useMove&quot;;</span><br><span class="line">import &#123; toRefs &#125; from &quot;vue&quot;;</span><br><span class="line">export default &#123;</span><br><span class="line">  setup() &#123;</span><br><span class="line">    const &#123; position &#125; = useMove();</span><br><span class="line">    const &#123; x, y &#125; = toRefs(position);</span><br><span class="line">    return &#123;</span><br><span class="line">      x,</span><br><span class="line">      y,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>可以看到，整个数据来源清晰了，即使去编写更多的 hook 函数，也不会出现命名冲突的问题</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul>
<li>在逻辑组织和逻辑复用方面，<code>Composition API</code>是优于<code>Options API</code></li>
<li>因为<code>Composition API</code>几乎是函数，会有更好的类型推断。</li>
<li><code>Composition API</code>对 <code>tree-shaking</code> 友好，代码也更容易压缩</li>
<li><code>Composition API</code>中见不到<code>this</code>的使用，减少了<code>this</code>指向不明的情况</li>
<li>如果是小型组件，可以继续使用<code>Options API</code>，也是十分友好的。</li>
</ul>
<h1 id="7-什么是SPA单页面应用，首屏加载你是如何优化的"><a href="#7-什么是SPA单页面应用，首屏加载你是如何优化的" class="headerlink" title="7.什么是SPA单页面应用，首屏加载你是如何优化的"></a>7.什么是SPA单页面应用，首屏加载你是如何优化的</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">单页Web应用（single page web application，SPA），就是只有一张Web页面的应用，是加载单个HTML页面并在用户与应用程序交互时动态更新该页面的Web应用程序。我们开发的<span class="string">`Vue`</span>项目大多是借助个官方的<span class="string">`CLI`</span>脚手架，快速搭建项目，直接通过<span class="string">`new Vue`</span>构建一个实例，并将<span class="string">`el:&#x27;#app&#x27;`</span>挂载参数传入，最后通过<span class="string">`npm run build`</span>的方式打包后生成一个<span class="string">`index.html`</span>，称这种只有一个<span class="string">`HTML`</span>的页面为单页面应用。</span><br><span class="line"></span><br><span class="line">当然，<span class="string">`vue`</span>也可以像<span class="string">`jq`</span>一样引入，作为多页面应用的基础框架。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SPA首屏优化方式</span><br><span class="line"></span><br><span class="line">减小入口文件积</span><br><span class="line">静态资源本地缓存</span><br><span class="line">UI框架按需加载</span><br><span class="line">图片资源的压缩</span><br><span class="line">组件重复打包</span><br><span class="line">开启GZip压缩</span><br><span class="line">使用SSR</span><br></pre></td></tr></table></figure>
<h1 id="8-对Vue项目你做过哪些性能优化"><a href="#8-对Vue项目你做过哪些性能优化" class="headerlink" title="8.对Vue项目你做过哪些性能优化"></a>8.对Vue项目你做过哪些性能优化</h1><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">1、<span class="code">`v-if`</span>和<span class="code">`v-show`</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">*</span>   频繁切换时使用<span class="code">`v-show`</span>，利用其缓存特性</span><br><span class="line"><span class="bullet">*</span>   首屏渲染时使用<span class="code">`v-if`</span>，如果为<span class="code">`false`</span>则不进行渲染</span><br><span class="line"></span><br><span class="line">2、<span class="code">`v-for`</span>的<span class="code">`key`</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">*</span>   列表变化时，循环时使用唯一不变的<span class="code">`key`</span>，借助其本地复用策略</span><br><span class="line"><span class="bullet">*</span>   列表只进行一次渲染时，<span class="code">`key`</span>可以采用循环的<span class="code">`index`</span></span><br><span class="line"></span><br><span class="line">3、侦听器和计算属性</span><br><span class="line"></span><br><span class="line"><span class="bullet">*</span>   侦听器<span class="code">`watch`</span>用于数据变化时引起其他行为</span><br><span class="line"><span class="bullet">*</span>   多使用<span class="code">`compouter`</span>计算属性顾名思义就是新计算而来的属性，如果依赖的数据未发生变化，不会触发重新计算</span><br><span class="line"></span><br><span class="line">4、合理使用生命周期</span><br><span class="line"></span><br><span class="line"><span class="bullet">*</span>   在<span class="code">`destroyed`</span>阶段进行绑定事件或者定时器的销毁</span><br><span class="line"><span class="bullet">*</span>   使用动态组件的时候通过<span class="code">`keep-alive`</span>包裹进行缓存处理，相关的操作可以在<span class="code">`actived`</span>阶段激活</span><br><span class="line"></span><br><span class="line">5、数据响应式处理</span><br><span class="line"></span><br><span class="line"><span class="bullet">*</span>   不需要响应式处理的数据可以通过<span class="code">`Object.freeze`</span>处理，或者直接通过<span class="code">`this.xxx = xxx`</span>的方式进行定义</span><br><span class="line"><span class="bullet">*</span>   需要响应式处理的属性可以通过<span class="code">`this.$set`</span>的方式处理，而不是<span class="code">`JSON.parse(JSON.stringify(XXX))`</span>的方式</span><br><span class="line"></span><br><span class="line">6、路由加载方式</span><br><span class="line"></span><br><span class="line"><span class="bullet">*</span>   页面组件可以采用异步加载的方式</span><br><span class="line"></span><br><span class="line">7、插件引入</span><br><span class="line"></span><br><span class="line"><span class="bullet">*</span>   第三方插件可以采用按需加载的方式，比如<span class="code">`element-ui`</span>。</span><br><span class="line"></span><br><span class="line">8、减少代码量</span><br><span class="line"></span><br><span class="line"><span class="bullet">*</span>   采用<span class="code">`mixin`</span>的方式抽离公共方法</span><br><span class="line"><span class="bullet">*</span>   抽离公共组件</span><br><span class="line"><span class="bullet">*</span>   定义公共方法至公共<span class="code">`js`</span>中</span><br><span class="line"><span class="bullet">*</span>   抽离公共<span class="code">`css`</span></span><br><span class="line"></span><br><span class="line">9、编译方式</span><br><span class="line"></span><br><span class="line"><span class="bullet">*</span>   如果线上需要<span class="code">`template`</span>的编译，可以采用完成版<span class="code">`vue.esm.js`</span></span><br><span class="line"><span class="bullet">*</span>   如果线上无需<span class="code">`template`</span>的编译，可采用运行时版本<span class="code">`vue.runtime.esm.js`</span>，相比完整版体积要小大约<span class="code">`30%`</span></span><br><span class="line"></span><br><span class="line">10、渲染方式</span><br><span class="line"></span><br><span class="line"><span class="bullet">*</span>   服务端渲染，如果是需要<span class="code">`SEO`</span>的网站可以采用服务端渲染的方式</span><br><span class="line"><span class="bullet">*</span>   前端渲染，一些企业内部使用的后端管理系统可以采用前端渲染的方式</span><br><span class="line"></span><br><span class="line">11、字体图标的使用</span><br><span class="line"></span><br><span class="line"><span class="bullet">*</span>   有些图片图标尽可能使用字体图标</span><br></pre></td></tr></table></figure>
<h1 id="9-Vue组件通信的方式有哪些"><a href="#9-Vue组件通信的方式有哪些" class="headerlink" title="9.Vue组件通信的方式有哪些"></a>9.Vue组件通信的方式有哪些</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">vue中8种常规的通信方案</span><br><span class="line"></span><br><span class="line">通过 props 传递</span><br><span class="line">通过 $emit 触发自定义事件</span><br><span class="line">使用 ref</span><br><span class="line">EventBus</span><br><span class="line">$parent 或$root</span><br><span class="line">attrs 与 listeners</span><br><span class="line">Provide 与 Inject</span><br><span class="line">Vuex</span><br><span class="line"></span><br><span class="line">组件间通信的分类可以分成以下</span><br><span class="line"></span><br><span class="line">父子关系的组件数据传递选择 props  与 $emit进行传递，也可选择ref</span><br><span class="line">兄弟关系的组件数据传递可选择$bus，其次可以选择$parent进行传递</span><br><span class="line">祖先与后代组件数据传递可选择attrs与listeners或者 Provide与 Inject</span><br><span class="line">复杂关系的组件数据传递可以通过vuex存放共享的变量</span><br></pre></td></tr></table></figure>
<h1 id="10-Vue常用的修饰符有哪些"><a href="#10-Vue常用的修饰符有哪些" class="headerlink" title="10.Vue常用的修饰符有哪些"></a>10.Vue常用的修饰符有哪些</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"> 1、表单修饰符</span><br><span class="line"></span><br><span class="line">（1）`.lazy`</span><br><span class="line"></span><br><span class="line">在默认情况下，`v-model` 在每次 `input` 事件触发后将输入框的值与数据进行同步 ，可以添加 `lazy` 修饰符，从而转为在 `change` 事件之后进行同步:</span><br><span class="line"></span><br><span class="line">```</span><br><span class="line">&lt;input v-model.lazy=&quot;msg&quot;&gt;</span><br><span class="line"></span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">（2）`.number`</span><br><span class="line"></span><br><span class="line">如果想自动将用户的输入值转为数值类型，可以给 `v-model` 添加 `number` 修饰符：</span><br><span class="line"></span><br><span class="line">```</span><br><span class="line">&lt;input v-model.number=&quot;age&quot; type=&quot;number&quot;&gt;</span><br><span class="line"></span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">（3）`.trim`</span><br><span class="line"></span><br><span class="line">如果要自动过滤用户输入的首尾空白字符，可以给 `v-model` 添加 `trim` 修饰符：</span><br><span class="line"></span><br><span class="line">```</span><br><span class="line">&lt;input v-model.trim=&quot;msg&quot;&gt;</span><br><span class="line"></span><br><span class="line">```</span><br><span class="line"></span><br><span class="line"> 2、事件修饰符</span><br><span class="line"></span><br><span class="line"> （1）`.stop`</span><br><span class="line"></span><br><span class="line">阻止单击事件继续传播。</span><br><span class="line"></span><br><span class="line">```</span><br><span class="line">&lt;!--这里只会触发a--&gt;</span><br><span class="line">&lt;div @click=&quot;divClick&quot;&gt;&lt;a v-on:click.stop=&quot;aClick&quot;&gt;点击&lt;/a&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">（2）`.prevent`</span><br><span class="line"></span><br><span class="line">阻止标签的默认行为。</span><br><span class="line"></span><br><span class="line">```</span><br><span class="line">&lt;a href=&quot;http://www.baidu.com&quot; v-on:click.prevent=&quot;aClick&quot;&gt;点击&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">（3）`.capture`</span><br><span class="line"></span><br><span class="line">事件先在有`.capture`修饰符的节点上触发，然后在其包裹的内部节点中触发。</span><br><span class="line"></span><br><span class="line">```</span><br><span class="line">&lt;!--这里先执行divClick事件，然后再执行aClick事件--&gt;</span><br><span class="line">&lt;div @click=&quot;divClick&quot;&gt;&lt;a v-on:click=&quot;aClick&quot;&gt;点击&lt;/a&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">（4）`.self`</span><br><span class="line"></span><br><span class="line">只当在 event.target 是当前元素自身时触发处理函数，即事件不是从内部元素触发的。</span><br><span class="line"></span><br><span class="line">```</span><br><span class="line">&lt;!--在a标签上点击时只会触发aClick事件，只有点击phrase的时候才会触发divClick事件--&gt;</span><br><span class="line">&lt;div @click.self=&quot;divClick&quot;&gt;phrase&lt;a v-on:click=&quot;aClick&quot;&gt;点击&lt;/a&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">（5）`.once`</span><br><span class="line"></span><br><span class="line">不像其它只能对原生的 DOM 事件起作用的修饰符，`.once` 修饰符还能被用到自定义的组件事件上，表示当前事件只触发一次。</span><br><span class="line"></span><br><span class="line">```</span><br><span class="line">&lt;a v-on:click.once=&quot;aClick&quot;&gt;点击&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">```</span><br><span class="line">（6）`.passive`</span><br><span class="line"></span><br><span class="line">`.passive` 修饰符尤其能够提升移动端的性能</span><br><span class="line"></span><br><span class="line">```</span><br><span class="line">&lt;!-- 滚动事件的默认行为 (即滚动行为) 将会立即触发 --&gt;  </span><br><span class="line">&lt;!-- 而不会等待 `onScroll` 完成 --&gt;  </span><br><span class="line">&lt;!-- 这其中包含 `event.preventDefault()` 的情况 --&gt;  </span><br><span class="line">&lt;div v-on:scroll.passive=&quot;onScroll&quot;&gt;...&lt;/div&gt;</span><br><span class="line">```</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="11-Vue中的-nextTick有什么作用"><a href="#11-Vue中的-nextTick有什么作用" class="headerlink" title="11.Vue中的$nextTick有什么作用"></a>11.Vue中的$nextTick有什么作用</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> callbacks = []</span><br><span class="line"><span class="keyword">let</span> pending = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 完成两件事：</span></span><br><span class="line"><span class="comment"> *   1、用 try catch 包装 flushSchedulerQueue 函数，然后将其放入 callbacks 数组</span></span><br><span class="line"><span class="comment"> *   2、如果 pending 为 false，表示现在浏览器的任务队列中没有 flushCallbacks 函数</span></span><br><span class="line"><span class="comment"> *     如果 pending 为 true，则表示浏览器的任务队列中已经被放入了 flushCallbacks 函数，</span></span><br><span class="line"><span class="comment"> *     待执行 flushCallbacks 函数时，pending 会被再次置为 false，表示下一个 flushCallbacks 函数可以进入</span></span><br><span class="line"><span class="comment"> *     浏览器的任务队列了</span></span><br><span class="line"><span class="comment"> * pending 的作用：保证在同一时刻，浏览器的任务队列中只有一个 flushCallbacks 函数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">*</span>&#125; cb 接收一个回调函数 =&gt; flushSchedulerQueue</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">*</span>&#125; ctx 上下文</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns</span> </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">nextTick</span> (cb?: <span class="title class_">Function</span>, ctx?: <span class="title class_">Object</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> _resolve</span><br><span class="line">  <span class="comment">// 用 callbacks 数组存储经过包装的 cb 函数</span></span><br><span class="line">  callbacks.<span class="title function_">push</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (cb) &#123;</span><br><span class="line">      <span class="comment">// 用 try catch 包装回调函数，便于错误捕获</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        cb.<span class="title function_">call</span>(ctx)</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="title function_">handleError</span>(e, ctx, <span class="string">&#x27;nextTick&#x27;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (_resolve) &#123;</span><br><span class="line">      <span class="title function_">_resolve</span>(ctx)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">if</span> (!pending) &#123;</span><br><span class="line">    pending = <span class="literal">true</span></span><br><span class="line">    <span class="comment">// 执行 timerFunc，在浏览器的任务队列中（首选微任务队列）放入 flushCallbacks 函数</span></span><br><span class="line">    <span class="title function_">timerFunc</span>()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// $flow-disable-line</span></span><br><span class="line">  <span class="keyword">if</span> (!cb &amp;&amp; <span class="keyword">typeof</span> <span class="title class_">Promise</span> !== <span class="string">&#x27;undefined&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">      _resolve = resolve</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">官方对其的定义</span><br><span class="line">​</span><br><span class="line">在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM</span><br><span class="line">​</span><br><span class="line">什么意思呢？</span><br><span class="line">​</span><br><span class="line">我们可以理解成，Vue 在更新 DOM 时是异步执行的。当数据发生变化，Vue将开启一个异步更新队列，视图需要等队列中所有数据变化完成之后，再统一进行更新</span><br><span class="line">​</span><br><span class="line">Vue 的异步更新机制的核心是利用了浏览器的异步任务队列来实现的，首选微任务队列，宏任务队列次之。</span><br><span class="line">​</span><br><span class="line">当响应式数据更新后，会调用 dep.notify 方法，通知 dep 中收集的 watcher 去执行 update 方法，watcher.update 将 watcher 自己放入一个 watcher 队列（全局的 queue 数组）。</span><br><span class="line">​</span><br><span class="line">然后通过 nextTick 方法将一个刷新 watcher 队列的方法（flushSchedulerQueue）放入一个全局的 callbacks 数组中。</span><br><span class="line">​</span><br><span class="line">如果此时浏览器的异步任务队列中没有一个叫 flushCallbacks 的函数，则执行 timerFunc 函数，将 flushCallbacks 函数放入异步任务队列。如果异步任务队列中已经存在 flushCallbacks 函数，等待其执行完成以后再放入下一个 flushCallbacks 函数。</span><br><span class="line">​</span><br><span class="line">flushCallbacks 函数负责执行 callbacks 数组中的所有 flushSchedulerQueue 函数。</span><br><span class="line">​</span><br><span class="line">flushSchedulerQueue 函数负责刷新 watcher 队列，即执行 queue 数组中每一个 watcher 的 run 方法，从而进入更新阶段，比如执行组件更新函数或者执行用户 watch 的回调函数。</span><br></pre></td></tr></table></figure>
<h1 id="12-如何理解双向数据绑定"><a href="#12-如何理解双向数据绑定" class="headerlink" title="12.如何理解双向数据绑定"></a>12.如何理解双向数据绑定</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">我们都知道 Vue 是数据双向绑定的框架，双向绑定由三个重要部分构成</span><br><span class="line"></span><br><span class="line">数据层（Model）：应用的数据及业务逻辑</span><br><span class="line">视图层（<span class="keyword">View</span>）：应用的展示效果，各类UI组件</span><br><span class="line">业务逻辑层（ViewModel）：框架封装的核心，它负责将数据与视图关联起来</span><br><span class="line">而上面的这个分层的架构方案，可以用一个专业术语进行称呼：MVVM这里的控制层的核心功能便是 “数据双向绑定” 。自然，我们只需弄懂它是什么，便可以进一步了解数据绑定的原理</span><br><span class="line"></span><br><span class="line">理解ViewModel</span><br><span class="line">它的主要职责就是：</span><br><span class="line"></span><br><span class="line">数据变化后更新视图</span><br><span class="line">视图变化后更新数据</span><br><span class="line">当然，它还有两个主要部分组成</span><br><span class="line"></span><br><span class="line">监听器（Observer）：对所有数据的属性进行监听</span><br><span class="line">解析器（Compiler）：对每个元素节点的指令进行扫描跟解析,根据指令模板替换数据,以及绑定相应的更新函数</span><br></pre></td></tr></table></figure>
<h1 id="13-v-show和v-if有什么区别？你可以讲讲吗"><a href="#13-v-show和v-if有什么区别？你可以讲讲吗" class="headerlink" title="13.v-show和v-if有什么区别？你可以讲讲吗"></a>13.v-show和v-if有什么区别？你可以讲讲吗</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">v<span class="operator">-</span><span class="keyword">show</span> 与 v<span class="operator">-</span>if 的作用效果是相同的(不含v<span class="operator">-</span><span class="keyword">else</span>)，都能控制元素在页面是否显示,在用法上也是相同的</span><br><span class="line"></span><br><span class="line"><span class="operator">-</span> 区别 </span><br><span class="line">控制手段不同</span><br><span class="line">编译过程不同</span><br><span class="line">编译条件不同</span><br><span class="line"></span><br><span class="line">控制手段：v<span class="operator">-</span><span class="keyword">show</span>隐藏则是为该元素添加css<span class="comment">--display:none，dom元素依旧还在。v-if显示隐藏是将dom元素整个添加或删除</span></span><br><span class="line"></span><br><span class="line">编译过程：v<span class="operator">-</span>if切换有一个局部编译<span class="operator">/</span>卸载的过程，切换过程中合适地销毁和重建内部的事件监听和子组件；v<span class="operator">-</span><span class="keyword">show</span>只是简单的基于css切换</span><br><span class="line"></span><br><span class="line">编译条件：v<span class="operator">-</span>if是真正的条件渲染，它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。只有渲染条件为假时，并不做操作，直到为真才渲染</span><br><span class="line"></span><br><span class="line">v<span class="operator">-</span><span class="keyword">show</span> 由<span class="literal">false</span>变为<span class="literal">true</span>的时候不会触发组件的生命周期</span><br><span class="line"></span><br><span class="line">v<span class="operator">-</span>if由<span class="literal">false</span>变为<span class="literal">true</span>的时候，触发组件的beforeCreate、<span class="keyword">create</span>、beforeMount、mounted钩子，由<span class="literal">true</span>变为<span class="literal">false</span>的时候触发组件的beforeDestory、destoryed方法</span><br><span class="line"></span><br><span class="line">性能消耗：v<span class="operator">-</span>if有更高的切换消耗；v<span class="operator">-</span><span class="keyword">show</span>有更高的初始渲染消耗</span><br></pre></td></tr></table></figure>
<h1 id="14-有用过keep-alive吗？它有什么作用"><a href="#14-有用过keep-alive吗？它有什么作用" class="headerlink" title="14.有用过keep-alive吗？它有什么作用"></a>14.有用过keep-alive吗？它有什么作用</h1><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">`vue`中支持组件化，并且也有用于缓存的内置组件`keep-alive`可直接使用，使用场景为`路由组件`和`动态组件`。</span><br><span class="line"></span><br><span class="line">*   `activated`表示进入组件的生命周期，`deactivated`表示离开组件的生命周期</span><br><span class="line">*   `include`表示匹配到的才缓存，`exclude`表示匹配到的都不缓存</span><br><span class="line">*   `max`表示最多可以缓存多少组件</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">关于keep-alive的基本用法：</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">keep-alive</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">component</span> <span class="attr">:is</span>=<span class="string">&quot;view&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></span><br><span class="line">使用includes和exclude：</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">keep-alive</span> <span class="attr">include</span>=<span class="string">&quot;a,b&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">component</span> <span class="attr">:is</span>=<span class="string">&quot;view&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 正则表达式 (使用 `v-bind`) --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">keep-alive</span> <span class="attr">:include</span>=<span class="string">&quot;/a|b/&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">component</span> <span class="attr">:is</span>=<span class="string">&quot;view&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 数组 (使用 `v-bind`) --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">keep-alive</span> <span class="attr">:include</span>=<span class="string">&quot;[&#x27;a&#x27;, &#x27;b&#x27;]&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">component</span> <span class="attr">:is</span>=<span class="string">&quot;view&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></span><br><span class="line">匹配首先检查组件自身的 name 选项，如果 name 选项不可用，则匹配它的局部注册名称 (父组件 components 选项的键值)，匿名组件不能被匹配</span><br><span class="line"></span><br><span class="line">设置了 keep-alive 缓存的组件，会多出两个生命周期钩子（activated与deactivated）：</span><br><span class="line"></span><br><span class="line">首次进入组件时：beforeRouteEnter &gt; beforeCreate &gt; created&gt; mounted &gt; activated &gt; ... ... &gt; beforeRouteLeave &gt; deactivated</span><br><span class="line"></span><br><span class="line">再次进入组件时：beforeRouteEnter &gt;activated &gt; ... ... &gt; beforeRouteLeave &gt; deactivated</span><br></pre></td></tr></table></figure>
<h1 id="15-你可以实现一个虚拟DOM吗"><a href="#15-你可以实现一个虚拟DOM吗" class="headerlink" title="15.你可以实现一个虚拟DOM吗"></a>15.你可以实现一个虚拟DOM吗</h1><p><strong>先看浏览器对<code>HTML</code>的理解</strong>：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>My title<span class="tag">&lt;/<span class="name">h1</span>&gt;</span>  </span><br><span class="line">    Some text content  </span><br><span class="line">    <span class="comment">&lt;!-- <span class="doctag">TODO:</span> Add tagline --&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>当浏览器读到这些代码时，它会建立一个DOM树来保持追踪所有内容，如同你会画一张家谱树来追踪家庭成员的发展一样。 上述 HTML 对应的 DOM 节点树如下图所示：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7ee0f38a11304a768737a2e7de69e7e9~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="544ef95bdd7c96a19d700ce613ab425a_dom-tree.png"></p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">每个元素都是一个节点。每段文字也是一个节点。甚至注释也都是节点。一个节点就是页面的一个部分。就像家谱树一样，每个节点都可以有孩子节点 (也就是说每个部分可以包含其它的一些部分)。</span><br><span class="line"></span><br><span class="line"><span class="strong">**再看`Vue`对`HTML template`的理解**</span></span><br><span class="line"></span><br><span class="line">Vue 通过建立一个<span class="strong">**虚拟 DOM**</span> 来追踪自己要如何改变真实 DOM。因为它所包含的信息会告诉 Vue 页面上需要渲染什么样的节点，包括及其子节点的描述信息。我们把这样的节点描述为“虚拟节点 (virtual node)”，也常简写它为“<span class="strong">**VNode**</span>”。“虚拟 DOM”是我们对由 Vue 组件树建立起来的整个 VNode 树的称呼。</span><br><span class="line"></span><br><span class="line">简言之，浏览器对HTML的理解是DOM树，Vue对<span class="code">`HTML`</span>的理解是虚拟DOM，最后在<span class="code">`patch`</span>阶段通过DOM操作的api将其渲染成真实的DOM节点。</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<h2 id="如何实现虚拟DOM"><a href="#如何实现虚拟DOM" class="headerlink" title="如何实现虚拟DOM"></a>如何实现虚拟DOM</h2><p>首先可以看看<code>vue</code>中<code>VNode</code>的结构</p>
<p>源码位置：src/core/vdom/vnode.js</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">export default <span class="keyword">class</span> <span class="title class_">VNode</span> &#123;</span><br><span class="line">  tag: string | void;</span><br><span class="line">  <span class="keyword">data</span>: VNodeData | void;</span><br><span class="line">  children: ?Array&lt;VNode&gt;;</span><br><span class="line">  text: string | void;</span><br><span class="line">  elm: Node | void;</span><br><span class="line">  ns: string | void;</span><br><span class="line">  context: Component | void; <span class="comment">// rendered in this component&#x27;s scope</span></span><br><span class="line">  functionalContext: Component | void; <span class="comment">// only for functional component root nodes</span></span><br><span class="line">  key: string | number | void;</span><br><span class="line">  componentOptions: VNodeComponentOptions | void;</span><br><span class="line">  componentInstance: Component | void; <span class="comment">// component instance</span></span><br><span class="line">  parent: VNode | void; <span class="comment">// component placeholder node</span></span><br><span class="line">  raw: boolean; <span class="comment">// contains raw HTML? (server only)</span></span><br><span class="line">  isStatic: boolean; <span class="comment">// hoisted static node</span></span><br><span class="line">  isRootInsert: boolean; <span class="comment">// necessary for enter transition check</span></span><br><span class="line">  isComment: boolean; <span class="comment">// empty comment placeholder?</span></span><br><span class="line">  isCloned: boolean; <span class="comment">// is a cloned node?</span></span><br><span class="line">  isOnce: boolean; <span class="comment">// is a v-once node?</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span> (</span><br><span class="line">    tag?: string,</span><br><span class="line">    <span class="keyword">data</span>?: VNodeData,</span><br><span class="line">    children?: ?Array&lt;VNode&gt;,</span><br><span class="line">    text?: string,</span><br><span class="line">    elm?: Node,</span><br><span class="line">    context?: Component,</span><br><span class="line">    componentOptions?: VNodeComponentOptions</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="comment">/*当前节点的标签名*/</span></span><br><span class="line">    <span class="keyword">this</span>.tag = tag</span><br><span class="line">    <span class="comment">/*当前节点对应的对象，包含了具体的一些数据信息，是一个VNodeData类型，可以参考VNodeData类型中的数据信息*/</span></span><br><span class="line">    <span class="keyword">this</span>.<span class="keyword">data</span> = <span class="keyword">data</span></span><br><span class="line">    <span class="comment">/*当前节点的子节点，是一个数组*/</span></span><br><span class="line">    <span class="keyword">this</span>.children = children</span><br><span class="line">    <span class="comment">/*当前节点的文本*/</span></span><br><span class="line">    <span class="keyword">this</span>.text = text</span><br><span class="line">    <span class="comment">/*当前虚拟节点对应的真实dom节点*/</span></span><br><span class="line">    <span class="keyword">this</span>.elm = elm</span><br><span class="line">    <span class="comment">/*当前节点的名字空间*/</span></span><br><span class="line">    <span class="keyword">this</span>.ns = undefined</span><br><span class="line">    <span class="comment">/*编译作用域*/</span></span><br><span class="line">    <span class="keyword">this</span>.context = context</span><br><span class="line">    <span class="comment">/*函数化组件作用域*/</span></span><br><span class="line">    <span class="keyword">this</span>.functionalContext = undefined</span><br><span class="line">    <span class="comment">/*节点的key属性，被当作节点的标志，用以优化*/</span></span><br><span class="line">    <span class="keyword">this</span>.key = <span class="keyword">data</span> &amp;&amp; <span class="keyword">data</span>.key</span><br><span class="line">    <span class="comment">/*组件的option选项*/</span></span><br><span class="line">    <span class="keyword">this</span>.componentOptions = componentOptions</span><br><span class="line">    <span class="comment">/*当前节点对应的组件的实例*/</span></span><br><span class="line">    <span class="keyword">this</span>.componentInstance = undefined</span><br><span class="line">    <span class="comment">/*当前节点的父节点*/</span></span><br><span class="line">    <span class="keyword">this</span>.parent = undefined</span><br><span class="line">    <span class="comment">/*简而言之就是是否为原生HTML或只是普通文本，innerHTML的时候为true，textContent的时候为false*/</span></span><br><span class="line">    <span class="keyword">this</span>.raw = <span class="literal">false</span></span><br><span class="line">    <span class="comment">/*静态节点标志*/</span></span><br><span class="line">    <span class="keyword">this</span>.isStatic = <span class="literal">false</span></span><br><span class="line">    <span class="comment">/*是否作为跟节点插入*/</span></span><br><span class="line">    <span class="keyword">this</span>.isRootInsert = <span class="literal">true</span></span><br><span class="line">    <span class="comment">/*是否为注释节点*/</span></span><br><span class="line">    <span class="keyword">this</span>.isComment = <span class="literal">false</span></span><br><span class="line">    <span class="comment">/*是否为克隆节点*/</span></span><br><span class="line">    <span class="keyword">this</span>.isCloned = <span class="literal">false</span></span><br><span class="line">    <span class="comment">/*是否有v-once指令*/</span></span><br><span class="line">    <span class="keyword">this</span>.isOnce = <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// DEPRECATED: alias for componentInstance for backwards compat.</span></span><br><span class="line">  <span class="comment">/* istanbul ignore next https://github.com/answershuto/learnVue*/</span></span><br><span class="line">  <span class="keyword">get</span> child (): Component | void &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.componentInstance</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<p>这里对<code>VNode</code>进行稍微的说明：</p>
<ul>
<li>所有对象的 <code>context</code> 选项都指向了 <code>Vue</code> 实例</li>
<li><code>elm</code> 属性则指向了其相对应的真实 <code>DOM</code> 节点</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vue<span class="string">`是通过`</span>createElement<span class="string">`生成`</span>VNode</span><br></pre></td></tr></table></figure>
<p>源码位置：src/core/vdom/create-element.js</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">createElement</span> (</span><br><span class="line">  <span class="attr">context</span>: <span class="title class_">Component</span>,</span><br><span class="line">  <span class="attr">tag</span>: <span class="built_in">any</span>,</span><br><span class="line">  <span class="attr">data</span>: <span class="built_in">any</span>,</span><br><span class="line">  <span class="attr">children</span>: <span class="built_in">any</span>,</span><br><span class="line">  <span class="attr">normalizationType</span>: <span class="built_in">any</span>,</span><br><span class="line">  <span class="attr">alwaysNormalize</span>: <span class="built_in">boolean</span></span><br><span class="line">): <span class="title class_">VNode</span> | <span class="title class_">Array</span>&lt;<span class="title class_">VNode</span>&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(data) || <span class="title function_">isPrimitive</span>(data)) &#123;</span><br><span class="line">    normalizationType = children</span><br><span class="line">    children = data</span><br><span class="line">    data = <span class="literal">undefined</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">isTrue</span>(alwaysNormalize)) &#123;</span><br><span class="line">    normalizationType = <span class="variable constant_">ALWAYS_NORMALIZE</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">_createElement</span>(context, tag, data, children, normalizationType)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<p>上面可以看到<code>createElement</code> 方法实际上是对 <code>_createElement</code> 方法的封装，对参数的传入进行了判断</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">export function <span class="built_in">_createElement</span>(</span><br><span class="line">    context: Component,</span><br><span class="line">    tag?: string | Class&lt;Component&gt; | Function | Object,</span><br><span class="line">    data?: VNodeData,</span><br><span class="line">    children?: any,</span><br><span class="line">    normalizationType?: number</span><br><span class="line">): VNode | Array&lt;VNode&gt; &#123;</span><br><span class="line">    if (isDef(data) &amp;&amp; <span class="built_in">isDef</span>((data: any)<span class="selector-class">.__ob__</span>)) &#123;</span><br><span class="line">        process<span class="selector-class">.env</span><span class="selector-class">.NODE_ENV</span> !== &#x27;production&#x27; &amp;&amp; <span class="built_in">warn</span>(</span><br><span class="line">            `Avoid using observed data object as vnode data: $&#123;JSON.stringify(data)&#125;\n` +</span><br><span class="line">            &#x27;Always create fresh vnode data objects in each render!&#x27;,</span><br><span class="line">            context`</span><br><span class="line">        )</span><br><span class="line">        return <span class="built_in">createEmptyVNode</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// object syntax in v-bind</span></span><br><span class="line">    if (isDef(data) &amp;&amp; <span class="built_in">isDef</span>(data.is)) &#123;</span><br><span class="line">        tag = data<span class="selector-class">.is</span></span><br><span class="line">    &#125;</span><br><span class="line">    if (!tag) &#123;</span><br><span class="line">        <span class="comment">// in case of component :is set to falsy value</span></span><br><span class="line">        return <span class="built_in">createEmptyVNode</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    ... </span><br><span class="line">    <span class="comment">// support single function children as default scoped slot</span></span><br><span class="line">    if (Array.isArray(children) &amp;&amp;</span><br><span class="line">        typeof children<span class="selector-attr">[0]</span> === &#x27;function&#x27;</span><br><span class="line">    ) &#123;</span><br><span class="line">        data = data || &#123;&#125;</span><br><span class="line">        data<span class="selector-class">.scopedSlots</span> = &#123; default: children[<span class="number">0</span>] &#125;</span><br><span class="line">        children<span class="selector-class">.length</span> = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    if (normalizationType === ALWAYS_NORMALIZE) &#123;</span><br><span class="line">        children = <span class="built_in">normalizeChildren</span>(children)</span><br><span class="line">    &#125; else if ( === SIMPLE_NORMALIZE) &#123;</span><br><span class="line">        children = <span class="built_in">simpleNormalizeChildren</span>(children)</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// 创建VNode</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<p>可以看到<code>_createElement</code>接收5个参数：</p>
<ul>
<li><code>context</code> 表示 <code>VNode</code> 的上下文环境，是 <code>Component</code> 类型</li>
<li>tag 表示标签，它可以是一个字符串，也可以是一个 <code>Component</code></li>
<li><code>data</code> 表示 <code>VNode</code> 的数据，它是一个 <code>VNodeData</code> 类型</li>
<li><code>children</code> 表示当前 <code>VNode</code>的子节点，它是任意类型的</li>
<li><code>normalizationType</code> 表示子节点规范的类型，类型不同规范的方法也就不一样，主要是参考 <code>render</code> 函数是编译生成的还是用户手写的</li>
</ul>
<p>根据<code>normalizationType</code> 的类型，<code>children</code>会有不同的定义</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if (<span class="attr">normalizationType</span> === ALWAYS_NORMALIZE) &#123;</span><br><span class="line">    <span class="attr">children</span> = normalizeChildren(children)</span><br><span class="line">&#125; else if ( === SIMPLE_NORMALIZE) &#123;</span><br><span class="line">    <span class="attr">children</span> = simpleNormalizeChildren(children)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<p><code>simpleNormalizeChildren</code>方法调用场景是 <code>render</code> 函数是编译生成的</p>
<p><code>normalizeChildren</code>方法调用场景分为下面两种：</p>
<ul>
<li><code>render</code> 函数是用户手写的</li>
<li>编译 <code>slot</code>、<code>v-for</code> 的时候会产生嵌套数组</li>
</ul>
<p>无论是<code>simpleNormalizeChildren</code>还是<code>normalizeChildren</code>都是对<code>children</code>进行规范（使<code>children</code> 变成了一个类型为 <code>VNode</code> 的 <code>Array</code>），这里就不展开说了</p>
<p>规范化<code>children</code>的源码位置在：src/core/vdom/helpers/normalzie-children.js</p>
<p>在规范化<code>children</code>后，就去创建<code>VNode</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> vnode, ns</span><br><span class="line"><span class="comment">// 对tag进行判断</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> tag === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="title class_">Ctor</span></span><br><span class="line">  ns = (context.<span class="property">$vnode</span> &amp;&amp; context.<span class="property">$vnode</span>.<span class="property">ns</span>) || config.<span class="title function_">getTagNamespace</span>(tag)</span><br><span class="line">  <span class="keyword">if</span> (config.<span class="title function_">isReservedTag</span>(tag)) &#123;</span><br><span class="line">    <span class="comment">// 如果是内置的节点，则直接创建一个普通VNode</span></span><br><span class="line">    vnode = <span class="keyword">new</span> <span class="title class_">VNode</span>(</span><br><span class="line">      config.<span class="title function_">parsePlatformTagName</span>(tag), data, children,</span><br><span class="line">      <span class="literal">undefined</span>, <span class="literal">undefined</span>, context</span><br><span class="line">    )</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_">isDef</span>(<span class="title class_">Ctor</span> = <span class="title function_">resolveAsset</span>(context.<span class="property">$options</span>, <span class="string">&#x27;components&#x27;</span>, tag))) &#123;</span><br><span class="line">    <span class="comment">// component</span></span><br><span class="line">    <span class="comment">// 如果是component类型，则会通过createComponent创建VNode节点</span></span><br><span class="line">    vnode = <span class="title function_">createComponent</span>(<span class="title class_">Ctor</span>, data, context, children, tag)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    vnode = <span class="keyword">new</span> <span class="title class_">VNode</span>(</span><br><span class="line">      tag, data, children,</span><br><span class="line">      <span class="literal">undefined</span>, <span class="literal">undefined</span>, context</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// direct component options / constructor</span></span><br><span class="line">  vnode = <span class="title function_">createComponent</span>(tag, data, context, children)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">createComponent<span class="string">`同样是创建`</span><span class="title class_">VNode</span></span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<p>源码位置：src/core/vdom/create-component.js</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">createComponent</span> (</span><br><span class="line">  <span class="title class_">Ctor</span>: <span class="title class_">Class</span>&lt;<span class="title class_">Component</span>&gt; | <span class="title class_">Function</span> | <span class="title class_">Object</span> | <span class="keyword">void</span>,</span><br><span class="line">  <span class="attr">data</span>: ?<span class="title class_">VNodeData</span>,</span><br><span class="line">  <span class="attr">context</span>: <span class="title class_">Component</span>,</span><br><span class="line">  <span class="attr">children</span>: ?<span class="title class_">Array</span>&lt;<span class="title class_">VNode</span>&gt;,</span><br><span class="line">  tag?: string</span><br><span class="line">): <span class="title class_">VNode</span> | <span class="title class_">Array</span>&lt;<span class="title class_">VNode</span>&gt; | <span class="keyword">void</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">isUndef</span>(<span class="title class_">Ctor</span>)) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line"> <span class="comment">// 构建子类构造函数 </span></span><br><span class="line">  <span class="keyword">const</span> baseCtor = context.<span class="property">$options</span>.<span class="property">_base</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// plain options object: turn it into a constructor</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">isObject</span>(<span class="title class_">Ctor</span>)) &#123;</span><br><span class="line">    <span class="title class_">Ctor</span> = baseCtor.<span class="title function_">extend</span>(<span class="title class_">Ctor</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// if at this stage it&#x27;s not a constructor or an async component factory,</span></span><br><span class="line">  <span class="comment">// reject.</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="title class_">Ctor</span> !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span>) &#123;</span><br><span class="line">      <span class="title function_">warn</span>(<span class="string">`Invalid Component definition: <span class="subst">$&#123;<span class="built_in">String</span>(Ctor)&#125;</span>`</span>, context)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// async component</span></span><br><span class="line">  <span class="keyword">let</span> asyncFactory</span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">isUndef</span>(<span class="title class_">Ctor</span>.<span class="property">cid</span>)) &#123;</span><br><span class="line">    asyncFactory = <span class="title class_">Ctor</span></span><br><span class="line">    <span class="title class_">Ctor</span> = <span class="title function_">resolveAsyncComponent</span>(asyncFactory, baseCtor, context)</span><br><span class="line">    <span class="keyword">if</span> (<span class="title class_">Ctor</span> === <span class="literal">undefined</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">createAsyncPlaceholder</span>(</span><br><span class="line">        asyncFactory,</span><br><span class="line">        data,</span><br><span class="line">        context,</span><br><span class="line">        children,</span><br><span class="line">        tag</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  data = data || &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// resolve constructor options in case global mixins are applied after</span></span><br><span class="line">  <span class="comment">// component constructor creation</span></span><br><span class="line">  <span class="title function_">resolveConstructorOptions</span>(<span class="title class_">Ctor</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// transform component v-model data into props &amp; events</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">isDef</span>(data.<span class="property">model</span>)) &#123;</span><br><span class="line">    <span class="title function_">transformModel</span>(<span class="title class_">Ctor</span>.<span class="property">options</span>, data)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// extract props</span></span><br><span class="line">  <span class="keyword">const</span> propsData = <span class="title function_">extractPropsFromVNodeData</span>(data, <span class="title class_">Ctor</span>, tag)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// functional component</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">isTrue</span>(<span class="title class_">Ctor</span>.<span class="property">options</span>.<span class="property">functional</span>)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">createFunctionalComponent</span>(<span class="title class_">Ctor</span>, propsData, data, context, children)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// extract listeners, since these needs to be treated as</span></span><br><span class="line">  <span class="comment">// child component listeners instead of DOM listeners</span></span><br><span class="line">  <span class="keyword">const</span> listeners = data.<span class="property">on</span></span><br><span class="line">  <span class="comment">// replace with listeners with .native modifier</span></span><br><span class="line">  <span class="comment">// so it gets processed during parent component patch.</span></span><br><span class="line">  data.<span class="property">on</span> = data.<span class="property">nativeOn</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">isTrue</span>(<span class="title class_">Ctor</span>.<span class="property">options</span>.<span class="property">abstract</span>)) &#123;</span><br><span class="line">    <span class="keyword">const</span> slot = data.<span class="property">slot</span></span><br><span class="line">    data = &#123;&#125;</span><br><span class="line">    <span class="keyword">if</span> (slot) &#123;</span><br><span class="line">      data.<span class="property">slot</span> = slot</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 安装组件钩子函数，把钩子函数合并到data.hook中</span></span><br><span class="line">  <span class="title function_">installComponentHooks</span>(data)</span><br><span class="line"></span><br><span class="line">  <span class="comment">//实例化一个VNode返回。组件的VNode是没有children的</span></span><br><span class="line">  <span class="keyword">const</span> name = <span class="title class_">Ctor</span>.<span class="property">options</span>.<span class="property">name</span> || tag</span><br><span class="line">  <span class="keyword">const</span> vnode = <span class="keyword">new</span> <span class="title class_">VNode</span>(</span><br><span class="line">    <span class="string">`vue-component-<span class="subst">$&#123;Ctor.cid&#125;</span><span class="subst">$&#123;name ? <span class="string">`-<span class="subst">$&#123;name&#125;</span>`</span> : <span class="string">&#x27;&#x27;</span>&#125;</span>`</span>,</span><br><span class="line">    data, <span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="literal">undefined</span>, context,</span><br><span class="line">    &#123; <span class="title class_">Ctor</span>, propsData, listeners, tag, children &#125;,</span><br><span class="line">    asyncFactory</span><br><span class="line">  )</span><br><span class="line">  <span class="keyword">if</span> (__WEEX__ &amp;&amp; <span class="title function_">isRecyclableComponent</span>(vnode)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">renderRecyclableComponentTemplate</span>(vnode)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> vnode</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<p>稍微提下<code>createComponent</code>生成<code>VNode</code>的三个关键流程：</p>
<ul>
<li>构造子类构造函数<code>Ctor</code></li>
<li><code>installComponentHooks</code>安装组件钩子函数</li>
<li>实例化 <code>vnode</code></li>
</ul>
<h2 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h2><p><code>createElement</code> 创建 <code>VNode</code> 的过程，每个 <code>VNode</code> 有 <code>children</code>，<code>children</code> 每个元素也是一个<code>VNode</code>，这样就形成了一个虚拟树结构，用于描述真实的<code>DOM</code>树结构</p>
<h1 id="16-为什么data属性是一个函数而不是一个对象，具体原因是什么"><a href="#16-为什么data属性是一个函数而不是一个对象，具体原因是什么" class="headerlink" title="16.为什么data属性是一个函数而不是一个对象，具体原因是什么"></a>16.为什么data属性是一个函数而不是一个对象，具体原因是什么</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">是不是一定是函数，得看场景。并且，也无需担心什么时候该将<span class="string">`data`</span>写为函数还是对象，因为<span class="string">`vue`</span>内部已经做了处理，并在控制台输出错误信息。</span><br><span class="line"></span><br><span class="line">**场景一**：<span class="string">`new Vue(&#123;data: ...&#125;)`</span>  </span><br><span class="line">这种场景主要为项目入口或者多个<span class="string">`html`</span>页面各实例化一个<span class="string">`Vue`</span>时，这里的<span class="string">`data`</span>即可用对象的形式，也可用工厂函数返回对象的形式。因为，这里的<span class="string">`data`</span>只会出现一次，不存在重复引用而引起的数据污染问题。</span><br><span class="line"></span><br><span class="line">**场景二**：组件场景中的选项  </span><br><span class="line">在生成组件<span class="string">`vnode`</span>的过程中，组件会在生成构造函数的过程中执行合并策略：</span><br><span class="line"></span><br><span class="line"><span class="string">``</span><span class="string">`</span></span><br><span class="line"><span class="string">// data合并策略</span></span><br><span class="line"><span class="string">strats.data = function (</span></span><br><span class="line"><span class="string">  parentVal,</span></span><br><span class="line"><span class="string">  childVal,</span></span><br><span class="line"><span class="string">  vm</span></span><br><span class="line"><span class="string">) &#123;</span></span><br><span class="line"><span class="string">  if (!vm) &#123;</span></span><br><span class="line"><span class="string">    if (childVal &amp;&amp; typeof childVal !== &#x27;function&#x27;) &#123;</span></span><br><span class="line"><span class="string">      process.env.NODE_ENV !== &#x27;production&#x27; &amp;&amp; warn(</span></span><br><span class="line"><span class="string">        &#x27;The &quot;data&quot; option should be a function &#x27; +</span></span><br><span class="line"><span class="string">        &#x27;that returns a per-instance value in component &#x27; +</span></span><br><span class="line"><span class="string">        &#x27;definitions.&#x27;,</span></span><br><span class="line"><span class="string">        vm</span></span><br><span class="line"><span class="string">      );</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">      return parentVal</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    return mergeDataOrFn(parentVal, childVal)</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  return mergeDataOrFn(parentVal, childVal, vm)</span></span><br><span class="line"><span class="string">&#125;;</span></span><br><span class="line"><span class="string">`</span><span class="string">``</span></span><br><span class="line"></span><br><span class="line">如果合并过程中发现子组件的数据不是函数，即<span class="string">`typeof childVal !== &#x27;function&#x27;`</span>成立，进而在开发环境会在控制台输出警告并且直接返回<span class="string">`parentVal`</span>，说明这里压根就没有把<span class="string">`childVal`</span>中的任何<span class="string">`data`</span>信息合并到<span class="string">`options`</span>中去。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">上面讲到组件data必须是一个函数，不知道大家有没有思考过这是为什么呢？</span><br><span class="line"></span><br><span class="line">在我们定义好一个组件的时候，vue最终都会通过<span class="title class_">Vue</span>.<span class="title function_">extend</span>()构成组件实例</span><br><span class="line"></span><br><span class="line">这里我们模仿组件构造函数，定义data属性，采用对象的形式</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Component</span>(<span class="params"></span>)&#123;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Component</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">data</span> = &#123;</span><br><span class="line">  count : <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line">创建两个组件实例</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> componentA = <span class="keyword">new</span> <span class="title class_">Component</span>()</span><br><span class="line"><span class="keyword">const</span> componentB = <span class="keyword">new</span> <span class="title class_">Component</span>()</span><br><span class="line">修改componentA组件data属性的值，componentB中的值也发生了改变</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(componentB.<span class="property">data</span>.<span class="property">count</span>)  <span class="comment">// 0</span></span><br><span class="line">componentA.<span class="property">data</span>.<span class="property">count</span> = <span class="number">1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(componentB.<span class="property">data</span>.<span class="property">count</span>)  <span class="comment">// 1</span></span><br><span class="line">产生这样的原因这是两者共用了同一个内存地址，componentA修改的内容，同样对componentB产生了影响</span><br><span class="line"></span><br><span class="line">如果我们采用函数的形式，则不会出现这种情况（函数返回的对象内存地址并不相同）</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Component</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">data</span> = <span class="variable language_">this</span>.<span class="title function_">data</span>()</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Component</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">data</span> = <span class="keyword">function</span> (<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      count : <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">修改componentA组件data属性的值，componentB中的值不受影响</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(componentB.<span class="property">data</span>.<span class="property">count</span>)  <span class="comment">// 0</span></span><br><span class="line">componentA.<span class="property">data</span>.<span class="property">count</span> = <span class="number">1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(componentB.<span class="property">data</span>.<span class="property">count</span>)  <span class="comment">// 0</span></span><br><span class="line">vue组件可能会有很多个实例，采用函数返回一个全新data形式，使每个实例对象的数据不会受到其他实例对象数据的污染</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<h1 id="17-Vue2的初始化过程你有过了解吗，做了哪些事情"><a href="#17-Vue2的初始化过程你有过了解吗，做了哪些事情" class="headerlink" title="17.Vue2的初始化过程你有过了解吗，做了哪些事情"></a>17.Vue2的初始化过程你有过了解吗，做了哪些事情</h1><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">new Vue走到了vue的构造函数中：`<span class="attribute">src</span>\core\instance\index<span class="selector-class">.js</span>`文件。</span><br><span class="line"></span><br><span class="line">this<span class="selector-class">._init</span>(options)</span><br><span class="line"></span><br><span class="line">然后从Mixin增加的原型方法看，<span class="built_in">initMixin</span>(Vue)，调用的是为Vue增加的原型方法_init</span><br><span class="line"></span><br><span class="line"><span class="comment">// src/core/instance/init.js</span></span><br><span class="line"></span><br><span class="line">function initMixin (Vue) &#123;</span><br><span class="line">  Vue<span class="selector-class">.prototype</span><span class="selector-class">._init</span> = function (options) &#123;</span><br><span class="line">     <span class="selector-tag">var</span> vm = this; 创建vm, </span><br><span class="line">     ...</span><br><span class="line">     <span class="comment">// 合并options 到 vm.$options</span></span><br><span class="line">     vm.<span class="variable">$options</span> = <span class="built_in">mergeOptions</span>(  </span><br><span class="line">       resolveConstructorOptions(vm.constructor), </span><br><span class="line">       options || &#123;&#125;,  </span><br><span class="line">       vm </span><br><span class="line">     );</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">   <span class="built_in">initLifecycle</span>(vm); <span class="comment">//初始生命周期</span></span><br><span class="line">   <span class="built_in">initEvents</span>(vm); <span class="comment">//初始化事件</span></span><br><span class="line">   <span class="built_in">initRender</span>(vm); <span class="comment">//初始render函数</span></span><br><span class="line">   <span class="built_in">callHook</span>(vm, &#x27;beforeCreate&#x27;); <span class="comment">//执行 beforeCreate生命周期钩子</span></span><br><span class="line">   ...</span><br><span class="line">   <span class="built_in">initState</span>(vm);  <span class="comment">//初始化data，props，methods computed，watch </span></span><br><span class="line">   ...</span><br><span class="line">   <span class="built_in">callHook</span>(vm, &#x27;created&#x27;);  <span class="comment">//执行 created 生命周期钩子</span></span><br><span class="line">   </span><br><span class="line">   if (vm.$options.el) &#123;</span><br><span class="line">      vm.<span class="variable">$mount</span>(vm.$options.el); <span class="comment">//这里也是重点，下面需要用到</span></span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">总结</span><br><span class="line"></span><br><span class="line">所以，从上面的函数看来，new vue所做的事情，就像一个流程图一样展开了，分别是</span><br><span class="line"></span><br><span class="line">-   合并配置</span><br><span class="line">-   初始化生命周期</span><br><span class="line">-   初始化事件</span><br><span class="line">-   初始化渲染</span><br><span class="line">-   调用 `beforeCreate` 钩子函数</span><br><span class="line">-   init injections and reactivity（这个阶段属性都已注入绑定，而且被 `<span class="variable">$watch</span>` 变成reactivity，但是 `<span class="variable">$el</span>` 还是没有生成，也就是DOM没有生成）</span><br><span class="line">-   初始化state状态（初始化了data、props、computed、watcher）</span><br><span class="line">-   调用created钩子函数。</span><br><span class="line"></span><br><span class="line">在初始化的最后，检测到如果有 el 属性，则调用 vm.<span class="variable">$mount</span> 方法挂载 vm，挂载的目标就是把模板渲染成最终的 DOM。</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<h1 id="18-Vue3初始化的一个大概流程"><a href="#18-Vue3初始化的一个大概流程" class="headerlink" title="18.Vue3初始化的一个大概流程"></a>18.Vue3初始化的一个大概流程</h1><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line">- 初始化的一个大概流程</span><br><span class="line"></span><br><span class="line"><span class="built_in">createApp</span>() =&gt; <span class="built_in">mount</span>() =&gt; <span class="built_in">render</span>() =&gt; <span class="built_in">patch</span>() =&gt; <span class="built_in">processComponent</span>() =&gt; <span class="built_in">mountComponent</span>()</span><br><span class="line"></span><br><span class="line">- 简易版流程编写</span><br><span class="line"></span><br><span class="line"><span class="number">1</span><span class="selector-class">.Vue</span><span class="selector-class">.createApp</span>() 实际执行的是renderer的<span class="built_in">createApp</span>()</span><br><span class="line"></span><br><span class="line"><span class="number">2</span><span class="selector-class">.renderer</span>是createRenderer这个方法创建</span><br><span class="line"></span><br><span class="line"><span class="number">3</span><span class="selector-class">.renderer</span>的<span class="built_in">createApp</span>()是<span class="built_in">createAppAPI</span>()返回的</span><br><span class="line"></span><br><span class="line"><span class="number">4</span><span class="selector-class">.createAppApi</span>接受到render之后，创建一个app实例，定义mount方法</span><br><span class="line"></span><br><span class="line"><span class="number">5</span><span class="selector-class">.mount</span>会调用render函数。将vnode转换为真实dom</span><br><span class="line"></span><br><span class="line"><span class="built_in">createRenderer</span>() =&gt; renderer =&gt; renderer<span class="selector-class">.createApp</span>() &lt;= <span class="built_in">createAppApi</span>()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;<span class="selector-tag">div</span> id=&quot;app&quot;&gt;&lt;/<span class="selector-tag">div</span>&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="comment">// 3.createAppAPI</span></span><br><span class="line">    const createAppAPI = render =&gt; &#123;</span><br><span class="line">        return function <span class="built_in">createApp</span>(rootComponent) &#123;</span><br><span class="line">            <span class="comment">// 返回应用程序实例</span></span><br><span class="line">            const app = &#123;</span><br><span class="line">                <span class="built_in">mount</span>(rootContainer) &#123;</span><br><span class="line">                    <span class="comment">// 挂载vnode =&gt; dom</span></span><br><span class="line">                    const vnode = &#123;</span><br><span class="line">                        tag: rootComponent</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 执行渲染</span></span><br><span class="line">                    <span class="built_in">render</span>(vnode, rootContainer)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return app;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 创建createApp</span></span><br><span class="line">    const Vue = &#123;</span><br><span class="line">        <span class="built_in">createApp</span>(options) &#123;</span><br><span class="line">            <span class="comment">//实际执行的为renderer的createApp()</span></span><br><span class="line">            <span class="comment">// 返回app实例</span></span><br><span class="line">            return renderer<span class="selector-class">.createApp</span>(options)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.实现renderer工厂函数</span></span><br><span class="line">    const createRenderer = options =&gt; &#123;</span><br><span class="line">        <span class="comment">// 实现patch</span></span><br><span class="line">        const patch = (n1, n2, container) =&gt; &#123;</span><br><span class="line">            <span class="comment">// 获取根组件配置</span></span><br><span class="line">            const rootComponent = n2<span class="selector-class">.tag</span>;</span><br><span class="line">            const ctx = &#123; ..<span class="selector-class">.rootComponent</span><span class="selector-class">.data</span>()&#125;</span><br><span class="line">            <span class="comment">// 执行render获取vnode</span></span><br><span class="line">            const vnode = rootComponent<span class="selector-class">.render</span><span class="selector-class">.call</span>(ctx);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 转换vnode =&gt; dom</span></span><br><span class="line">            const parent = options<span class="selector-class">.querySelector</span>(container)</span><br><span class="line">            const child = options<span class="selector-class">.createElement</span>(vnode.tag)</span><br><span class="line">            if (typeof vnode.children === &#x27;string&#x27;) &#123;</span><br><span class="line">                child<span class="selector-class">.textContent</span> = vnode<span class="selector-class">.children</span></span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                <span class="comment">//array</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 追加</span></span><br><span class="line">            options<span class="selector-class">.insert</span>(child, parent)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 实现render</span></span><br><span class="line">        const render = (vnode, container) =&gt; &#123;</span><br><span class="line">            <span class="built_in">patch</span>(container._vnode || null, vnode, container)</span><br><span class="line">            container<span class="selector-class">._vnode</span> = vnode;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 该对象就是renderer</span></span><br><span class="line">        return &#123;</span><br><span class="line">            render,</span><br><span class="line">            createApp: <span class="built_in">createAppAPI</span>(render)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    const renderer = <span class="built_in">createRenderer</span>(&#123;</span><br><span class="line">        querySelector(el) &#123;</span><br><span class="line">            return document<span class="selector-class">.querySelector</span>(el)</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="built_in">createElement</span>(tag) &#123;</span><br><span class="line">            return document<span class="selector-class">.createElement</span>(tag)</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="built_in">insert</span>(child, parent) &#123;</span><br><span class="line">            parent<span class="selector-class">.appendChild</span>(child)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    Vue<span class="selector-class">.createApp</span>(&#123;</span><br><span class="line">        data() &#123;</span><br><span class="line">            return &#123;</span><br><span class="line">                bar: <span class="string">&#x27;hello,vue3&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="built_in">render</span>() &#123;</span><br><span class="line">            return &#123;</span><br><span class="line">                tag: <span class="string">&#x27;h1&#x27;</span>,</span><br><span class="line">                children: this.bar</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)<span class="selector-class">.mount</span>(&#x27;#app&#x27;)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<h1 id="19-vue3响应式api如何编写"><a href="#19-vue3响应式api如何编写" class="headerlink" title="19.vue3响应式api如何编写"></a>19.vue3响应式api如何编写</h1><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">var</span> activeEffect = null;</span><br><span class="line">function <span class="built_in">effect</span>(fn) &#123;</span><br><span class="line">  activeEffect = fn;</span><br><span class="line">  <span class="built_in">activeEffect</span>();</span><br><span class="line">  activeEffect = null; </span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">var</span> depsMap = new <span class="built_in">WeakMap</span>();</span><br><span class="line">function <span class="built_in">gather</span>(target, key) &#123;</span><br><span class="line">  <span class="comment">// 避免例如console.log(obj1.name)而触发gather</span></span><br><span class="line">  if (!activeEffect) return;</span><br><span class="line">  let depMap = depsMap<span class="selector-class">.get</span>(target);</span><br><span class="line">  if (!depMap) &#123;</span><br><span class="line">    depsMap<span class="selector-class">.set</span>(target, (depMap = new Map()));</span><br><span class="line">  &#125;</span><br><span class="line">  let dep = depMap<span class="selector-class">.get</span>(key);</span><br><span class="line">  if (!dep) &#123;</span><br><span class="line">    depMap<span class="selector-class">.set</span>(key, (dep = new Set()));</span><br><span class="line">  &#125;</span><br><span class="line">  dep<span class="selector-class">.add</span>(activeEffect)</span><br><span class="line">&#125;</span><br><span class="line">function <span class="built_in">trigger</span>(target, key) &#123;</span><br><span class="line">  let depMap = depsMap<span class="selector-class">.get</span>(target);</span><br><span class="line">  if (depMap) &#123;</span><br><span class="line">    const dep = depMap<span class="selector-class">.get</span>(key);</span><br><span class="line">    if (dep) &#123;</span><br><span class="line">      dep<span class="selector-class">.forEach</span>((effect) =&gt; <span class="built_in">effect</span>());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">function <span class="built_in">reactive</span>(target) &#123;</span><br><span class="line">  const handle = &#123;</span><br><span class="line">    <span class="built_in">set</span>(target, key, value, receiver) &#123;</span><br><span class="line">      Reflect<span class="selector-class">.set</span>(target, key, value, receiver);</span><br><span class="line">      <span class="built_in">trigger</span>(receiver, key); <span class="comment">// 设置值时触发自动更新</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="built_in">get</span>(target, key, receiver) &#123;</span><br><span class="line">      <span class="built_in">gather</span>(receiver, key); <span class="comment">// 访问时收集依赖</span></span><br><span class="line">      return Reflect<span class="selector-class">.get</span>(target, key, receiver);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">  return new <span class="built_in">Proxy</span>(target, handle);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function <span class="built_in">ref</span>(name)&#123;</span><br><span class="line">    return <span class="built_in">reactive</span>(</span><br><span class="line">        &#123;</span><br><span class="line">            value: name</span><br><span class="line">        &#125;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<h1 id="20-在Vue项目中你是如何做的SSR渲染"><a href="#20-在Vue项目中你是如何做的SSR渲染" class="headerlink" title="20.在Vue项目中你是如何做的SSR渲染"></a>20.在Vue项目中你是如何做的SSR渲染</h1><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">与传统 SPA (单页应用程序 (Single-Page Application)) 相比，服务器端渲染 (SSR) 的优势主要在于：</span><br><span class="line"></span><br><span class="line"><span class="bullet">*</span>   更好的 SEO，由于搜索引擎爬虫抓取工具可以直接查看完全渲染的页面。</span><br><span class="line"><span class="bullet">*</span>   更快的内容到达时间 (time-to-content)，特别是对于缓慢的网络情况或运行缓慢的设备。</span><br><span class="line"></span><br><span class="line">Vue.js 是构建客户端应用程序的框架。默认情况下，可以在浏览器中输出 Vue 组件，进行生成 DOM 和操作 DOM。然而，也可以将同一个组件渲染为服务器端的 HTML 字符串，将它们直接发送到浏览器，最后将这些静态标记&quot;激活&quot;为客户端上完全可交互的应用程序</span><br><span class="line"></span><br><span class="line">服务器渲染的 Vue.js 应用程序也可以被认为是&quot;同构&quot;或&quot;通用&quot;，因为应用程序的大部分代码都可以在服务器和客户端上运行</span><br><span class="line"></span><br><span class="line"><span class="bullet">*</span> Vue SSR是一个在SPA上进行改良的服务端渲染</span><br><span class="line"><span class="bullet">*</span> 通过Vue SSR渲染的页面，需要在客户端激活才能实现交互</span><br><span class="line"><span class="bullet">*</span> Vue SSR将包含两部分：服务端渲染的首屏，包含交互的SPA</span><br><span class="line"></span><br><span class="line">使用ssr不存在单例模式，每次用户请求都会创建一个新的vue实例</span><br><span class="line">实现ssr需要实现服务端首屏渲染和客户端激活</span><br><span class="line">服务端异步获取数据asyncData可以分为首屏异步获取和切换组件获取</span><br><span class="line">首屏异步获取数据，在服务端预渲染的时候就应该已经完成</span><br><span class="line">切换组件通过mixin混入，在beforeMount钩子完成数据获取</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<h1 id="21-怎么看Vue的diff算法"><a href="#21-怎么看Vue的diff算法" class="headerlink" title="21.怎么看Vue的diff算法"></a>21.怎么看Vue的diff算法</h1><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">diff 算法是一种通过同层的树节点进行比较的高效算法</span><br><span class="line"></span><br><span class="line">diff整体策略为：深度优先，同层比较</span><br><span class="line">比较只会在同层级进行, 不会跨层级比较</span><br><span class="line">比较的过程中，循环从两边向中间收拢</span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> 当数据发生改变时，订阅者watcher就会调用patch给真实的DOM打补丁</span><br><span class="line"><span class="bullet">-</span> 通过isSameVnode进行判断，相同则调用patchVnode方法</span><br><span class="line"><span class="bullet">-</span> patchVnode做了以下操作：</span><br><span class="line"><span class="bullet">  -</span> 找到对应的真实dom，称为el</span><br><span class="line"><span class="bullet">  -</span> 如果都有都有文本节点且不相等，将el文本节点设置为Vnode的文本节点</span><br><span class="line"><span class="bullet">  -</span> 如果oldVnode有子节点而VNode没有，则删除el子节点</span><br><span class="line"><span class="bullet">  -</span> 如果oldVnode没有子节点而VNode有，则将VNode的子节点真实化后添加到el</span><br><span class="line"><span class="bullet">  -</span> 如果两者都有子节点，则执行updateChildren函数比较子节点</span><br><span class="line"><span class="bullet">-</span> updateChildren主要做了以下操作：</span><br><span class="line"><span class="bullet">  -</span> 设置新旧VNode的头尾指针</span><br><span class="line"><span class="bullet">  -</span> 新旧头尾指针进行比较，循环向中间靠拢，根据情况调用patchVnode进行patch重复流程、调用createElem创建一个新节点，从哈希表寻找 key一致的VNode 节点再分情况操作</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<h1 id="22-从0到1构建一个Vue项目你需要做哪些内容"><a href="#22-从0到1构建一个Vue项目你需要做哪些内容" class="headerlink" title="22.从0到1构建一个Vue项目你需要做哪些内容"></a>22.从<code>0</code>到<code>1</code>构建一个<code>Vue</code>项目你需要做哪些内容</h1><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">*</span>   架子：选用合适的初始化脚手架(<span class="code">`vue-cli2.0`</span>或者<span class="code">`vue-cli3.0`</span>)</span><br><span class="line"><span class="bullet">*</span>   请求：数据<span class="code">`axios`</span>请求的配置</span><br><span class="line"><span class="bullet">*</span>   登录：登录注册系统</span><br><span class="line"><span class="bullet">*</span>   路由：路由管理页面</span><br><span class="line"><span class="bullet">*</span>   数据：<span class="code">`vuex`</span>全局数据管理</span><br><span class="line"><span class="bullet">*</span>   权限：权限管理系统</span><br><span class="line"><span class="bullet">*</span>   埋点：埋点系统</span><br><span class="line"><span class="bullet">*</span>   插件：第三方插件的选取以及引入方式</span><br><span class="line"><span class="bullet">*</span>   错误：错误页面</span><br><span class="line"><span class="bullet">*</span>   入口：前端资源直接当静态资源，或者服务端模板拉取</span><br><span class="line"><span class="bullet">*</span>   <span class="code">`SEO`</span>：如果考虑<span class="code">`SEO`</span>建议采用<span class="code">`SSR`</span>方案</span><br><span class="line"><span class="bullet">*</span>   组件：基础组件/业务组件</span><br><span class="line"><span class="bullet">*</span>   样式：样式预处理起，公共样式抽取</span><br><span class="line"><span class="bullet">*</span>   方法：公共方法抽离</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<h1 id="23-介绍一下-js-的数据类型有哪些，值是如何存储的"><a href="#23-介绍一下-js-的数据类型有哪些，值是如何存储的" class="headerlink" title="23. 介绍一下 js 的数据类型有哪些，值是如何存储的"></a>23. 介绍一下 js 的数据类型有哪些，值是如何存储的</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">JavaScript</span> 一共有 <span class="number">8</span> 种数据类型，其中有 <span class="number">7</span> 种基本数据类型：<span class="title class_">Undefined</span>、<span class="title class_">Null</span>、<span class="title class_">Boolean</span>、<span class="title class_">Number</span>、<span class="title class_">String</span>、<span class="title class_">Symbol</span>（es6 新增，表示独一无二的值）和 <span class="title class_">BigInt</span>（es10 新增）；</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> 种引用数据类型——<span class="title class_">Object</span>（<span class="title class_">Object</span> 本质上是由一组无序的名值对组成的）。里面包含 <span class="keyword">function</span>、<span class="title class_">Array</span>、<span class="title class_">Date</span> 等。<span class="title class_">JavaScript</span> 不支持任何创建自定义类型的机制，而所有值最终都将是上述 <span class="number">8</span> 种数据类型之一。</span><br><span class="line"></span><br><span class="line">原始数据类型：直接存储在**栈**（stack）中，占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储。</span><br><span class="line"></span><br><span class="line">引用数据类型：同时存储在**栈**（stack）和**堆**（heap）中，占据空间大、大小不固定。引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体。</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<h1 id="24-JS-中Object-prototype-toString-call-判断数据类型"><a href="#24-JS-中Object-prototype-toString-call-判断数据类型" class="headerlink" title="24. JS 中Object.prototype.toString.call()判断数据类型"></a>24. JS 中Object.prototype.toString.call()判断数据类型</h1><figure class="highlight vbscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var a = Object.prototype.toString;</span><br><span class="line">console.<span class="built_in">log</span>(a.<span class="keyword">call</span>(<span class="number">2</span>));</span><br><span class="line">console.<span class="built_in">log</span>(a.<span class="keyword">call</span>(<span class="literal">true</span>));</span><br><span class="line">console.<span class="built_in">log</span>(a.<span class="keyword">call</span>(<span class="comment">&#x27;str&#x27;));</span></span><br><span class="line">console.<span class="built_in">log</span>(a.<span class="keyword">call</span>([]));</span><br><span class="line">console.<span class="built_in">log</span>(a.<span class="keyword">call</span>(<span class="keyword">function</span>()&#123;&#125;));</span><br><span class="line">console.<span class="built_in">log</span>(a.<span class="keyword">call</span>(&#123;&#125;));</span><br><span class="line">console.<span class="built_in">log</span>(a.<span class="keyword">call</span>(undefined));</span><br><span class="line">console.<span class="built_in">log</span>(a.<span class="keyword">call</span>(<span class="literal">null</span>));https://link.juejin.cn?target=https%<span class="number">3</span>A%<span class="number">2</span>F%<span class="number">2</span>Fsegmentfault.com%<span class="number">2</span>Fa%<span class="number">2</span>F1190000011467723%<span class="number">23</span>articleHeader24 <span class="string">&quot;https://segmentfault.com/a/1190000011467723#articleHeader24&quot;</span>)</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<h1 id="25-null-和-undefined-的区别？"><a href="#25-null-和-undefined-的区别？" class="headerlink" title="25. null 和 undefined 的区别？"></a>25. null 和 undefined 的区别？</h1><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">首先 <span class="title class_">Undefined</span> 和 <span class="title class_">Null</span> 都是基本数据类型，这两个基本数据类型分别都只有一个值，就是 <span class="literal">undefined</span> 和 <span class="literal">null</span>。</span><br><span class="line"></span><br><span class="line"><span class="literal">undefined</span> 代表的含义是未定义， <span class="literal">null</span> 代表的含义是空对象（其实不是真的对象，请看下面的**注意**！）。一般变量声明了但还没有定义的时候会返回 <span class="literal">undefined</span>，<span class="literal">null</span> 主要用于赋值给一些可能会返回对象的变量，作为初始化。</span><br><span class="line"></span><br><span class="line">其实 <span class="literal">null</span> 不是对象，虽然 <span class="keyword">typeof</span> <span class="literal">null</span> 会输出 <span class="built_in">object</span>，但是这只是 <span class="variable constant_">JS</span> 存在的一个悠久 <span class="title class_">Bug</span>。在 <span class="variable constant_">JS</span> 的最初版本中使用的是 <span class="number">32</span> 位系统，为了性能考虑使用低位存储变量的类型信息，<span class="number">000</span> 开头代表是对象，然而 <span class="literal">null</span> 表示为全零，所以将它错误的判断为 <span class="built_in">object</span> 。虽然现在的内部类型判断代码已经改变了，但是对于这个 <span class="title class_">Bug</span> 却是一直流传下来。</span><br><span class="line"></span><br><span class="line"><span class="literal">undefined</span> 在 js 中不是一个保留字，这意味着我们可以使用 <span class="literal">undefined</span> 来作为一个变量名，这样的做法是非常危险的，它 会影响我们对 <span class="literal">undefined</span> 值的判断。但是我们可以通过一些方法获得安全的 <span class="literal">undefined</span> 值，比如说 <span class="built_in">void</span> <span class="number">0</span>。</span><br><span class="line"></span><br><span class="line">当我们对两种类型使用 <span class="keyword">typeof</span> 进行判断的时候，<span class="title class_">Null</span> 类型化会返回 “<span class="built_in">object</span>”，这是一个历史遗留的问题。当我们使用双等 号对两种类型的值进行比较时会返回 <span class="literal">true</span>，使用三个等号时会返回 <span class="literal">false</span>。</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<h1 id="26-和-的-valueOf-和-toString-的结果是什么？"><a href="#26-和-的-valueOf-和-toString-的结果是什么？" class="headerlink" title="26. {}和 [] 的 valueOf 和 toString 的结果是什么？"></a>26. {}和 [] 的 valueOf 和 toString 的结果是什么？</h1><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#125; 的 valueOf 结果为 &#123;&#125; ，toString 的结果为 &quot;<span class="selector-attr">[object Object]</span>&quot;</span><br><span class="line"></span><br><span class="line"><span class="selector-attr">[]</span> 的 valueOf 结果为 <span class="selector-attr">[]</span> ，toString 的结果为 &quot;&quot;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<h1 id="27-Javascript-的作用域和作用域链"><a href="#27-Javascript-的作用域和作用域链" class="headerlink" title="27. Javascript 的作用域和作用域链"></a>27. Javascript 的作用域和作用域链</h1><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="strong">**作用域：**</span> 作用域是定义变量的区域，它有一套访问变量的规则，这套规则来管理浏览器引擎如何在当前作用域以及嵌套的作用域中根据变量（标识符）进行变量查找。</span><br><span class="line"></span><br><span class="line"><span class="strong">**作用域链：**</span> 作用域链的作用是保证对执行环境有权访问的所有变量和函数的有序访问，通过作用域链，我们可以访问到外层环境的变量和 函数。</span><br><span class="line"></span><br><span class="line">作用域链的本质上是一个指向变量对象的指针列表。变量对象是一个包含了执行环境中所有变量和函数的对象。作用域链的前 端始终都是当前执行上下文的变量对象。全局执行上下文的变量对象（也就是全局对象）始终是作用域链的最后一个对象。</span><br><span class="line"></span><br><span class="line">当我们查找一个变量时，如果当前执行环境中没有找到，我们可以沿着作用域链向后查找。</span><br><span class="line"></span><br><span class="line">作用域链的创建过程跟执行上下文的建立有关</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<h1 id="28-谈谈你对-this、call、apply-和-bind-的理解"><a href="#28-谈谈你对-this、call、apply-和-bind-的理解" class="headerlink" title="28. 谈谈你对 this、call、apply 和 bind 的理解"></a>28. 谈谈你对 this、call、apply 和 bind 的理解</h1><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>  在浏览器里，在全局范围内 <span class="keyword">this</span> 指向 window 对象；</span><br><span class="line"><span class="number">2.</span>  在函数中，<span class="keyword">this</span> 永远指向最后调用他的那个对象；</span><br><span class="line"><span class="number">3.</span>  构造函数中，<span class="keyword">this</span> 指向 new 出来的那个新的对象；</span><br><span class="line"><span class="number">4.</span>  call、apply、bind 中的 <span class="keyword">this</span> 被强绑定在指定的那个对象上；</span><br><span class="line"><span class="number">5.</span>  箭头函数中 <span class="keyword">this</span> 比较特殊, 箭头函数 <span class="keyword">this</span> 为父作用域的 <span class="keyword">this</span>，不是调用时的 <span class="keyword">this</span>. 要知道前四种方式, 都是调用时确定, 也就是动态的, 而箭头函数的 <span class="keyword">this</span> 指向是静态的, 声明的时候就确定了下来；</span><br><span class="line"><span class="number">6.</span>  apply、call、bind 都是 js 给函数内置的一些 API，调用他们可以为函数指定 <span class="keyword">this</span> 的执行, 同时也可以传参。</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/86f03b8b3ca14adcaeba3b90fdb7eedb~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="img"></p>
<h1 id="29-JavaScript-原型，原型链？-有什么特点？"><a href="#29-JavaScript-原型，原型链？-有什么特点？" class="headerlink" title="29. JavaScript 原型，原型链？ 有什么特点？"></a>29. JavaScript 原型，原型链？ 有什么特点？</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">在 js 中我们是使用构造函数来新建一个对象的，每一个构造函数的内部都有一个 prototype 属性值，这个属性值是一个对 象，这个对象包含了可以由该构造函数的所有实例共享的属性和方法。当我们使用构造函数新建一个对象后，在这个对象的内部 将包含一个指针，这个指针指向构造函数的 prototype 属性对应的值，在 <span class="title class_">ES5</span> 中这个指针被称为对象的原型。一般来说我们 是不应该能够获取到这个值的，但是现在浏览器中都实现了 **proto** 属性来让我们访问这个属性，但是我们最好不要使用这 个属性，因为它不是规范中规定的。<span class="title class_">ES5</span> 中新增了一个 <span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>() 方法，我们可以通过这个方法来获取对 象的原型。</span><br><span class="line"></span><br><span class="line">当我们访问一个对象的属性时，如果这个对象内部不存在这个属性，那么它就会去它的原型对象里找这个属性，这个原型对象又 会有自己的原型，于是就这样一直找下去，也就是原型链的概念。原型链的尽头一般来说都是 <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span> 所以这就 是我们新建的对象为什么能够使用 <span class="title function_">toString</span>() 等方法的原因。</span><br><span class="line"></span><br><span class="line">特点：</span><br><span class="line"></span><br><span class="line"><span class="title class_">JavaScript</span> 对象是通过引用来传递的，我们创建的每个新对象实体中并没有一份属于自己的原型副本。当我们修改原型时，与 之相关的对象也会继承这一改变。</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<p>参考文章： <a href="https://link.juejin.cn?target=http%3A%2F%2Fcavszhouyou.top%2FJavaScript%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E4%B9%8B%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE.html">《JavaScript 深入理解之原型与原型链》</a></p>
<h1 id="30-什么是闭包，为什么要用它？"><a href="#30-什么是闭包，为什么要用它？" class="headerlink" title="30. 什么是闭包，为什么要用它？"></a>30. 什么是闭包，为什么要用它？</h1><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> 能够访问其它函数内部变量的函数，称为闭包</span><br><span class="line"><span class="bullet">-</span> 能够访问自由变量的函数，称为闭包</span><br><span class="line"></span><br><span class="line">场景</span><br><span class="line">至于闭包的使用场景，其实在日常开发中使用到是非常频繁的</span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> 防抖节流函数</span><br><span class="line"><span class="bullet">-</span> 定时器回调</span><br><span class="line"><span class="bullet">-</span> 等就不一一列举了</span><br><span class="line"></span><br><span class="line">优点</span><br><span class="line">闭包帮我们解决了什么问题呢</span><br><span class="line"><span class="strong">**内部变量是私有的，可以做到隔离作用域，保持数据的不被污染性**</span></span><br><span class="line"></span><br><span class="line">缺点</span><br><span class="line">同时闭包也带来了不小的坏处</span><br><span class="line"><span class="strong">**说到了它的优点`内部变量是私有的,可以做到隔离作用域`,那也就是说垃圾回收机制是无法清理闭包中内部变量的，那最后结果就是内存泄漏**</span></span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<h1 id="31-三种事件模型是什么？"><a href="#31-三种事件模型是什么？" class="headerlink" title="31. 三种事件模型是什么？"></a>31. 三种事件模型是什么？</h1><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="strong">**事件**</span> 是用户操作网页时发生的交互动作或者网页本身的一些操作，现代浏览器一共有三种事件模型。</span><br><span class="line"></span><br><span class="line"><span class="bullet">1.</span>  <span class="strong">**DOM0 级模型：**</span> ，这种模型不会传播，所以没有事件流的概念，但是现在有的浏览器支持以冒泡的方式实现，它可以在网页中直接定义监听函数，也可以通过 js 属性来指定监听函数。这种方式是所有浏览器都兼容的。</span><br><span class="line"><span class="bullet">2.</span>  <span class="strong">**IE 事件模型：**</span> 在该事件模型中，一次事件共有两个过程，事件处理阶段，和事件冒泡阶段。事件处理阶段会首先执行目标元素绑定的监听事件。然后是事件冒泡阶段，冒泡指的是事件从目标元素冒泡到 document，依次检查经过的节点是否绑定了事件监听函数，如果有则执行。这种模型通过 attachEvent 来添加监听函数，可以添加多个监听函数，会按顺序依次执行。</span><br><span class="line"><span class="bullet">3.</span>  <span class="strong">**DOM2 级事件模型：**</span> 在该事件模型中，一次事件共有三个过程，第一个过程是事件捕获阶段。捕获指的是事件从 document 一直向下传播到目标元素，依次检查经过的节点是否绑定了事件监听函数，如果有则执行。后面两个阶段和 IE 事件模型的两个阶段相同。这种事件模型，事件绑定的函数是 addEventListener，其中第三个参数可以指定事件是否在捕获阶段执行。</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<h1 id="32-js-数组和字符串有哪些原生方法-列举一下"><a href="#32-js-数组和字符串有哪些原生方法-列举一下" class="headerlink" title="32. js 数组和字符串有哪些原生方法, 列举一下"></a>32. js 数组和字符串有哪些原生方法, 列举一下</h1><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ab8c5beff9054a23a296c5b738878184~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="img"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d35b1e307cba458c8b1e73917165be6b~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="img"></p>
<h1 id="33-js-延迟加载的方式有哪些"><a href="#33-js-延迟加载的方式有哪些" class="headerlink" title="33. js 延迟加载的方式有哪些"></a>33. js 延迟加载的方式有哪些</h1><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">js 的加载、解析和执行会阻塞页面的渲染过程，因此我们希望 js 脚本能够尽可能的延迟加载，提高页面的渲染速度。</span><br><span class="line"></span><br><span class="line"><span class="bullet">1.</span>  将 js 脚本放在文档的底部，来使 js 脚本尽可能的在最后来加载执行。</span><br><span class="line"><span class="bullet">2.</span>  给 js 脚本添加 defer 属性，这个属性会让脚本的加载与文档的解析同步解析，然后在文档解析完成后再执行这个脚本文件，这样的话就能使页面的渲染不被阻塞。多个设置了 defer 属性的脚本按规范来说最后是顺序执行的，但是在一些浏览器中可能不是这样。</span><br><span class="line"><span class="bullet">3.</span>  给 js 脚本添加 async 属性，这个属性会使脚本异步加载，不会阻塞页面的解析过程，但是当脚本加载完成后立即执行 js 脚本，这个时候如果文档没有解析完成的话同样会阻塞。多个 async 属性的脚本的执行顺序是不可预测的，一般不会按照代码的顺序依次执行。</span><br><span class="line"><span class="bullet">4.</span>  动态创建 DOM 标签的方式，我们可以对文档的加载事件进行监听，当文档加载完成后再动态的创建 script 标签来引入 js 脚本。</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<h1 id="34-js-的几种模块规范？"><a href="#34-js-的几种模块规范？" class="headerlink" title="34. js 的几种模块规范？"></a>34. js 的几种模块规范？</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">js 中现在比较成熟的有四种模块加载方案：</span><br><span class="line"></span><br><span class="line">*   第一种是 <span class="title class_">CommonJS</span> 方案，它通过 <span class="built_in">require</span> 来引入模块，通过 <span class="variable language_">module</span>.<span class="property">exports</span> 定义模块的输出接口。这种模块加载方案是服务器端的解决方案，它是以同步的方式来引入模块的，因为在服务端文件都存储在本地磁盘，所以读取非常快，所以以同步的方式加载没有问题。但如果是在浏览器端，由于模块的加载是使用网络请求，因此使用异步加载的方式更加合适。</span><br><span class="line">*   第二种是 <span class="variable constant_">AMD</span> 方案，这种方案采用异步加载的方式来加载模块，模块的加载不影响后面语句的执行，所有依赖这个模块的语句都定义在一个回调函数里，等到加载完成后再执行回调函数。<span class="built_in">require</span>.<span class="property">js</span> 实现了 <span class="variable constant_">AMD</span> 规范。</span><br><span class="line">*   第三种是 <span class="variable constant_">CMD</span> 方案，这种方案和 <span class="variable constant_">AMD</span> 方案都是为了解决异步模块加载的问题，sea.<span class="property">js</span> 实现了 <span class="variable constant_">CMD</span> 规范。它和 <span class="built_in">require</span>.<span class="property">js</span> 的区别在于模块定义时对依赖的处理不同和对依赖模块的执行时机的处理不同。</span><br><span class="line">*   第四种方案是 <span class="title class_">ES6</span> 提出的方案，使用 <span class="keyword">import</span> 和 <span class="keyword">export</span> 的形式来导入导出模块。</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<h1 id="35-AMD-和-CMD-规范的区别？"><a href="#35-AMD-和-CMD-规范的区别？" class="headerlink" title="35. AMD 和 CMD 规范的区别？"></a>35. AMD 和 CMD 规范的区别？</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">它们之间的主要区别有两个方面。</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span>  第一个方面是在模块定义时对依赖的处理不同。<span class="variable constant_">AMD</span> 推崇依赖前置，在定义模块的时候就要声明其依赖的模块。而 <span class="variable constant_">CMD</span> 推崇就近依赖，只有在用到某个模块的时候再去 <span class="built_in">require</span>。</span><br><span class="line"><span class="number">2.</span>  第二个方面是对依赖模块的执行时机处理不同。首先 <span class="variable constant_">AMD</span> 和 <span class="variable constant_">CMD</span> 对于模块的加载方式都是异步加载，不过它们的区别在于 模块的执行时机，<span class="variable constant_">AMD</span> 在依赖模块加载完成后就直接执行依赖模块，依赖模块的执行顺序和我们书写的顺序不一定一致。而 <span class="variable constant_">CMD</span> 在依赖模块加载完成后并不执行，只是下载而已，等到所有的依赖模块都加载好后，进入回调函数逻辑，遇到 <span class="built_in">require</span> 语句 的时候才执行对应的模块，这样模块的执行顺序就和我们书写的顺序保持一致了。</span><br><span class="line"></span><br><span class="line"><span class="comment">// CMD</span></span><br><span class="line"><span class="title function_">define</span>(<span class="keyword">function</span>(<span class="params"><span class="built_in">require</span>, <span class="built_in">exports</span>, <span class="variable language_">module</span></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">&quot;./a&quot;</span>);</span><br><span class="line">  a.<span class="title function_">doSomething</span>();</span><br><span class="line">  <span class="comment">// 此处略去 100 行</span></span><br><span class="line">  <span class="keyword">var</span> b = <span class="built_in">require</span>(<span class="string">&quot;./b&quot;</span>); <span class="comment">// 依赖可以就近书写</span></span><br><span class="line">  b.<span class="title function_">doSomething</span>();</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// AMD 默认推荐</span></span><br><span class="line"><span class="title function_">define</span>([<span class="string">&quot;./a&quot;</span>, <span class="string">&quot;./b&quot;</span>], <span class="keyword">function</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">  <span class="comment">// 依赖必须一开始就写好</span></span><br><span class="line">  a.<span class="title function_">doSomething</span>();</span><br><span class="line">  <span class="comment">// 此处略去 100 行</span></span><br><span class="line">  b.<span class="title function_">doSomething</span>();</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<h1 id="36-ES6-模块与-CommonJS-模块、AMD、CMD-的差异。"><a href="#36-ES6-模块与-CommonJS-模块、AMD、CMD-的差异。" class="headerlink" title="36. ES6 模块与 CommonJS 模块、AMD、CMD 的差异。"></a>36. ES6 模块与 CommonJS 模块、AMD、CMD 的差异。</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、语法上</span><br><span class="line"><span class="title class_">CommonJS</span> 使用的是 <span class="variable language_">module</span>.<span class="property">exports</span> = &#123;&#125; 导出一个模块对象，<span class="built_in">require</span>(‘file_path’) 引入模块对象；</span><br><span class="line"><span class="title class_">ES6</span>使用的是 <span class="keyword">export</span> 导出指定数据， <span class="keyword">import</span> 引入具体数据。</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、<span class="title class_">CommonJS</span> 模块输出的是一个值的拷贝，<span class="title class_">ES6</span> 模块输出的是值的引用</span><br><span class="line"></span><br><span class="line"><span class="title class_">CommonJS</span> 模块输出的是值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。</span><br><span class="line"></span><br><span class="line"><span class="title class_">ES6</span> <span class="title class_">Modules</span> 的运行机制与 <span class="title class_">CommonJS</span> 不一样。<span class="variable constant_">JS</span> 引擎对脚本静态分析的时候，遇到模块加载命令<span class="keyword">import</span>，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。换句话说，<span class="title class_">ES6</span>的<span class="keyword">import</span> 有点像 <span class="title class_">Unix</span> 系统的“符号连接”，原始值变了，<span class="keyword">import</span>加载的值也会跟着变。因此，<span class="title class_">ES6</span>模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块。</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>、<span class="title class_">CommonJS</span> 模块是运行时加载，<span class="title class_">ES6</span> 模块是编译时加载</span><br><span class="line"></span><br><span class="line">运行时加载: <span class="title class_">CommonJS</span> 模块就是对象；即在输入时是先加载整个模块，生成一个对象，然后再从这个对象上面读取方法，这种加载称为“运行时加载”。</span><br><span class="line"></span><br><span class="line">编译时加载: <span class="title class_">ES6</span> 模块不是对象，而是通过 <span class="keyword">export</span> 命令显式指定输出的代码，<span class="keyword">import</span>时采用静态命令的形式。即在<span class="keyword">import</span>时可以指定加载某个输出值，而不是加载整个模块，这种加载称为“编译时加载”</span><br><span class="line"></span><br><span class="line"><span class="variable constant_">PS</span>：<span class="title class_">CommonJS</span> 加载的是一个对象（即<span class="variable language_">module</span>.<span class="property">exports</span>属性），该对象只有在脚本运行完才会生成。而 <span class="title class_">ES6</span> 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<h1 id="37-JS-的运行机制"><a href="#37-JS-的运行机制" class="headerlink" title="37. JS 的运行机制"></a>37. JS 的运行机制</h1><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">异步任务分类：宏任务，微任务</span><br><span class="line">同步任务和异步任务分别进入不同的执行&quot;场所&quot;</span><br><span class="line">先执行主线程执行栈中的宏任务</span><br><span class="line">执行过程中如果遇到微任务，进入Event Table并注册函数，完成后移入到微任务的任务队列中</span><br><span class="line">宏任务执行完毕后，立即执行当前微任务队列中的所有微任务（依次执行）</span><br><span class="line">主线程会不断获取任务队列中的任务、执行任务、再获取、再执行任务也就是常说的Event Loop(事件循环)。</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<h1 id="38-简单介绍一下-V8-引擎的垃圾回收机制"><a href="#38-简单介绍一下-V8-引擎的垃圾回收机制" class="headerlink" title="38. 简单介绍一下 V8 引擎的垃圾回收机制"></a>38. 简单介绍一下 V8 引擎的垃圾回收机制</h1><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">v8 的垃圾回收机制基于分代回收机制，这个机制又基于世代假说，这个假说有两个特点，一是新生的对象容易早死，另一个是不死的对象会活得更久。基于这个假说，v8 引擎将内存分为了新生代和老生代。</span><br><span class="line"></span><br><span class="line">新创建的对象或者只经历过一次的垃圾回收的对象被称为新生代。经历过多次垃圾回收的对象被称为老生代。</span><br><span class="line"></span><br><span class="line">新生代被分为 <span class="selector-tag">From</span> 和 <span class="selector-tag">To</span> 两个空间，<span class="selector-tag">To</span> 一般是闲置的。当 <span class="selector-tag">From</span> 空间满了的时候会执行 Scavenge 算法进行垃圾回收。当我们执行垃圾回收算法的时候应用逻辑将会停止，等垃圾回收结束后再继续执行。这个算法分为三步：</span><br><span class="line"></span><br><span class="line">（<span class="number">1</span>）首先检查 <span class="selector-tag">From</span> 空间的存活对象，如果对象存活则判断对象是否满足晋升到老生代的条件，如果满足条件则晋升到老生代。如果不满足条件则移动 <span class="selector-tag">To</span> 空间。</span><br><span class="line"></span><br><span class="line">（<span class="number">2</span>）如果对象不存活，则释放对象的空间。</span><br><span class="line"></span><br><span class="line">（<span class="number">3</span>）最后将 <span class="selector-tag">From</span> 空间和 <span class="selector-tag">To</span> 空间角色进行交换。</span><br><span class="line"></span><br><span class="line">新生代对象晋升到老生代有两个条件：</span><br><span class="line"></span><br><span class="line">（<span class="number">1</span>）第一个是判断是对象否已经经过一次 Scavenge 回收。若经历过，则将对象从 <span class="selector-tag">From</span> 空间复制到老生代中；若没有经历，则复制到 <span class="selector-tag">To</span> 空间。</span><br><span class="line"></span><br><span class="line">（<span class="number">2</span>）第二个是 <span class="selector-tag">To</span> 空间的内存使用占比是否超过限制。当对象从 <span class="selector-tag">From</span> 空间复制到 <span class="selector-tag">To</span> 空间时，若 <span class="selector-tag">To</span> 空间使用超过 <span class="number">25%</span>，则对象直接晋升到老生代中。设置 <span class="number">25%</span> 的原因主要是因为算法结束后，两个空间结束后会交换位置，如果 <span class="selector-tag">To</span> 空间的内存太小，会影响后续的内存分配。</span><br><span class="line"></span><br><span class="line">老生代采用了标记清除法和标记压缩法。标记清除法首先会对内存中存活的对象进行标记，标记结束后清除掉那些没有标记的对象。由于标记清除后会造成很多的内存碎片，不便于后面的内存分配。所以了解决内存碎片的问题引入了标记压缩法。</span><br><span class="line"></span><br><span class="line">由于在进行垃圾回收的时候会暂停应用的逻辑，对于新生代方法由于内存小，每次停顿的时间不会太长，但对于老生代来说每次垃圾回收的时间长，停顿会造成很大的影响。 为了解决这个问题 V8 引入了增量标记的方法，将一次停顿进行的过程分为了多步，每次执行完一小步就让运行逻辑执行一会，就这样交替运行。</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<p>相关资料：</p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.jianshu.com%2Fp%2Fb8ed21e8a4fb">《深入理解 V8 的垃圾回收原理》</a></p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F23992332">《JavaScript 中的垃圾回收》</a></p>
<h1 id="39-哪些操作会造成内存泄漏？"><a href="#39-哪些操作会造成内存泄漏？" class="headerlink" title="39. 哪些操作会造成内存泄漏？"></a>39. 哪些操作会造成内存泄漏？</h1><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">*</span>   1. 意外的全局变量</span><br><span class="line"><span class="bullet">*</span>   2. 被遗忘的计时器或回调函数</span><br><span class="line"><span class="bullet">*</span>   3. 脱离 DOM 的引用</span><br><span class="line"><span class="bullet">*</span>   4. 闭包</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<h1 id="40-ES6有哪些新特性？"><a href="#40-ES6有哪些新特性？" class="headerlink" title="40.ES6有哪些新特性？"></a>40.ES6有哪些新特性？</h1><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">*</span>   块作用域</span><br><span class="line"><span class="bullet">*</span>   类</span><br><span class="line"><span class="bullet">*</span>   箭头函数</span><br><span class="line"><span class="bullet">*</span>   模板字符串</span><br><span class="line"><span class="bullet">*</span>   加强的对象字面</span><br><span class="line"><span class="bullet">*</span>   对象解构</span><br><span class="line"><span class="bullet">*</span>   Promise</span><br><span class="line"><span class="bullet">*</span>   模块</span><br><span class="line"><span class="bullet">*</span>   Symbol</span><br><span class="line"><span class="bullet">*</span>   代理（proxy）Set</span><br><span class="line"><span class="bullet">*</span>   函数默认参数</span><br><span class="line"><span class="bullet">*</span>   展开</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<h1 id="41-什么是箭头函数？"><a href="#41-什么是箭头函数？" class="headerlink" title="41. 什么是箭头函数？"></a>41. 什么是箭头函数？</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ES5 Version</span></span><br><span class="line"><span class="keyword">var</span> getCurrentDate = <span class="keyword">function</span> (<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ES6 Version</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">getCurrentDate</span> = (<span class="params"></span>) =&gt; <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line"></span><br><span class="line">箭头函数表达式的语法比函数表达式更简洁，并且没有自己的<span class="string">`this，arguments，super或new.target`</span>。箭头函数表达式更适用于那些本来需要匿名函数的地方，并且它不能用作构造函数。</span><br><span class="line"></span><br><span class="line">箭头函数没有自己的 <span class="variable language_">this</span> 值。它捕获词法作用域函数的 <span class="variable language_">this</span> 值，如果我们在全局作用域声明箭头函数，则 <span class="variable language_">this</span> 值为 <span class="variable language_">window</span> 对象。</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<h1 id="42-什么是高阶函数？"><a href="#42-什么是高阶函数？" class="headerlink" title="42. 什么是高阶函数？"></a>42. 什么是高阶函数？</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">高阶函数只是将函数作为参数或返回值的函数。</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">higherOrderFunction</span>(<span class="params">param,callback</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">callback</span>(param);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<h1 id="43-手写-call、apply-及-bind-函数"><a href="#43-手写-call、apply-及-bind-函数" class="headerlink" title="43. 手写 call、apply 及 bind 函数"></a>43. 手写 call、apply 及 bind 函数</h1><h2 id="1-实现call函数"><a href="#1-实现call函数" class="headerlink" title="1.实现call函数"></a>1.实现call函数</h2><p><strong>实现步骤：</strong></p>
<ul>
<li>处理边界：<ul>
<li>对象不存在，this指向window；</li>
</ul>
</li>
<li>将「调用函数」<em>挂载到</em>「this指向的对象」的fn属性上。</li>
<li>执行「this指向的对象」上的fn函数，并传入参数，返回结果。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">mu_call</span> = <span class="keyword">function</span> (<span class="params">context, ...args</span>) &#123;</span><br><span class="line">    <span class="comment">//obj不存在指向window</span></span><br><span class="line">    <span class="keyword">if</span> (!context || context === <span class="literal">null</span>) &#123;</span><br><span class="line">      context = <span class="variable language_">window</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创造唯一的key值  作为我们构造的context内部方法名</span></span><br><span class="line">    <span class="keyword">let</span> fn = <span class="title class_">Symbol</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//this指向调用call的函数</span></span><br><span class="line">    context[fn] = <span class="variable language_">this</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行函数并返回结果 相当于把自身作为传入的context的方法进行调用了</span></span><br><span class="line">    <span class="keyword">return</span> context[fn](...args);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 测试</span></span><br><span class="line">  <span class="keyword">var</span> value = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">    <span class="attr">value</span>: <span class="number">1</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> myObj = &#123;</span><br><span class="line">      <span class="attr">name</span>: name,</span><br><span class="line">      <span class="attr">age</span>: age,</span><br><span class="line">      <span class="attr">value</span>: <span class="variable language_">this</span>.<span class="property">value</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">value</span>, myObj);</span><br><span class="line">  &#125;</span><br><span class="line">  bar.<span class="title function_">mu_call</span>(<span class="literal">null</span>); <span class="comment">//打印 2 &#123;name: undefined, age: undefined, value: 2&#125;</span></span><br><span class="line">  bar.<span class="title function_">mu_call</span>(obj1, <span class="string">&#x27;tom&#x27;</span>, <span class="string">&#x27;110&#x27;</span>); <span class="comment">// 打印 1 &#123;name: &quot;tom&quot;, age: &quot;110&quot;, value: 1&#125;</span></span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<h2 id="2-实现apply函数"><a href="#2-实现apply函数" class="headerlink" title="2.实现apply函数"></a>2.实现apply函数</h2><p><strong>实现步骤：</strong></p>
<ul>
<li>与call一致</li>
<li>区别于参数的形式</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">mu_apply</span> = <span class="keyword">function</span> (<span class="params">context, args</span>) &#123;</span><br><span class="line">  <span class="comment">//obj不存在指向window</span></span><br><span class="line">  <span class="keyword">if</span> (!context || context === <span class="literal">null</span>) &#123;</span><br><span class="line">    context = <span class="title class_">Window</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 创造唯一的key值  作为我们构造的context内部方法名</span></span><br><span class="line">  <span class="keyword">let</span> fn = <span class="title class_">Symbol</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">//this指向调用call的函数</span></span><br><span class="line">  context[fn] = <span class="variable language_">this</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 执行函数并返回结果 相当于把自身作为传入的context的方法进行调用了</span></span><br><span class="line">  <span class="keyword">return</span> context[fn](...args);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="keyword">var</span> value = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">  <span class="attr">value</span>: <span class="number">1</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> myObj = &#123;</span><br><span class="line">    <span class="attr">name</span>: name,</span><br><span class="line">    <span class="attr">age</span>: age,</span><br><span class="line">    <span class="attr">value</span>: <span class="variable language_">this</span>.<span class="property">value</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">value</span>, myObj);</span><br><span class="line">&#125;</span><br><span class="line">bar.<span class="title function_">mu_apply</span>(obj1, [<span class="string">&quot;tom&quot;</span>, <span class="string">&quot;110&quot;</span>]); <span class="comment">// 打印 1 &#123;name: &quot;tom&quot;, age: &quot;110&quot;, value: 1&#125;</span></span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<h2 id="3-实现bind函数"><a href="#3-实现bind函数" class="headerlink" title="3.实现bind函数"></a>3.实现bind函数</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">mu_bind</span> = <span class="keyword">function</span> (<span class="params">context, ...args</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!context || context === <span class="literal">null</span>) &#123;</span><br><span class="line">      context = <span class="variable language_">window</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创造唯一的key值  作为我们构造的context内部方法名</span></span><br><span class="line">    <span class="keyword">let</span> fn = <span class="title class_">Symbol</span>();</span><br><span class="line">    context[fn] = <span class="variable language_">this</span>;</span><br><span class="line">    <span class="keyword">let</span> _this = <span class="variable language_">this</span>;</span><br><span class="line">    <span class="comment">//  bind情况要复杂一点</span></span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">function</span> (<span class="params">...innerArgs</span>) &#123;</span><br><span class="line">      <span class="comment">// 第一种情况 :若是将 bind 绑定之后的函数当作构造函数，通过 new 操作符使用，则不绑定传入的 this，而是将 this 指向实例化出来的对象</span></span><br><span class="line">      <span class="comment">// 此时由于new操作符作用  this指向result实例对象  而result又继承自传入的_this 根据原型链知识可得出以下结论</span></span><br><span class="line">      <span class="comment">// this.__proto__ === result.prototype   //this instanceof result =&gt;true</span></span><br><span class="line">      <span class="comment">// this.__proto__.__proto__ === result.prototype.__proto__ === _this.prototype; //this instanceof _this =&gt;true</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span> <span class="keyword">instanceof</span> _this === <span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">// 此时this指向指向result的实例  这时候不需要改变this指向</span></span><br><span class="line">        <span class="variable language_">this</span>[fn] = _this;</span><br><span class="line">        <span class="variable language_">this</span>[fn](...[...args, ...innerArgs]); <span class="comment">//这里使用es6的方法让bind支持参数合并</span></span><br><span class="line">        <span class="keyword">delete</span> <span class="variable language_">this</span>[fn];</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果只是作为普通函数调用  那就很简单了 直接改变this指向为传入的context</span></span><br><span class="line">        context[fn](...[...args, ...innerArgs]);</span><br><span class="line">        <span class="keyword">delete</span> context[fn];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 如果绑定的是构造函数 那么需要继承构造函数原型属性和方法</span></span><br><span class="line">    <span class="comment">// 实现继承的方式: 使用Object.create</span></span><br><span class="line">    result.<span class="property"><span class="keyword">prototype</span></span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="variable language_">this</span>.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(name); <span class="comment">//&#x27;我是参数传进来的name&#x27;</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(age); <span class="comment">//&#x27;我是参数传进来的age&#x27;</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>); <span class="comment">//构造函数this指向实例对象</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 构造函数原型的方法</span></span><br><span class="line">  <span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">say</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">123</span>);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 普通函数</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">normalFun</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(name); <span class="comment">//&#x27;我是参数传进来的name&#x27;</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(age); <span class="comment">//&#x27;我是参数传进来的age&#x27;</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>); <span class="comment">//普通函数this指向绑定bind的第一个参数 也就是例子中的obj</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">objName</span>); <span class="comment">//&#x27;我是obj传进来的name&#x27;</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">objAge</span>); <span class="comment">//&#x27;我是obj传进来的age&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> obj = &#123;</span><br><span class="line">    <span class="attr">objName</span>: <span class="string">&#x27;我是obj传进来的name&#x27;</span>,</span><br><span class="line">    <span class="attr">objAge</span>: <span class="string">&#x27;我是obj传进来的age&#x27;</span>,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 先测试作为构造函数调用</span></span><br><span class="line">  <span class="comment">//   let bindFun = Person.mu_bind(obj, &#x27;我是参数传进来的name&#x27;);</span></span><br><span class="line">  <span class="comment">//   let a = new bindFun(&#x27;我是参数传进来的age&#x27;);</span></span><br><span class="line">  <span class="comment">//   a.say(); //123</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//   再测试作为普通函数调用a;</span></span><br><span class="line">  <span class="keyword">let</span> bindFun = normalFun.<span class="title function_">mu_bind</span>(obj, <span class="string">&#x27;我是参数传进来的name&#x27;</span>);</span><br><span class="line">  <span class="title function_">bindFun</span>(<span class="string">&#x27;我是参数传进来的age&#x27;</span>);</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<p>参考文章： <a target="_blank" rel="noopener" href="https://juejin.cn/post/7186557308883714085">高频JavaScript手写面试题，你“行”吗</a></p>
<h1 id="44-函数柯里化的实现"><a href="#44-函数柯里化的实现" class="headerlink" title="44. 函数柯里化的实现"></a>44. 函数柯里化的实现</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数柯里化指的是一种将使用多个参数的一个函数转换成一系列使用一个参数的函数的技术。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">curry</span>(<span class="params">fn, args</span>) &#123;</span><br><span class="line">  <span class="comment">// 获取函数需要的参数长度</span></span><br><span class="line">  <span class="keyword">let</span> length = fn.<span class="property">length</span>;</span><br><span class="line"></span><br><span class="line">  args = args || [];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> subArgs = args.<span class="title function_">slice</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拼接得到现有的所有参数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="variable language_">arguments</span>.<span class="property">length</span>; i++) &#123;</span><br><span class="line">      subArgs.<span class="title function_">push</span>(<span class="variable language_">arguments</span>[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断参数的长度是否已经满足函数所需参数的长度</span></span><br><span class="line">    <span class="keyword">if</span> (subArgs.<span class="property">length</span> &gt;= length) &#123;</span><br><span class="line">      <span class="comment">// 如果满足，执行函数</span></span><br><span class="line">      <span class="keyword">return</span> fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, subArgs);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 如果不满足，递归返回科里化的函数，等待参数的传入</span></span><br><span class="line">      <span class="keyword">return</span> curry.<span class="title function_">call</span>(<span class="variable language_">this</span>, fn, subArgs);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// es6 实现</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">curry</span>(<span class="params">fn, ...args</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> fn.<span class="property">length</span> &lt;= args.<span class="property">length</span> ? <span class="title function_">fn</span>(...args) : curry.<span class="title function_">bind</span>(<span class="literal">null</span>, fn, ...args);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<p>参考文章： <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fmqyqingfeng%2FBlog%2Fissues%2F42">《JavaScript 专题之函数柯里化》</a></p>
<h1 id="45-实现一个-new-操作符"><a href="#45-实现一个-new-操作符" class="headerlink" title="45. 实现一个 new 操作符"></a>45. 实现一个 new 操作符</h1><p><strong>首先需要了解new做了什么事情：</strong></p>
<ul>
<li>首先创建了一个空对象。</li>
<li>将空对象<code>proto</code>指向构造函数的原型<code>prototype</code>。</li>
<li>使<code>this</code>指向新创建的对象，并执行构造函数。</li>
<li>执行结果有返回值并且是一个对象， 返回执行的结果， 否则返回新创建的对象。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码实现</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">mu_new</span>(<span class="params">fn,...arg</span>)&#123;</span><br><span class="line">    <span class="comment">// 首先创建空对象</span></span><br><span class="line">    <span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line">    <span class="comment">// 将空对象的原型proto指向构造函数的原型prototype</span></span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">setPrototypeOf</span>(obj, fn.<span class="property"><span class="keyword">prototype</span></span>)</span><br><span class="line">    <span class="comment">// 将this指向新创建的对象，并且执行构造函数</span></span><br><span class="line">    <span class="keyword">const</span> result = fn.<span class="title function_">apply</span>(obj,arg);</span><br><span class="line">    <span class="comment">// 执行结果有返回值并且是一个对象，返回执行的结果，否侧返回新创建的对象</span></span><br><span class="line">    <span class="keyword">return</span> result <span class="keyword">instanceof</span> <span class="title class_">Object</span> ? result : obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 验证mu_new函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Dog</span>(<span class="params">name</span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">say</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;my name is&#x27;</span> + <span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> dog = <span class="title function_">mu_new</span>(<span class="title class_">Dog</span>, <span class="string">&quot;傻🐶&quot;</span>);</span><br><span class="line">dog.<span class="title function_">say</span>() <span class="comment">//my name is傻🐶</span></span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<h1 id="46-可以讲讲Promise吗，可以手写实现一下吗？"><a href="#46-可以讲讲Promise吗，可以手写实现一下吗？" class="headerlink" title="46. 可以讲讲Promise吗，可以手写实现一下吗？"></a>46. 可以讲讲Promise吗，可以手写实现一下吗？</h1><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。它由社区最早提出和实现，ES6 将其写进了语言标准，统一了用法，原生提供了<span class="code">`Promise`</span>对象。</span><br><span class="line"></span><br><span class="line">所谓<span class="code">`Promise`</span>，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。</span><br><span class="line"></span><br><span class="line"><span class="strong">**那我们来看看我们所熟知的`Promise`的基本原理**</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">+</span> 首先我们在调用Promise时，会返回一个Promise对象。</span><br><span class="line"><span class="bullet">+</span> 构建Promise对象时，需要传入一个executor函数，Promise的主要业务流程都在executor函数中执行。</span><br><span class="line"><span class="bullet">+</span> 如果运行在excutor函数中的业务执行成功了，会调用resolve函数；如果执行失败了，则调用reject函数。</span><br><span class="line"><span class="bullet">+</span> Promise的状态不可逆，同时调用resolve函数和reject函数，默认会采取第一次调用的结果。</span><br><span class="line"></span><br><span class="line"><span class="strong">**结合Promise/A+规范，我们还可以分析出哪些基本特征**</span></span><br><span class="line"></span><br><span class="line">Promise/A+的规范比较多，在这列出一下核心的规范。[<span class="string">Promise/A+规范</span>](<span class="link">https://link.juejin.cn/?target=https%3A%2F%2Fpromisesaplus.com%2F</span>)</span><br><span class="line"></span><br><span class="line"><span class="bullet">+</span> promise有三个状态：pending，fulfilled，rejected，默认状态是pending。</span><br><span class="line"><span class="bullet">+</span> promise有一个value保存成功状态的值，有一个reason保存失败状态的值，可以是undefined/thenable/promise。</span><br><span class="line"><span class="bullet">+</span> promise只能从pending到rejected, 或者从pending到fulfilled，状态一旦确认，就不会再改变。</span><br><span class="line"><span class="bullet">+</span> promise 必须有一个then方法，then接收两个参数，分别是promise成功的回调onFulfilled, 和promise失败的回调onRejected。</span><br><span class="line"><span class="bullet">+</span> 如果then中抛出了异常，那么就会把这个异常作为参数，传递给下一个then的失败的回调onRejected。</span><br><span class="line"></span><br><span class="line">那<span class="code">`CustomPromise`</span>，还实现不了基本原理的3，4两条，那我们来根据基本原理与Promise/A+分析下，还缺少什么</span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> promise有三个状态：pending，fulfilled，rejected。</span><br><span class="line"><span class="bullet">-</span> executor执行器调用reject与resolve两个方法</span><br><span class="line"><span class="bullet">-</span> 还需要有保存成功或失败两个值的变量</span><br><span class="line"><span class="bullet">-</span> then接收两个参数，分别是成功的回调onFulfilled,失败的回调onRejected</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/7194257890893365308">手写实现promise</a></p>
<h1 id="47-什么是-async-await-及其如何工作-可以手写async吗"><a href="#47-什么是-async-await-及其如何工作-可以手写async吗" class="headerlink" title="47. 什么是 async/await 及其如何工作, 可以手写async吗"></a>47. 什么是 <code>async/await</code> 及其如何工作, 可以手写async吗</h1><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1、Async—声明一个异步函数</span><br><span class="line"><span class="bullet">  -</span> 自动将常规函数转换成Promise，返回值也是一个Promise对象</span><br><span class="line"><span class="bullet">  -</span> 只有async函数内部的异步操作执行完，才会执行then方法指定的回调函数</span><br><span class="line"><span class="bullet">  -</span> 异步函数内部可以使用await</span><br><span class="line">2、Await—暂停异步的功能执行(var result = await someAsyncCall();)</span><br><span class="line"><span class="bullet">  -</span> 放置在Promise调用之前，await强制其他代码等待，直到Promise完成并返回结果</span><br><span class="line"><span class="bullet">  -</span> 只能与Promise一起使用，不适用与回调</span><br><span class="line"><span class="bullet">  -</span> 只能在async函数内部使用</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/7195358576364224568">手写实现async</a></p>
<h1 id="48-instanceof-的优缺点是什么，如何实现"><a href="#48-instanceof-的优缺点是什么，如何实现" class="headerlink" title="48. instanceof 的优缺点是什么，如何实现"></a>48. instanceof 的优缺点是什么，如何实现</h1><p><strong>优缺点：</strong></p>
<ul>
<li><strong>「优点」</strong>：能够区分Array、Object和Function，适合用于判断自定义的类实例对象</li>
<li><strong>「缺点」</strong>：Number，Boolean，String基本数据类型不能判断</li>
</ul>
<p><strong>实现步骤：</strong></p>
<ul>
<li>传入参数为左侧的实例L，和右侧的构造函数R</li>
<li>处理边界，如果要检测对象为基本类型则返回false</li>
<li>分别取传入参数的原型</li>
<li>判断左侧的原型是否取到了null，如果是null返回false；如果两侧原型相等，返回true，否则继续取左侧原型的原型。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传入参数左侧为实例L, 右侧为构造函数R</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">mu_instanceof</span>(<span class="params">L,R</span>)&#123;</span><br><span class="line">    <span class="comment">// 处理边界：检测实例类型是否为原始类型</span></span><br><span class="line">    <span class="keyword">const</span> baseTypes = [<span class="string">&#x27;string&#x27;</span>,<span class="string">&#x27;number&#x27;</span>,<span class="string">&#x27;boolean&#x27;</span>,<span class="string">&#x27;symbol&#x27;</span>,<span class="string">&#x27;undefined&#x27;</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(baseTypes.<span class="title function_">includes</span>(<span class="keyword">typeof</span> L) || L === <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分别取传入参数的原型</span></span><br><span class="line">    <span class="keyword">let</span> <span class="title class_">Lp</span> = L.<span class="property">__proto__</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="title class_">Rp</span> = R.<span class="property"><span class="keyword">prototype</span></span>; <span class="comment">// 函数才拥有prototype属性</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断原型</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="title class_">Lp</span> === <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="title class_">Lp</span> === <span class="title class_">Rp</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="title class_">Lp</span> = <span class="title class_">Lp</span>.<span class="property">__proto__</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 验证</span></span><br><span class="line"><span class="keyword">const</span> isArray = <span class="title function_">mu_instanceof</span>([],<span class="title class_">Array</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(isArray); <span class="comment">//true</span></span><br><span class="line"><span class="keyword">const</span> isDate = <span class="title function_">mu_instanceof</span>(<span class="string">&#x27;2023-01-09&#x27;</span>,<span class="title class_">Date</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(isDate); <span class="comment">// false</span></span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<h1 id="49-js-的节流与防抖"><a href="#49-js-的节流与防抖" class="headerlink" title="49. js 的节流与防抖"></a>49. js 的节流与防抖</h1><h2 id="1-防抖"><a href="#1-防抖" class="headerlink" title="1.防抖"></a>1.防抖</h2><p><em>函数防抖是在事件被触发n秒后再执行回调，如果在「n秒内又被触发」，则「重新计时」</em></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">debounce</span>(<span class="params">fn, wait</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> timer = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (timer != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line">      &#125;</span><br><span class="line">      timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">fn</span>();</span><br><span class="line">      &#125;, wait);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 测试</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">handle</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 窗口大小改变，触发防抖，执行handle</span></span><br><span class="line">  <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;resize&#x27;</span>, <span class="title function_">debounce</span>(handle, <span class="number">1000</span>));</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<h2 id="2-节流"><a href="#2-节流" class="headerlink" title="2.节流"></a>2.节流</h2><p><em>当事件触发时，保证一定时间段内只<strong>调用一次</strong>函数。例如页面滚动的时候，每隔一段时间发一次请求</em></p>
<p><strong>实现步骤：</strong></p>
<ul>
<li>传入参数为执行函数fn，等待时间wait。</li>
<li>保存初始时间now。</li>
<li>返回一个函数，如果超过等待时间，执行函数，将now更新为当前时间。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">throttle</span>(<span class="params">fn, wait, ...args</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> pre = <span class="title class_">Date</span>.<span class="title function_">now</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="comment">// 函数可能会有入参</span></span><br><span class="line">      <span class="keyword">var</span> context = <span class="variable language_">this</span>;</span><br><span class="line">      <span class="keyword">var</span> now = <span class="title class_">Date</span>.<span class="title function_">now</span>();</span><br><span class="line">      <span class="keyword">if</span> (now - pre &gt;= wait) &#123;</span><br><span class="line">        <span class="comment">// 将执行函数的this指向当前作用域</span></span><br><span class="line">        fn.<span class="title function_">apply</span>(context, args);</span><br><span class="line">        pre = <span class="title class_">Date</span>.<span class="title function_">now</span>();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 测试</span></span><br><span class="line">  <span class="keyword">var</span> name = <span class="string">&#x27;mu&#x27;</span>;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">handle</span>(<span class="params">val</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(val + <span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 滚动鼠标，触发防抖，执行handle</span></span><br><span class="line">  <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;scroll&#x27;</span>, <span class="title function_">throttle</span>(handle, <span class="number">1000</span>, <span class="string">&#x27;木由&#x27;</span>));</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<h1 id="50-HTML、XML、XHTML-的区别"><a href="#50-HTML、XML、XHTML-的区别" class="headerlink" title="50.HTML、XML、XHTML 的区别"></a>50.HTML、XML、XHTML 的区别</h1><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="code">`HTML`</span>：超文本标记语言，是语法较为松散的、不严格的<span class="code">`Web`</span>语言；</span><br><span class="line"><span class="bullet">-</span> <span class="code">`XML`</span>：可扩展的标记语言，主要用于存储数据和结构，可扩展；</span><br><span class="line"><span class="bullet">-</span> <span class="code">`XHTML`</span>：可扩展的超文本标记语言，基于<span class="code">`XML`</span>，作用与<span class="code">`HTML`</span>类似，但语法更严格。</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<h1 id="51-HTML、XHTML和HTML5区别以及有什么联系"><a href="#51-HTML、XHTML和HTML5区别以及有什么联系" class="headerlink" title="51. HTML、XHTML和HTML5区别以及有什么联系"></a>51. HTML、XHTML和HTML5区别以及有什么联系</h1><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">XHTML与HTML的区别</span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> <span class="code">`XHTML`</span>标签名必须小写；</span><br><span class="line"><span class="bullet">-</span> <span class="code">`XHTML`</span>元素必须被关闭；</span><br><span class="line"><span class="bullet">-</span> <span class="code">`XHTML`</span>元素必须被正确的嵌套；</span><br><span class="line"><span class="bullet">-</span> <span class="code">`XHTML`</span>元素必须要有根元素。</span><br><span class="line"></span><br><span class="line">XHTML与HTML5的区别</span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> <span class="code">`HTML5`</span>新增了<span class="code">`canvas`</span>绘画元素；</span><br><span class="line"><span class="bullet">-</span> <span class="code">`HTML5`</span>新增了用于绘媒介回放的<span class="code">`video`</span>和<span class="code">`audio`</span>元素；</span><br><span class="line"><span class="bullet">-</span> 更具语义化的标签，便于浏览器识别；</span><br><span class="line"><span class="bullet">-</span> 对本地离线存储有更好的支持；</span><br><span class="line"><span class="bullet">-</span> <span class="code">`MATHML`</span>，<span class="code">`SVG`</span>等，可以更好的<span class="code">`render`</span>；</span><br><span class="line"><span class="bullet">-</span> 添加了新的表单控件：<span class="code">`calendar`</span>、<span class="code">`date`</span>、<span class="code">`time`</span>、<span class="code">`email`</span>等。</span><br><span class="line"></span><br><span class="line">HTML、XHTML、HTML5之间联系</span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> <span class="code">`XHTML`</span>是<span class="code">`HTML`</span>规范版本；</span><br><span class="line"><span class="bullet">-</span> <span class="code">`HTML5`</span>是<span class="code">`HTML`</span>、<span class="code">`XHTML`</span>以及<span class="code">`HTML DOM`</span>的新标准。</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<h1 id="52-行内元素有哪些？块级元素有哪些？-空-void-元素有那些？"><a href="#52-行内元素有哪些？块级元素有哪些？-空-void-元素有那些？" class="headerlink" title="52.行内元素有哪些？块级元素有哪些？ 空(void)元素有那些？"></a>52.行内元素有哪些？块级元素有哪些？ 空(void)元素有那些？</h1><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> 行内元素： <span class="code">`a`</span>, <span class="code">`b`</span>, <span class="code">`span`</span>, <span class="code">`img`</span>, <span class="code">`input`</span>, <span class="code">`select`</span>, <span class="code">`strong`</span>;</span><br><span class="line"><span class="bullet">-</span> 块级元素： <span class="code">`div`</span>, <span class="code">`ul`</span>, <span class="code">`li`</span>, <span class="code">`dl`</span>, <span class="code">`dt`</span>, <span class="code">`dd`</span>, <span class="code">`h1-5`</span>, <span class="code">`p`</span>等；</span><br><span class="line"><span class="bullet">-</span> 空元素： <span class="code">`&lt;br&gt;`</span>, <span class="code">`&lt;hr&gt;`</span>, <span class="code">`&lt;img&gt;`</span>, <span class="code">`&lt;link&gt;`</span>, <span class="code">`&lt;meta&gt;`</span>;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<h1 id="53-页面导入样式时，使用link和-import有什么区别"><a href="#53-页面导入样式时，使用link和-import有什么区别" class="headerlink" title="53. 页面导入样式时，使用link和@import有什么区别"></a>53. 页面导入样式时，使用link和@import有什么区别</h1><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="code">`link`</span>属于<span class="code">`HTML`</span>标签，而<span class="code">`@import`</span>是<span class="code">`css`</span>提供的；</span><br><span class="line"><span class="bullet">-</span> 页面被加载时，<span class="code">`link`</span>会同时被加载，而<span class="code">`@import`</span>引用的css会等到页面被加载完再加载；</span><br><span class="line"><span class="bullet">-</span> <span class="code">`@import`</span>只在<span class="code">`IE5`</span>以上才能识别，而<span class="code">`link`</span>是<span class="code">`XHTML`</span>标签，无兼容问题；</span><br><span class="line"><span class="bullet">-</span> <span class="code">`link`</span>方式的样式的权重高于<span class="code">`@import`</span>的权重。</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<h1 id="54-如何理解语义化标签"><a href="#54-如何理解语义化标签" class="headerlink" title="54. 如何理解语义化标签"></a>54. 如何理解语义化标签</h1><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">概念</span><br><span class="line"></span><br><span class="line">语义化是指根据内容的结构化（内容语义化），选择合适的标签（代码语义化），便于开发者阅读和写出更优雅的代码的同时，让浏览器的爬虫和机器很好的解析。</span><br><span class="line"></span><br><span class="line">语义化的好处</span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> 用正确的标签做正确的事情；</span><br><span class="line"><span class="bullet">-</span> 去掉或者丢失样式的时候能够让页面呈现出清晰的结构；</span><br><span class="line"><span class="bullet">-</span> 方便其他设备解析（如屏幕阅读器、盲人阅读器、移动设备）以意义的方式来渲染网页；</span><br><span class="line"><span class="bullet">-</span> 有利于<span class="code">`SEO`</span>：和搜索引擎建立良好沟通，有助于爬虫抓取更多的有效信息：爬虫依赖于标签来确定上下文和各个关键字的权重；</span><br><span class="line"><span class="bullet">-</span> 便于团队开发和维护，语义化更具可读性，遵循W3C标准的团队都遵循这个标准，可以减少差异化。</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<h1 id="55-property和attribute的区别是什么"><a href="#55-property和attribute的区别是什么" class="headerlink" title="55. property和attribute的区别是什么"></a>55. property和attribute的区别是什么</h1><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="code">`property`</span>是<span class="code">`DOM`</span>中的属性，是<span class="code">`JavaScript`</span>里的对象;</span><br><span class="line"><span class="bullet">-</span> <span class="code">`attribute`</span>是<span class="code">`HTML`</span>标签上的特性，它的值只能够是字符串;</span><br><span class="line"></span><br><span class="line">简单的理解就是：<span class="code">`Attribute`</span>就是<span class="code">`DOM`</span>节点自带的属性，例如<span class="code">`html`</span>中常用的<span class="code">`id`</span>、<span class="code">`class`</span>、<span class="code">`title`</span>、<span class="code">`align`</span>等；而<span class="code">`Property`</span>是这个<span class="code">`DOM`</span>元素作为对象，其附加的内容，例如<span class="code">`childNodes`</span>、<span class="code">`firstChild`</span>等。</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<h1 id="56-html5有哪些新特性、移除了那些元素"><a href="#56-html5有哪些新特性、移除了那些元素" class="headerlink" title="56. html5有哪些新特性、移除了那些元素"></a>56. html5有哪些新特性、移除了那些元素</h1><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">新特性</span><br><span class="line"></span><br><span class="line"><span class="strong">**HTML5 现在已经不是 SGML 的子集，主要是关于图像，位置，存储，多任务等功能的增加。**</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> 拖拽释放<span class="code">`(Drag and drop)`</span> <span class="code">`API`</span>；</span><br><span class="line"><span class="bullet">-</span> 语义化更好的内容标签（<span class="code">`header`</span>, <span class="code">`nav`</span>, <span class="code">`footer`</span>, <span class="code">`aside`</span>, <span class="code">`article`</span>, <span class="code">`section`</span>）;</span><br><span class="line"><span class="bullet">-</span> 音频、视频API(<span class="code">`audio`</span>, <span class="code">`video`</span>);</span><br><span class="line"><span class="bullet">-</span> 画布<span class="code">`(Canvas)`</span> <span class="code">`API`</span>;</span><br><span class="line"><span class="bullet">-</span> 地理<span class="code">`(Geolocation)`</span> <span class="code">`API`</span>;</span><br><span class="line"><span class="bullet">-</span> 本地离线存储 <span class="code">`localStorage`</span> 长期存储数据，浏览器关闭后数据不丢失；</span><br><span class="line"><span class="bullet">-</span> <span class="code">`sessionStorage`</span> 的数据在浏览器关闭后自动删除;</span><br><span class="line"><span class="bullet">-</span> 表单控件:<span class="code">`calendar`</span>、<span class="code">`date`</span>、<span class="code">`time`</span>、<span class="code">`email`</span>、<span class="code">`url`</span>、<span class="code">`search`</span> ;</span><br><span class="line"><span class="bullet">-</span> 新的技术<span class="code">`webworker`</span>, <span class="code">`websocket`</span>, <span class="code">`Geolocation`</span>等；</span><br><span class="line"></span><br><span class="line">移除元素</span><br><span class="line"></span><br><span class="line"><span class="strong">**纯表现元素**</span>：</span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> <span class="code">`&lt;basefont&gt;`</span> 默认字体，不设置字体，以此渲染；</span><br><span class="line"><span class="bullet">-</span> <span class="code">`&lt;font&gt;`</span> 字体标签；</span><br><span class="line"><span class="bullet">-</span> <span class="code">`&lt;center&gt;`</span> 水平居中；</span><br><span class="line"><span class="bullet">-</span> <span class="code">`&lt;u&gt;`</span> 下划线；</span><br><span class="line"><span class="bullet">-</span> <span class="code">`&lt;big&gt;`</span>字体；</span><br><span class="line"><span class="bullet">-</span> <span class="code">`&lt;strike&gt;`</span>中横字；</span><br><span class="line"><span class="bullet">-</span> <span class="code">`&lt;tt&gt;`</span>文本等宽；</span><br><span class="line"></span><br><span class="line"><span class="strong">**对可用性产生负面影响的元素**</span>：</span><br><span class="line"></span><br><span class="line"><span class="code">`&lt;frameset&gt;`</span>,<span class="code">`&lt;noframes&gt;`</span>和<span class="code">`&lt;frame&gt;`</span>；</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<h1 id="57-什么是前端的结构，样式和行为相分离？以及分离的好处是什么？"><a href="#57-什么是前端的结构，样式和行为相分离？以及分离的好处是什么？" class="headerlink" title="57. 什么是前端的结构，样式和行为相分离？以及分离的好处是什么？"></a>57. 什么是前端的结构，样式和行为相分离？以及分离的好处是什么？</h1><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">结构，样式和行为分离</span><br><span class="line"></span><br><span class="line">若是将前端比作一个人来举例子，结构（<span class="code">`HTML`</span>）就相当于是人体的“骨架”，样式就相当于人体的“装饰”，例如衣服，首饰等；行为就相当于人做出的一系列“动作”。</span><br><span class="line"></span><br><span class="line">在结构，样式和行为分离，就是将三者分离开，各自负责各自的内容，各部分可以通过引用进行使用。</span><br><span class="line"></span><br><span class="line">在分离的基础上，我们需要做到代码的：<span class="strong">**精简**</span>， <span class="strong">**重用**</span>， <span class="strong">**有序**</span>。</span><br><span class="line"></span><br><span class="line">分离的好处</span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> 代码分离，利于团队的开发和后期的维护；</span><br><span class="line"><span class="bullet">-</span> 减少维护成本，提高可读性和更好的兼容性；</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<h1 id="58-如何对网站的文件和资源进行优化"><a href="#58-如何对网站的文件和资源进行优化" class="headerlink" title="58. 如何对网站的文件和资源进行优化"></a>58. 如何对网站的文件和资源进行优化</h1><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> 文件合并（目的是减少<span class="code">`http`</span>请求）；</span><br><span class="line"><span class="bullet">-</span> 文件压缩 （目的是直接减少文件下载的体积）；</span><br><span class="line"><span class="bullet">-</span> 使用缓存；</span><br><span class="line"><span class="bullet">-</span> 使用<span class="code">`cdn`</span>托管资源；</span><br><span class="line"><span class="bullet">-</span> <span class="code">`gizp`</span>压缩需要的js和css文件；</span><br><span class="line"><span class="bullet">-</span> 反向链接，网站外链接优化；</span><br><span class="line"><span class="bullet">-</span> meta标签优化（<span class="code">`title`</span>, <span class="code">`description`</span>, <span class="code">`keywords`</span>）,<span class="code">`heading`</span>标签的优化,<span class="code">`alt`</span>优化；</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<h1 id="59-Html5中本地存储概念是什么，有什么优点，与cookie有什么区别？"><a href="#59-Html5中本地存储概念是什么，有什么优点，与cookie有什么区别？" class="headerlink" title="59. Html5中本地存储概念是什么，有什么优点，与cookie有什么区别？"></a>59. Html5中本地存储概念是什么，有什么优点，与cookie有什么区别？</h1><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="code">`HTML5`</span>的<span class="code">`Web storage`</span>的存储方式有两种：<span class="code">`sessionStorage`</span>和<span class="code">`localStorage`</span>。</span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> <span class="code">`sessionStorage`</span>用于本地存储一个会话中的数据，当会话结束后就会销毁；</span><br><span class="line"><span class="bullet">-</span> 和<span class="code">`sessionStorage`</span>不同，<span class="code">`localStorage`</span>用于持久化的本地存储，除非用户主动删除数据，否则数据永远不会过期；</span><br><span class="line"><span class="bullet">-</span> <span class="code">`cookie`</span>是网站为了标示用户身份而储存在用户本地终端（<span class="code">`Client Side`</span>）上的数据（通常经过加密）。</span><br><span class="line"></span><br><span class="line"><span class="strong">**区别**</span>：</span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> <span class="strong">**从浏览器和服务器间的传递看**</span>： <span class="code">`cookie`</span>数据始终在同源的http请求中携带（即使不需要），即<span class="code">`cookie`</span>在浏览器和服务器间来回传递；而<span class="code">`sessionStorage`</span>和<span class="code">`localStorage`</span>不会自动把数据发给服务器，仅在本地保存。</span><br><span class="line"><span class="bullet">-</span> <span class="strong">**从大小看**</span>： 存储大小限制不同，<span class="code">`cookie`</span>数据不能超过<span class="code">`4k`</span>，只适合保存很小的数据；而<span class="code">`sessionStorage`</span>和<span class="code">`localStorage`</span> 虽然也有存储大小的限制，但比<span class="code">`cookie`</span>大得多，可以达到5M或更大。</span><br><span class="line"><span class="bullet">-</span> <span class="strong">**从数据有效期看**</span>： <span class="code">`sessionStorage`</span>在会话关闭会立刻关闭，因此持续性不久；<span class="code">`cookie`</span>只在设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭。而<span class="code">`localStorage`</span>始终有效。</span><br><span class="line"><span class="bullet">-</span> <span class="strong">**从作用域看**</span>： <span class="code">`sessionStorage`</span>不在不同的浏览器窗口中共享，即使是同一个页面；而<span class="code">`localStorage`</span>和<span class="code">`cookie`</span>都是可以在所有的同源窗口中共享的。</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<h1 id="60-常见的浏览器内核有哪些"><a href="#60-常见的浏览器内核有哪些" class="headerlink" title="60. 常见的浏览器内核有哪些"></a>60. 常见的浏览器内核有哪些</h1><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="code">`Trident`</span>内核：IE最先开发或使用的， 360浏览器；</span><br><span class="line"><span class="bullet">-</span> <span class="code">`Webkit`</span>内核：Google Chrome，Safari， 搜狗浏览器，360极速浏览器， 阿里云浏览器等；</span><br><span class="line"><span class="bullet">-</span> <span class="code">`Gecko`</span>内核： Mozilla FireFox (火狐浏览器) ，K-Meleon浏览器；</span><br><span class="line"><span class="bullet">-</span> <span class="code">`Presto`</span>内核：Opera浏览器；</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<h1 id="61-LocalStorage本地存储在HTML5中有什么用途"><a href="#61-LocalStorage本地存储在HTML5中有什么用途" class="headerlink" title="61. LocalStorage本地存储在HTML5中有什么用途"></a>61. LocalStorage本地存储在HTML5中有什么用途</h1><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="code">`localStorage`</span>本地存储相当于一个轻量级的数据库，可以在本地永久的储存数据（除非人为删除）。此外，还可以在断网情况下读取本地缓存的<span class="code">`cookies`</span>。</span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> 使用<span class="code">`localStorage`</span>保存数据： <span class="code">`localStorage.setItem(key, value)`</span>;</span><br><span class="line"><span class="bullet">-</span> 使用<span class="code">`localStorage`</span>获取保存的数据: <span class="code">`localStorage.getItem(key)`</span>;</span><br><span class="line"><span class="bullet">-</span> 清除<span class="code">`localStorage`</span>保存的数据： <span class="code">`localStorage.removeItem(key)`</span>;</span><br><span class="line"><span class="bullet">-</span> 清除全部<span class="code">`localStorage`</span>对象保存的数据: <span class="code">`localStorage.clear( )`</span>;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<h1 id="62-为什么利用多个域名来存储网站资源会更有效"><a href="#62-为什么利用多个域名来存储网站资源会更有效" class="headerlink" title="62. 为什么利用多个域名来存储网站资源会更有效"></a>62. 为什么利用多个域名来存储网站资源会更有效</h1><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="code">`CDN`</span>缓存更加方便；</span><br><span class="line"><span class="bullet">-</span> 突破浏览器并发限制；</span><br><span class="line"><span class="bullet">-</span> 节约<span class="code">`cookie`</span>宽带；</span><br><span class="line"><span class="bullet">-</span> 节约主域名的连接数，优化页面下响应速度；</span><br><span class="line"><span class="bullet">-</span> 防止不必要的安全问题；</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<h1 id="63-HTML中几种图片格式的区别以及使用"><a href="#63-HTML中几种图片格式的区别以及使用" class="headerlink" title="63. HTML中几种图片格式的区别以及使用"></a>63. HTML中几种图片格式的区别以及使用</h1><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">页面中常用的几种图片格式有: <span class="code">`png`</span>, <span class="code">`jpg(jpeg)`</span>,<span class="code">`gif`</span>, <span class="code">`bmp`</span>等；</span><br><span class="line"></span><br><span class="line">（1）、<span class="strong">**Png格式的特征**</span></span><br><span class="line"></span><br><span class="line">特征： 图片背景透明，可以支持的颜色有很多。</span><br><span class="line"></span><br><span class="line">使用范围: 比较广，在目前使用频率最高。</span><br><span class="line"></span><br><span class="line">（2）、<span class="strong">**jpg格式特征**</span></span><br><span class="line"></span><br><span class="line">特征： 图片不支持透明，静态图，支持的颜色也比较多，可压缩。</span><br><span class="line"></span><br><span class="line">使用范围： 使用范围较广，可使用作为电脑做面壁纸，手机屏保等，可根据需求来确实使用图片的分辨率，</span><br><span class="line"></span><br><span class="line">（3）、<span class="strong">**gif格式特征**</span></span><br><span class="line"></span><br><span class="line">特征： 动态图，支持的颜色较少。</span><br><span class="line"></span><br><span class="line">使用范围： 在目前看到的在网站内使用频率较低。</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<h1 id="64-DNS是什么"><a href="#64-DNS是什么" class="headerlink" title="64.DNS是什么"></a>64.DNS是什么</h1><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">全称 Domain Name System , 即域名系统。</span><br><span class="line"></span><br><span class="line"><span class="quote">&gt; 万维网上作为域名和 IP 地址相互映射的一个分布式数据库，能够使用户更方便的访问互联网，而不用去记住能够被机器直接读取的 IP 数串。DNS 协议运行在 UDP 协议之上，使用端口号 53。</span></span><br><span class="line"></span><br><span class="line">简单的说, 通过域名, 最终得到该域名对应的 IP 地址的过程叫做域名解析（或主机名解析）。</span><br><span class="line"></span><br><span class="line"><span class="code">```text</span></span><br><span class="line"><span class="code">www.zuofc.com (域名)  - DNS解析 -&gt; 111.222.33.444 (IP地址)</span></span><br><span class="line"><span class="code">```</span></span><br><span class="line"></span><br><span class="line">有 dns 的地方, 就有缓存。浏览器、操作系统、Local DNS、根域名服务器，它们都会对 DNS 结果做一定程度的缓存。</span><br><span class="line"></span><br><span class="line">DNS 查询过程如下:</span><br><span class="line"></span><br><span class="line"><span class="bullet">1.</span> 首先搜索浏览器自身的 DNS 缓存, 如果存在，则域名解析到此完成。</span><br><span class="line"><span class="bullet">2.</span> 如果浏览器自身的缓存里面没有找到对应的条目，那么会尝试读取操作系统的 hosts 文件看是否存在对应的映射关系, 如果存在，则域名解析到此完成。</span><br><span class="line"><span class="bullet">3.</span> 如果本地 hosts 文件不存在映射关系，则查找本地 DNS 服务器 (ISP 服务器, 或者自己手动设置的 DNS 服务器), 如果存在, 域名到此解析完成。</span><br><span class="line"><span class="bullet">4.</span> 如果本地 DNS 服务器还没找到的话, 它就会向根服务器发出请求, 进行递归查询。</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<h1 id="65-什么是强缓存"><a href="#65-什么是强缓存" class="headerlink" title="65.什么是强缓存"></a>65.什么是强缓存</h1><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">强缓存</span><br><span class="line">浏览器在加载资源时，会先根据本地缓存资源的 header 中的信息判断是否命中强缓存，如果命中则直接使用缓存中的资源不会再向服务器发送请求。</span><br><span class="line"></span><br><span class="line">这里的 header 中的信息指的是 expires 和 cahe-control.</span><br><span class="line"></span><br><span class="line"><span class="title class_">Expires</span></span><br><span class="line">该字段是 http1.<span class="number">0</span> 时的规范，它的值为一个绝对时间的 <span class="variable constant_">GMT</span> 格式的时间字符串，比如 <span class="title class_">Expires</span><span class="symbol">:Mon</span>,<span class="number">18</span> <span class="title class_">Oct</span> <span class="number">2066</span> <span class="number">23</span><span class="symbol">:</span><span class="number">59</span><span class="symbol">:</span><span class="number">59</span> <span class="variable constant_">GMT</span>。这个时间代表着这个资源的失效时间，在此时间之前，即命中缓存。这种方式有一个明显的缺点，由于失效时间是一个绝对时间，所以当服务器与客户端时间偏差较大时，就会导致缓存混乱（本地时间也可以随便更改）。</span><br><span class="line"></span><br><span class="line"><span class="title class_">Cache</span>-<span class="title class_">Control</span>（优先级高于 <span class="title class_">Expires</span>）</span><br><span class="line"><span class="title class_">Cache</span>-<span class="title class_">Control</span> 是 http1.<span class="number">1</span> 时出现的 header 信息，主要是利用该字段的 max-age 值来进行判断，它是一个相对时间，例如 <span class="title class_">Cache</span>-<span class="title class_">Control</span><span class="symbol">:max-age=</span><span class="number">3600</span>，代表着资源的有效期是 <span class="number">3600</span> 秒。cache-control 除了该字段外，还有下面几个比较常用的设置值：</span><br><span class="line"></span><br><span class="line">no-cache：需要进行协商缓存，发送请求到服务器确认是否使用缓存。</span><br><span class="line">no-store：禁止使用缓存，每一次都要重新请求数据。</span><br><span class="line"><span class="keyword">public</span>：可以被所有的用户缓存，包括终端用户和 <span class="variable constant_">CDN</span> 等中间代理服务器。</span><br><span class="line"><span class="keyword">private</span>：只能被终端用户的浏览器缓存，不允许 <span class="variable constant_">CDN</span> 等中继缓存服务器对其缓存。</span><br><span class="line"><span class="title class_">Cache</span>-<span class="title class_">Control</span> 与 <span class="title class_">Expires</span> 可以在服务端配置同时启用，同时启用的时候 <span class="title class_">Cache</span>-<span class="title class_">Control</span> 优先级高。</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<h1 id="66-什么是协商缓存"><a href="#66-什么是协商缓存" class="headerlink" title="66.什么是协商缓存"></a>66.什么是协商缓存</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">当强缓存没有命中的时候，浏览器会发送一个请求到服务器，服务器根据 header 中的部分信息来判断是否命中缓存。如果命中，则返回 <span class="number">304</span> ，告诉浏览器资源未更新，可使用本地的缓存。</span><br><span class="line"></span><br><span class="line">这里的 header 中的信息指的是 <span class="keyword">Last</span><span class="operator">-</span>Modify<span class="operator">/</span>If<span class="operator">-</span>Modify<span class="operator">-</span>Since 和 ETag<span class="operator">/</span>If<span class="operator">-</span><span class="keyword">None</span><span class="operator">-</span>Match.</span><br><span class="line"></span><br><span class="line"><span class="keyword">Last</span><span class="operator">-</span>Modify<span class="operator">/</span>If<span class="operator">-</span>Modify<span class="operator">-</span>Since</span><br><span class="line">浏览器第一次请求一个资源的时候，服务器返回的 header 中会加上 <span class="keyword">Last</span><span class="operator">-</span>Modify，<span class="keyword">Last</span><span class="operator">-</span>modify 是一个时间标识该资源的最后修改时间（只能精确到秒，所以间隔时间小于 <span class="number">1</span> 秒的请求是检测不到文件更改的。）。</span><br><span class="line"></span><br><span class="line">当浏览器再次请求该资源时，request 的请求头中会包含 If<span class="operator">-</span>Modify<span class="operator">-</span>Since，该值为缓存之前返回的 <span class="keyword">Last</span><span class="operator">-</span>Modify。服务器收到 If<span class="operator">-</span>Modify<span class="operator">-</span>Since 后，根据资源的最后修改时间判断是否命中缓存。</span><br><span class="line"></span><br><span class="line">如果命中缓存，则返回 <span class="number">304</span>，并且不会返回资源内容，并且不会返回 <span class="keyword">Last</span><span class="operator">-</span>Modify。</span><br><span class="line"></span><br><span class="line">缺点:</span><br><span class="line"></span><br><span class="line">短时间内资源发生了改变，<span class="keyword">Last</span><span class="operator">-</span>Modified 并不会发生变化。</span><br><span class="line"></span><br><span class="line">周期性变化。如果这个资源在一个周期内修改回原来的样子了，我们认为是可以使用缓存的，但是 <span class="keyword">Last</span><span class="operator">-</span>Modified 可不这样认为, 因此便有了 ETag。</span><br><span class="line"></span><br><span class="line">ETag<span class="operator">/</span>If<span class="operator">-</span><span class="keyword">None</span><span class="operator">-</span><span class="keyword">Match</span></span><br><span class="line">Etag 是基于文件内容进行编码的，可以保证如果服务器有更新，一定会重新请求资源，但是编码需要付出额外的开销。</span><br><span class="line"></span><br><span class="line">与 <span class="keyword">Last</span><span class="operator">-</span>Modify<span class="operator">/</span>If<span class="operator">-</span>Modify<span class="operator">-</span>Since 不同的是，Etag<span class="operator">/</span>If<span class="operator">-</span><span class="keyword">None</span><span class="operator">-</span><span class="keyword">Match</span> 返回的是一个校验码。ETag 可以保证每一个资源是唯一的，资源变化都会导致 ETag 变化。服务器根据浏览器上送的 If<span class="operator">-</span><span class="keyword">None</span><span class="operator">-</span><span class="keyword">Match</span> 值来判断是否命中缓存。</span><br><span class="line"></span><br><span class="line">与 <span class="keyword">Last</span><span class="operator">-</span>Modified 不一样的是，当服务器返回 <span class="number">304</span> <span class="keyword">Not</span> Modified 的响应时，由于 ETag 重新生成过，response header 中还会把这个 ETag 返回，即使这个 ETag 跟之前的没有变化。</span><br><span class="line"></span><br><span class="line"><span class="keyword">Last</span><span class="operator">-</span>Modified 与 ETag 是可以一起使用的，服务器会优先验证 ETag，一致的情况下，才会继续比对 <span class="keyword">Last</span><span class="operator">-</span>Modified，最后才决定是否返回 <span class="number">304</span>。 </span><br></pre></td></tr></table></figure>
<h1 id="67-打开-Chrome-浏览器一个-Tab-页面，至少会出现几个进程？"><a href="#67-打开-Chrome-浏览器一个-Tab-页面，至少会出现几个进程？" class="headerlink" title="67.打开 Chrome 浏览器一个 Tab 页面，至少会出现几个进程？"></a>67.打开 Chrome 浏览器一个 Tab 页面，至少会出现几个进程？</h1><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">最新的 <span class="selector-tag">Chrome</span> 浏览器包括至少四个: <span class="number">1</span> 个浏览器（<span class="selector-tag">Browser</span>）主进程、<span class="number">1</span> 个 <span class="selector-tag">GPU</span> 进程、<span class="number">1</span> 个网络（<span class="selector-tag">NetWork</span>）进程、多个渲染进程和多个插件进程, 当然还有复杂的情况；</span><br><span class="line"></span><br><span class="line">页面中有 <span class="selector-tag">iframe</span> 的话, <span class="selector-tag">iframe</span> 会单独在进程中</span><br><span class="line"></span><br><span class="line">有插件的话，插件也会开启进程</span><br><span class="line"></span><br><span class="line">多个页面属于同一站点，并且从 <span class="selector-tag">a</span> 打开 <span class="selector-tag">b</span> 页面，会共用一个渲染进程</span><br><span class="line"></span><br><span class="line">装了扩展的话，扩展也会占用进程</span><br><span class="line"></span><br><span class="line">这些进程都可以通过 <span class="selector-tag">Chrome</span> 任务管理器来查看</span><br></pre></td></tr></table></figure>
<h1 id="68-即使如今多进程架构，还是会碰到单页面卡死的最终崩溃导致所有页面崩溃的情况，讲一讲你的理解？"><a href="#68-即使如今多进程架构，还是会碰到单页面卡死的最终崩溃导致所有页面崩溃的情况，讲一讲你的理解？" class="headerlink" title="68.即使如今多进程架构，还是会碰到单页面卡死的最终崩溃导致所有页面崩溃的情况，讲一讲你的理解？"></a>68.即使如今多进程架构，还是会碰到单页面卡死的最终崩溃导致所有页面崩溃的情况，讲一讲你的理解？</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">提供一种情况，就是同一站点, 围绕这个展开也行。</span><br><span class="line"></span><br><span class="line"><span class="title class_">Chrome</span> 的默认策略是，每个标签对应一个渲染进程。但是如果从一个页面打开了新页面，而新页面和当前页面属于同一站点时，那么新页面会复用父页面的渲染进程。官方把这个默认策略叫 process-per-site-instance。</span><br><span class="line"></span><br><span class="line">更加简单的来说，就是如果多个页面符合同一站点，这几个页面会分配到一个渲染进程中去, 所以有这样子的一种情况, 一个页面崩溃了，会导致同一个站点的其他页面也奔溃，这是因为它们使用的是同一个渲染进程。</span><br><span class="line"></span><br><span class="line">有人会问为什么会跑到一个进程里面呢?</span><br><span class="line"></span><br><span class="line">你想一想呀, 属于同一家的站点，比如下面三个:</span><br><span class="line"></span><br><span class="line"><span class="attr">https</span>:<span class="comment">//time.geekbang.org</span></span><br><span class="line"><span class="attr">https</span>:<span class="comment">//www.geekbang.org</span></span><br><span class="line"><span class="attr">https</span>:<span class="comment">//www.geekbang.org:8080</span></span><br><span class="line">它们在一个渲染进程中的话，它们就会共享 <span class="variable constant_">JS</span> 执行环境，也就是 A 页面可以直接在 B 页面中执行脚本了, 有些时候就是有这样子的需求嘛。</span><br></pre></td></tr></table></figure>
<h1 id="69-TCP-建立连接过程讲一讲，为什么握手需要三次？"><a href="#69-TCP-建立连接过程讲一讲，为什么握手需要三次？" class="headerlink" title="69.TCP 建立连接过程讲一讲，为什么握手需要三次？"></a>69.TCP 建立连接过程讲一讲，为什么握手需要三次？</h1><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">**三次握手**</span><br><span class="line"></span><br><span class="line">第一次握手</span><br><span class="line">客户端向服务端发送连接请求报文段。该报文段的头部中 SYN=<span class="number">1</span>，ACK=<span class="number">0</span>，seq=x。请求发送后，客户端便进入 SYN-SENT 状态。</span><br><span class="line"></span><br><span class="line">PS1：SYN=<span class="number">1</span>，ACK=<span class="number">0</span> 表示该报文段为连接请求报文。</span><br><span class="line">PS2：x 为本次 TCP 通信的字节流的初始序号。</span><br><span class="line">TCP 规定：SYN=<span class="number">1</span> 的报文段不能有数据部分，但要消耗掉一个序号。</span><br><span class="line">第二次握手</span><br><span class="line">服务端收到连接请求报文段后，如果同意连接，则会发送一个应答：SYN=<span class="number">1</span>，ACK=<span class="number">1</span>，seq=y，ack=x+<span class="number">1</span>。</span><br><span class="line">该应答发送完成后便进入 SYN-RCVD 状态。</span><br><span class="line"></span><br><span class="line">PS1：SYN=<span class="number">1</span>，ACK=<span class="number">1</span> 表示该报文段为连接同意的应答报文。</span><br><span class="line">PS2：seq=y 表示服务端作为发送者时，发送字节流的初始序号。</span><br><span class="line">PS3：ack=x+<span class="number">1</span> 表示服务端希望下一个数据报发送序号从 x+<span class="number">1</span> 开始的字节。</span><br><span class="line">第三次握手</span><br><span class="line">当客户端收到连接同意的应答后，还要向服务端发送一个确认报文段，表示：服务端发来的连接同意应答已经成功收到。</span><br><span class="line">该报文段的头部为：ACK=<span class="number">1</span>，seq=x+<span class="number">1</span>，ack=y+<span class="number">1</span>。</span><br><span class="line">客户端发完这个报文段后便进入 ESTABLISHED 状态，服务端收到这个应答后也进入 ESTABLISHED 状态，此时连接的建立完成！</span><br><span class="line"></span><br><span class="line">**为什么连接建立需要三次握手，而不是两次握手**</span><br><span class="line"></span><br><span class="line">在谢希仁著《计算机网络》第四版中讲 “三次握手” 的目的是 “为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误”。在另一部经典的《计算机网络》一书中讲“三次握手” 的目的是为了解决 “网络中存在延迟的重复分组” 的问题。这两种不用的表述其实阐明的是同一个问题。</span><br><span class="line"></span><br><span class="line">谢希仁版《计算机网络》中的例子是这样的，“已失效的连接请求报文段”的产生在这样一种情况下：client 发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达 server。本来这是一个早已失效的报文段。但 server 收到此失效的连接请求报文段后，就误认为是 client 再次发出的一个新的连接请求。于是就向 client 发出确认报文段，同意建立连接。假设不采用 “三次握手”，那么只要 server 发出确认，新的连接就建立了。由于现在 client 并没有发出建立连接的请求，因此不会理睬 server 的确认，也不会向 server 发送数据。但 server 却以为新的运输连接已经建立，并一直等待 client 发来数据。这样，server 的很多资源就白白浪费掉了。采用“三次握手” 的办法可以防止上述现象发生。例如刚才那种情况，client 不会向 server 的确认发出确认。server 由于收不到确认，就知道 client 并没有要求建立连接。”</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">**四次挥手**</span><br><span class="line"></span><br><span class="line">第一次挥手</span><br><span class="line">若 <span class="selector-tag">A</span> 认为数据发送完成，则它需要向 <span class="selector-tag">B</span> 发送连接释放请求。该请求只有报文头，头中携带的主要参数为：</span><br><span class="line">FIN=<span class="number">1</span>，seq=u。此时，<span class="selector-tag">A</span> 将进入 FIN-WAIT-<span class="number">1</span> 状态。</span><br><span class="line"></span><br><span class="line">PS1：FIN=<span class="number">1</span> 表示该报文段是一个连接释放请求。</span><br><span class="line">PS2：seq=u，u-<span class="number">1</span> 是 <span class="selector-tag">A</span> 向 <span class="selector-tag">B</span> 发送的最后一个字节的序号。</span><br><span class="line">第二次挥手</span><br><span class="line"><span class="selector-tag">B</span> 收到连接释放请求后，会通知相应的应用程序，告诉它 <span class="selector-tag">A</span> 向 <span class="selector-tag">B</span> 这个方向的连接已经释放。此时 <span class="selector-tag">B</span> 进入 CLOSE-WAIT 状态，并向 <span class="selector-tag">A</span> 发送连接释放的应答，其报文头包含：</span><br><span class="line">ACK=<span class="number">1</span>，seq=v，ack=u+<span class="number">1</span>。</span><br><span class="line"></span><br><span class="line">PS1：ACK=<span class="number">1</span>：除 TCP 连接请求报文段以外，TCP 通信过程中所有数据报的 ACK 都为 <span class="number">1</span>，表示应答。</span><br><span class="line">PS2：seq=v，v-<span class="number">1</span> 是 <span class="selector-tag">B</span> 向 <span class="selector-tag">A</span> 发送的最后一个字节的序号。</span><br><span class="line">PS3：ack=u+<span class="number">1</span> 表示希望收到从第 u+<span class="number">1</span> 个字节开始的报文段，并且已经成功接收了前 u 个字节。</span><br><span class="line"><span class="selector-tag">A</span> 收到该应答，进入 FIN-WAIT-<span class="number">2</span> 状态，等待 <span class="selector-tag">B</span> 发送连接释放请求。</span><br><span class="line"></span><br><span class="line">第二次挥手完成后，<span class="selector-tag">A</span> 到 <span class="selector-tag">B</span> 方向的连接已经释放，<span class="selector-tag">B</span> 不会再接收数据，<span class="selector-tag">A</span> 也不会再发送数据。但 <span class="selector-tag">B</span> 到 <span class="selector-tag">A</span> 方向的连接仍然存在，<span class="selector-tag">B</span> 可以继续向 <span class="selector-tag">A</span> 发送数据。</span><br><span class="line"></span><br><span class="line">第三次挥手</span><br><span class="line">当 <span class="selector-tag">B</span> 向 <span class="selector-tag">A</span> 发完所有数据后，向 <span class="selector-tag">A</span> 发送连接释放请求，请求头：FIN=<span class="number">1</span>，ACK=<span class="number">1</span>，seq=w，ack=u+<span class="number">1</span>。<span class="selector-tag">B</span> 便进入 LAST-ACK 状态。</span><br><span class="line"></span><br><span class="line">第四次挥手</span><br><span class="line"><span class="selector-tag">A</span> 收到释放请求后，向 <span class="selector-tag">B</span> 发送确认应答，此时 <span class="selector-tag">A</span> 进入 <span class="selector-tag">TIME</span>-WAIT 状态。该状态会持续 <span class="number">2MS</span>L 时间，若该时间段内没有 <span class="selector-tag">B</span> 的重发请求的话，就进入 CLOSED 状态，撤销 TCB。当 <span class="selector-tag">B</span> 收到确认应答后，也便进入 CLOSED 状态，撤销 TCB。</span><br><span class="line"></span><br><span class="line">为什么 <span class="selector-tag">A</span> 要先进入 <span class="selector-tag">TIME</span>-WAIT 状态，等待 <span class="number">2MS</span>L 时间后才进入 CLOSED 状态？</span><br><span class="line">为了保证 <span class="selector-tag">B</span> 能收到 <span class="selector-tag">A</span> 的确认应答。</span><br><span class="line">若 <span class="selector-tag">A</span> 发完确认应答后直接进入 CLOSED 状态，那么如果该应答丢失，<span class="selector-tag">B</span> 等待超时后就会重新发送连接释放请求，但此时 <span class="selector-tag">A</span> 已经关闭了，不会作出任何响应，因此 <span class="selector-tag">B</span> 永远无法正常关闭。</span><br></pre></td></tr></table></figure>
<h1 id="70-从输入-URL-到页面展示，这中间发生了什么"><a href="#70-从输入-URL-到页面展示，这中间发生了什么" class="headerlink" title="70.从输入 URL 到页面展示，这中间发生了什么"></a>70.从输入 URL 到页面展示，这中间发生了什么</h1><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">URL解析</span><br><span class="line"><span class="bullet">  -</span> 首先判断你输入的是一个合法的URL 还是一个待搜索的关键词，并且根据你输入的内容进行对应操作</span><br><span class="line">DNS 查询</span><br><span class="line"><span class="bullet">  -</span> DNS查询对应ip</span><br><span class="line">TCP 连接</span><br><span class="line"><span class="bullet">  -</span> 在确定目标服务器服务器的IP地址后，则经历三次握手建立TCP连接</span><br><span class="line">HTTP 请求</span><br><span class="line"><span class="bullet">  -</span> 当建立tcp连接之后，就可以在这基础上进行通信，浏览器发送 http 请求到目标服务器</span><br><span class="line">响应请求</span><br><span class="line"><span class="bullet">  -</span> 当服务器接收到浏览器的请求之后，就会进行逻辑操作，处理完成之后返回一个HTTP响应消息</span><br><span class="line">页面渲染</span><br><span class="line"><span class="bullet">  -</span> 当浏览器接收到服务器响应的资源后，首先会对资源进行解析：</span><br><span class="line"></span><br><span class="line">  查看响应头的信息，根据不同的指示做对应处理，比如重定向，存储cookie，解压gzip，缓存资源等等</span><br><span class="line">  查看响应头的 Content-Type的值，根据不同的资源类型采用不同的解析方式</span><br><span class="line">  关于页面的渲染过程如下：</span><br><span class="line"></span><br><span class="line">  解析HTML，构建 DOM 树</span><br><span class="line">  解析 CSS ，生成 CSS 规则树</span><br><span class="line">  合并 DOM 树和 CSS 规则，生成 render 树</span><br><span class="line">  布局 render 树（ Layout / reflow ），负责各元素尺寸、位置的计算</span><br><span class="line">  绘制 render 树（ paint ），绘制页面像素信息</span><br><span class="line">  浏览器会将各层的信息发送给 GPU，GPU 会将各层合成（ composite ），显示在屏幕上</span><br></pre></td></tr></table></figure>
<h1 id="71-什么是-CDN"><a href="#71-什么是-CDN" class="headerlink" title="71.什么是 CDN"></a>71.什么是 CDN</h1><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">全称 <span class="attribute">Content</span> Delivery Network, 即内容分发网络。</span><br><span class="line"></span><br><span class="line">摘录一个形象的比喻, 来理解 CDN 是什么。</span><br><span class="line"></span><br><span class="line"><span class="number">10</span> 年前，还没有火车票代售点一说，<span class="number">12306</span><span class="selector-class">.cn</span> 更是无从说起。那时候火车票还只能在火车站的售票大厅购买，而我所在的小县城并不通火车，火车票都要去市里的火车站购买，而从我家到县城再到市里，来回就是 <span class="number">4</span> 个小时车程，简直就是浪费生命。后来就好了，小县城里出现了火车票代售点，甚至乡镇上也有了代售点，可以直接在代售点购买火车票，方便了不少，全市人民再也不用在一个点苦逼的排队买票了。</span><br><span class="line"></span><br><span class="line">简单的理解 CDN 就是这些代售点 (缓存服务器) 的承包商, 他为买票者提供了便利, 帮助他们在最近的地方 (最近的 CDN 节点) 用最短的时间 (最短的请求时间) 买到票(拿到资源), 这样去火车站售票大厅排队的人也就少了。也就减轻了售票大厅的压力(起到分流作用, 减轻服务器负载压力)。</span><br><span class="line"></span><br><span class="line">用户在浏览网站的时候，CDN 会选择一个离用户最近的 CDN 边缘节点来响应用户的请求，这样海南移动用户的请求就不会千里迢迢跑到北京电信机房的服务器（假设源站部署在北京电信机房）上了。</span><br><span class="line"></span><br><span class="line">CDN 缓存</span><br><span class="line">关于 CDN 缓存, 在浏览器本地缓存失效后, 浏览器会向 CDN 边缘节点发起请求。类似浏览器缓存, CDN 边缘节点也存在着一套缓存机制。CDN 边缘节点缓存策略因服务商不同而不同，但一般都会遵循 http 标准协议，通过 http 响应头中的</span><br><span class="line"></span><br><span class="line">Cache-control: max-age   //后面会提到</span><br><span class="line">的字段来设置 CDN 边缘节点数据缓存时间。</span><br><span class="line"></span><br><span class="line">当浏览器向 CDN 节点请求数据时，CDN 节点会判断缓存数据是否过期，若缓存数据并没有过期，则直接将缓存数据返回给客户端；否则，CDN 节点就会向服务器发出回源请求，从服务器拉取最新数据，更新本地缓存，并将最新数据返回给客户端。 CDN 服务商一般会提供基于文件后缀、目录多个维度来指定 CDN 缓存时间，为用户提供更精细化的缓存管理。</span><br><span class="line"></span><br><span class="line">CDN 优势</span><br><span class="line">CDN 节点解决了跨运营商和跨地域访问的问题，访问延时大大降低。</span><br><span class="line">大部分请求在 CDN 边缘节点完成，CDN 起到了分流作用，减轻了源服务器的负载。</span><br></pre></td></tr></table></figure>
<h1 id="72-说说HTTP与HTTPS的区别"><a href="#72-说说HTTP与HTTPS的区别" class="headerlink" title="72. 说说HTTP与HTTPS的区别"></a>72. 说说HTTP与HTTPS的区别</h1><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HTTPS是HTTP协议的安全版本，HTTP协议的数据传输是明文的，是不安全的，HTTPS使用了SSL/TLS协议进行了加密处理，相对更安全</span><br><span class="line">HTTP 和 HTTPS 使用连接方式不同，默认端口也不一样，HTTP是80，HTTPS是443</span><br><span class="line">HTTPS 由于需要设计加密以及多次握手，性能方面不如 HTTP</span><br><span class="line">HTTPS需要SSL，SSL 证书需要钱，功能越强大的证书费用越高</span><br></pre></td></tr></table></figure>
<h1 id="73-webpack文件指纹策略：hash-chunkhash-contenthash"><a href="#73-webpack文件指纹策略：hash-chunkhash-contenthash" class="headerlink" title="73.webpack文件指纹策略：hash chunkhash contenthash"></a>73.webpack文件指纹策略：hash chunkhash contenthash</h1><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">hash策略：是以项目为单位的，项目内容改变则会生成新的hash，内容不变则hash不变</span><br><span class="line"></span><br><span class="line">chunkhash策略：是以chunk为单位的，当一个文件内容改变，则整个相应的chunk组模块的hash回发生改变</span><br><span class="line"></span><br><span class="line">contenthash策略：是以自身内容为单为的</span><br><span class="line"></span><br><span class="line">推荐使用：css ：contenthash</span><br><span class="line"></span><br><span class="line">•js：chunkhash</span><br></pre></td></tr></table></figure>
<h1 id="74-说说webpack的构建流程"><a href="#74-说说webpack的构建流程" class="headerlink" title="74.说说webpack的构建流程"></a>74.说说webpack的构建流程</h1><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2f6f2ca5dcff4bdcb1e0397661d9e583~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="在这里插入图片描述"></p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.初始化参数：解析webpack配置参数，合并shell传入和webpack.config.js文件配置的参数，形成最后的配置结果。</span><br><span class="line">2.开始编译：上一步得到的参数初始化compiler对象，注册所有配置的插件，插件监听webpack构建生命周期的事件节点，做出相应的反应，执行对象的 run 方法开始执行编译。</span><br><span class="line">3.确定入口：从配置的entry入口，开始解析文件构建AST语法树，找出依赖，递归下去。</span><br><span class="line">4.编译模块：递归中根据文件类型和loader配置，调用所有配置的loader对文件进行转换，再找出该模块依赖的模块，再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理。</span><br><span class="line">5.完成模块编译：在经过第4步使⽤ Loader 翻译完所有模块后，得到了每个模块被翻译后的最终内容以及它们之间的依赖关系；</span><br><span class="line">6.输出资源：根据⼊⼝和模块之间的依赖关系，组装成⼀个个包含多个模块的 Chunk，再把每个 Chunk 转换成⼀个单独的⽂件加⼊到输出列表，这步是可以修改输出内容的最后机会；</span><br><span class="line">7.输出完成：在确定好输出内容后，根据配置确定输出的路径和⽂件名，把⽂件内容写⼊到⽂件系统。</span><br></pre></td></tr></table></figure>
<h1 id="75-说说Loader和Plugin的区别？编写Loader，Plugin的思路"><a href="#75-说说Loader和Plugin的区别？编写Loader，Plugin的思路" class="headerlink" title="75.说说Loader和Plugin的区别？编写Loader，Plugin的思路"></a>75.说说Loader和Plugin的区别？编写Loader，Plugin的思路</h1><h2 id="一、区别"><a href="#一、区别" class="headerlink" title="一、区别"></a>一、区别</h2><ul>
<li>loader 是文件加载器，能够加载资源文件，并对这些文件进行一些处理，诸如编译、压缩等，最终一起打包到指定的文件中</li>
<li>plugin 赋予了 webpack 各种灵活的功能，例如打包优化、资源管理、环境变量注入等，目的是解决 loader 无法实现的其他事</li>
</ul>
<p>从整个运行时机上来看，如下图所示：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/82612d86c7ae4aeaafc68a3487df9f93~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="img"></p>
<p>可以看到，两者在运行时机上的区别：</p>
<ul>
<li>loader 运行在打包文件之前</li>
<li>plugins 在整个编译周期都起作用</li>
</ul>
<p>在<code>Webpack</code> 运行的生命周期中会广播出许多事件，<code>Plugin</code> 可以监听这些事件，在合适的时机通过<code>Webpack</code>提供的 <code>API</code>改变输出结果</p>
<p>对于<code>loader</code>，实质是一个转换器，将A文件进行编译形成B文件，操作的是文件，比如将<code>A.scss</code>或<code>A.less</code>转变为<code>B.css</code>，单纯的文件转换过程</p>
<h2 id="二、编写loader"><a href="#二、编写loader" class="headerlink" title="二、编写loader"></a>二、编写loader</h2><p>在编写 <code>loader</code> 前，我们首先需要了解 <code>loader</code> 的本质</p>
<p>其本质为函数，函数中的 <code>this</code> 作为上下文会被 <code>webpack</code> 填充，因此我们不能将 <code>loader</code>设为一个箭头函数</p>
<p>函数接受一个参数，为 <code>webpack</code> 传递给 <code>loader</code> 的文件源内容</p>
<p>函数中 <code>this</code> 是由 <code>webpack</code> 提供的对象，能够获取当前 <code>loader</code> 所需要的各种信息</p>
<p>函数中有异步操作或同步操作，异步操作通过 <code>this.callback</code> 返回，返回值要求为 <code>string</code> 或者 <code>Buffer</code></p>
<p>代码如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导出一个函数，source为webpack传递给loader的文件源内容</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="keyword">function</span>(<span class="params">source</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> content = <span class="title function_">doSomeThing2JsString</span>(source);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果 loader 配置了 options 对象，那么this.query将指向 options</span></span><br><span class="line">    <span class="keyword">const</span> options = <span class="variable language_">this</span>.<span class="property">query</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 可以用作解析其他模块路径的上下文</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;this.context&#x27;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * this.callback 参数：</span></span><br><span class="line"><span class="comment">     * error：Error | null，当 loader 出错时向外抛出一个 error</span></span><br><span class="line"><span class="comment">     * content：String | Buffer，经过 loader 编译后需要导出的内容</span></span><br><span class="line"><span class="comment">     * sourceMap：为方便调试生成的编译后内容的 source map</span></span><br><span class="line"><span class="comment">     * ast：本次编译生成的 AST 静态语法树，之后执行的 loader 可以直接使用这个 AST，进而省去重复生成 AST 的过程</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">callback</span>(<span class="literal">null</span>, content); <span class="comment">// 异步</span></span><br><span class="line">    <span class="keyword">return</span> content; <span class="comment">// 同步</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<p>一般在编写<code>loader</code>的过程中，保持功能单一，避免做多种功能</p>
<p>如<code>less</code>文件转换成 <code>css</code>文件也不是一步到位，而是 <code>less-loader</code>、<code>css-loader</code>、<code>style-loader</code>几个 <code>loader</code>的链式调用才能完成转换</p>
<h2 id="三、编写plugin"><a href="#三、编写plugin" class="headerlink" title="三、编写plugin"></a>三、编写plugin</h2><p>由于<code>webpack</code>基于发布订阅模式，在运行的生命周期中会广播出许多事件，插件通过监听这些事件，就可以在特定的阶段执行自己的插件任务</p>
<p>在之前也了解过，<code>webpack</code>编译会创建两个核心对象：</p>
<ul>
<li>compiler：包含了 webpack 环境的所有的配置信息，包括 options，loader 和 plugin，和 webpack 整个生命周期相关的钩子</li>
<li>compilation：作为 plugin 内置事件回调函数的参数，包含了当前的模块资源、编译生成资源、变化的文件以及被跟踪依赖的状态信息。当检测到一个文件变化，一次新的 Compilation 将被创建</li>
</ul>
<p>如果自己要实现<code>plugin</code>，也需要遵循一定的规范：</p>
<ul>
<li>插件必须是一个函数或者是一个包含 <code>apply</code> 方法的对象，这样才能访问<code>compiler</code>实例</li>
<li>传给每个插件的 <code>compiler</code> 和 <code>compilation</code> 对象都是同一个引用，因此不建议修改</li>
<li>异步的事件需要在插件处理完任务时调用回调函数通知 <code>Webpack</code> 进入下一个流程，不然会卡住</li>
</ul>
<p>实现<code>plugin</code>的模板如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyPlugin</span> &#123;</span><br><span class="line">    <span class="comment">// Webpack 会调用 MyPlugin 实例的 apply 方法给插件实例传入 compiler 对象</span></span><br><span class="line">  apply (compiler) &#123;</span><br><span class="line">    <span class="comment">// 找到合适的事件钩子，实现自己的插件功能</span></span><br><span class="line">    compiler.<span class="property">hooks</span>.<span class="property">emit</span>.<span class="title function_">tap</span>(<span class="string">&#x27;MyPlugin&#x27;</span>, <span class="function"><span class="params">compilation</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// compilation: 当前打包构建流程的上下文</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(compilation);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// do something...</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<p>在 <code>emit</code> 事件发生时，代表源文件的转换和组装已经完成，可以读取到最终将输出的资源、代码块、模块及其依赖，并且可以修改输出资源的内容</p>
<h1 id="76-提高webpack的构建速度"><a href="#76-提高webpack的构建速度" class="headerlink" title="76.提高webpack的构建速度"></a>76.提高webpack的构建速度</h1><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">优化 loader 配置</span><br><span class="line">合理使用 resolve.extensions</span><br><span class="line">优化 resolve.modules</span><br><span class="line">优化 resolve.<span class="keyword">alias</span></span><br><span class="line">使用 DLLPlugin 插件</span><br><span class="line">使用 cache-loader</span><br><span class="line">terser 启动多线程</span><br><span class="line">合理使用 sourceMap</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<h1 id="77-webpack-热更新是怎么做到的"><a href="#77-webpack-热更新是怎么做到的" class="headerlink" title="77.webpack 热更新是怎么做到的"></a>77.webpack 热更新是怎么做到的</h1><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">通过webpack-dev-server创建两个服务器：提供静态资源的服务（express）和Socket服务</span><br><span class="line">express server 负责直接提供静态资源的服务（打包后的资源直接被浏览器请求和解析）</span><br><span class="line">socket server 是一个 websocket 的长连接，双方可以通信</span><br><span class="line">当 socket server 监听到对应的模块发生变化时，会生成两个文件<span class="selector-class">.json</span>（manifest文件）和<span class="selector-class">.js</span>文件（update chunk）</span><br><span class="line">通过长连接，socket server 可以直接将这两个文件主动发送给客户端（浏览器）</span><br><span class="line">浏览器拿到两个新的文件后，通过HMR runtime机制，加载这两个文件，并且针对修改的模块进行更新</span><br></pre></td></tr></table></figure>
<h1 id="78-webpack中常见的Loader"><a href="#78-webpack中常见的Loader" class="headerlink" title="78.webpack中常见的Loader"></a>78.webpack中常见的Loader</h1><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">style-loader: 将css添加到DOM的内联样式标签style里</span></span><br><span class="line">css-loader :允许将css文件通过require的方式引入，并返回css代码</span><br><span class="line"><span class="section">less-loader: 处理less</span></span><br><span class="line"><span class="section">sass-loader: 处理sass</span></span><br><span class="line"><span class="section">postcss-loader: 用postcss来处理CSS</span></span><br><span class="line"><span class="section">autoprefixer-loader: 处理CSS3属性前缀，已被弃用，建议直接使用postcss</span></span><br><span class="line"><span class="section">file-loader: 分发文件到output目录并返回相对路径</span></span><br><span class="line"><span class="section">url-loader: 和file-loader类似，但是当文件小于设定的limit时可以返回一个Data Url</span></span><br><span class="line"><span class="section">html-minify-loader: 压缩HTML</span></span><br><span class="line">babel-loader :用babel来转换ES6文件到ES</span><br></pre></td></tr></table></figure>
<h1 id="79-webpack中常见的Plugin"><a href="#79-webpack中常见的Plugin" class="headerlink" title="79.webpack中常见的Plugin"></a>79.webpack中常见的Plugin</h1><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/42a9982ea5ee422d8a6877b2a36a83f1~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="img"></p>
<h1 id="80-Git常用的命令有哪些"><a href="#80-Git常用的命令有哪些" class="headerlink" title="80.Git常用的命令有哪些"></a>80.Git常用的命令有哪些</h1><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line">**基本操作**</span><br><span class="line">  </span><br><span class="line">git init 初始化仓库，默认为 master 分支</span><br><span class="line"></span><br><span class="line">git add . 提交全部文件修改到缓存区</span><br><span class="line"></span><br><span class="line">git add &lt;具体某个文件路径+全名&gt; 提交某些文件到缓存区</span><br><span class="line"></span><br><span class="line">git diff 查看当前代码 add后，会 add 哪些内容</span><br><span class="line"></span><br><span class="line">git diff --staged查看现在 commit 提交后，会提交哪些内容</span><br><span class="line"></span><br><span class="line">git status 查看当前分支状态</span><br><span class="line"></span><br><span class="line">git pull &lt;远程仓库名&gt; &lt;远程分支名&gt; 拉取远程仓库的分支与本地当前分支合并</span><br><span class="line"></span><br><span class="line">git pull &lt;远程仓库名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt; 拉取远程仓库的分支与本地某个分支合并</span><br><span class="line"></span><br><span class="line">git commit -m <span class="string">&quot;&lt;注释&gt;&quot;</span> 提交代码到本地仓库，并写提交注释</span><br><span class="line"></span><br><span class="line">git commit -v 提交时显示所有diff信息</span><br><span class="line"></span><br><span class="line">git commit --amend [file1] [file2] 重做上一次commit，并包括指定文件的新变化</span><br><span class="line"></span><br><span class="line">**提交规则**</span><br><span class="line"></span><br><span class="line"><span class="section">feat: 新特性，添加功能</span></span><br><span class="line"></span><br><span class="line"><span class="section">fix: 修改 bug</span></span><br><span class="line"></span><br><span class="line"><span class="section">refactor: 代码重构</span></span><br><span class="line"></span><br><span class="line"><span class="section">docs: 文档修改</span></span><br><span class="line"></span><br><span class="line"><span class="section">style: 代码格式修改, 注意不是 css 修改</span></span><br><span class="line"></span><br><span class="line"><span class="section">test: 测试用例修改</span></span><br><span class="line"></span><br><span class="line"><span class="section">chore: 其他修改, 比如构建流程, 依赖管理</span></span><br><span class="line"></span><br><span class="line">**分支操作**</span><br><span class="line">  </span><br><span class="line">git branch 查看本地所有分支</span><br><span class="line"></span><br><span class="line">git branch -r 查看远程所有分支</span><br><span class="line"></span><br><span class="line">git branch -a 查看本地和远程所有分支</span><br><span class="line"></span><br><span class="line">git merge &lt;分支名&gt; 合并分支</span><br><span class="line"></span><br><span class="line">git merge --abort 合并分支出现冲突时，取消合并，一切回到合并前的状态</span><br><span class="line"></span><br><span class="line">git branch &lt;新分支名&gt; 基于当前分支，新建一个分支</span><br><span class="line"></span><br><span class="line">git checkout --orphan &lt;新分支名&gt; 新建一个空分支（会保留之前分支的所有文件）</span><br><span class="line"></span><br><span class="line">git branch -D &lt;分支名&gt; 删除本地某个分支</span><br><span class="line"></span><br><span class="line">git push &lt;远程库名&gt; :&lt;分支名&gt; 删除远程某个分支</span><br><span class="line"></span><br><span class="line">git branch &lt;新分支名称&gt; &lt;提交ID&gt; 从提交历史恢复某个删掉的某个分支</span><br><span class="line"></span><br><span class="line">git branch -m &lt;原分支名&gt; &lt;新分支名&gt; 分支更名</span><br><span class="line"></span><br><span class="line">git checkout &lt;分支名&gt; 切换到本地某个分支</span><br><span class="line"></span><br><span class="line">git checkout &lt;远程库名&gt;/&lt;分支名&gt; 切换到线上某个分支</span><br><span class="line"></span><br><span class="line">git checkout -b &lt;新分支名&gt; 把基于当前分支新建分支，并切换为这个分支</span><br><span class="line"></span><br><span class="line">**远程操作**</span><br><span class="line"></span><br><span class="line">git fetch [remote] 下载远程仓库的所有变动</span><br><span class="line"></span><br><span class="line">git remote -v 显示所有远程仓库</span><br><span class="line"></span><br><span class="line">git pull [remote] [branch] 拉取远程仓库的分支与本地当前分支合并</span><br><span class="line"></span><br><span class="line">git fetch 获取线上最新版信息记录，不合并</span><br><span class="line"></span><br><span class="line">git push [remote] [branch] 上传本地指定分支到远程仓库</span><br><span class="line"></span><br><span class="line">git push [remote] --force 强行推送当前分支到远程仓库，即使有冲突</span><br><span class="line"></span><br><span class="line">git push [remote] --all 推送所有分支到远程仓库</span><br><span class="line"></span><br><span class="line">**撤销操作**</span><br><span class="line"></span><br><span class="line">git checkout [file] 恢复暂存区的指定文件到工作区</span><br><span class="line"></span><br><span class="line">git checkout [commit] [file] 恢复某个commit的指定文件到暂存区和工作区</span><br><span class="line"></span><br><span class="line">git checkout . 恢复暂存区的所有文件到工作区</span><br><span class="line"></span><br><span class="line">git reset [commit] 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变</span><br><span class="line"></span><br><span class="line">git reset --hard 重置暂存区与工作区，与上一次commit保持一致</span><br><span class="line"></span><br><span class="line">git reset [file] 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变</span><br><span class="line"></span><br><span class="line">git revert [commit] 后者的所有变化都将被前者抵消，并且应用到当前分支</span><br><span class="line"></span><br><span class="line">reset：真实硬性回滚，目标版本后面的提交记录全部丢失了</span><br><span class="line"></span><br><span class="line">revert：同样回滚，这个回滚操作相当于一个提价，目标版本后面的提交记录也全部都有</span><br><span class="line"></span><br><span class="line">**存储操作**</span><br><span class="line"></span><br><span class="line">git stash 暂时将未提交的变化移除</span><br><span class="line"></span><br><span class="line">git stash pop 取出储藏中最后存入的工作状态进行恢复，会删除储藏</span><br><span class="line"></span><br><span class="line">git stash list 查看所有储藏中的工作</span><br><span class="line"></span><br><span class="line">git stash apply &lt;储藏的名称&gt; 取出储藏中对应的工作状态进行恢复，不会删除储藏</span><br><span class="line"></span><br><span class="line">git stash clear 清空所有储藏中的工作</span><br><span class="line"></span><br><span class="line">git stash drop &lt;储藏的名称&gt; 删除对应的某个储藏</span><br></pre></td></tr></table></figure>
<h1 id="81-标准的CSS盒子模型及其和低版本的IE盒子模型的区别？"><a href="#81-标准的CSS盒子模型及其和低版本的IE盒子模型的区别？" class="headerlink" title="81.标准的CSS盒子模型及其和低版本的IE盒子模型的区别？"></a>81.标准的CSS盒子模型及其和低版本的IE盒子模型的区别？</h1><p>标准（W3C）盒子模型：<code>width</code> = 内容宽度<code>（content） + border + padding + margin</code></p>
<p>低版本IE盒子模型： <code>width</code> = 内容宽度<code>（content + border + padding）+ margin</code></p>
<p>图片展示:</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e67a7e62bf014408ad1c20e3951c179a~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="img"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9599a855d62546d993f481f44caa252c~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="img"></p>
<p>区别： 标准盒子模型盒子的<code>height</code>和<code>width</code>是<code>content</code>（内容）的宽高，而IE盒子模型盒子的宽高则包括<code>content+padding+border</code>部分。</p>
<h1 id="82-几种解决IE6存在的bug的方法"><a href="#82-几种解决IE6存在的bug的方法" class="headerlink" title="82.几种解决IE6存在的bug的方法"></a>82.几种解决IE6存在的bug的方法</h1><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> 由<span class="code">`float`</span>引起的双边距的问题，使用<span class="code">`display`</span>解决；</span><br><span class="line"><span class="bullet">-</span> 由<span class="code">`float`</span>引起的3像素问题，使用<span class="code">`display: inline -3px`</span>;</span><br><span class="line"><span class="bullet">-</span> 使用正确的书写顺序<span class="code">`link visited hover active`</span>，解决超链接<span class="code">`hover`</span>点击失效问题；</span><br><span class="line"><span class="bullet">-</span> 对于<span class="code">`IE`</span> 的<span class="code">`z-index`</span>问题，通过给父元素增加<span class="code">`position: relative`</span>解决；</span><br><span class="line"><span class="bullet">-</span> 使用<span class="code">`!important`</span>解决<span class="code">`Min-height`</span>最小高度问题；</span><br><span class="line"><span class="bullet">-</span> 使用<span class="code">`iframe`</span>解决<span class="code">`select`</span>在<span class="code">`IE6`</span>下的覆盖问题；</span><br><span class="line"><span class="bullet">-</span> 使用<span class="code">`over: hidden`</span>, <span class="code">`zoom: 0.08`</span>, <span class="code">`line-height: 1px`</span>解决定义1px左右的容器宽度问题；</span><br></pre></td></tr></table></figure>
<h1 id="83-CSS选择符有哪些？哪些属性可以继承？"><a href="#83-CSS选择符有哪些？哪些属性可以继承？" class="headerlink" title="83.CSS选择符有哪些？哪些属性可以继承？"></a>83.CSS选择符有哪些？哪些属性可以继承？</h1><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">常见的选择符有一下：</span><br><span class="line"></span><br><span class="line">`id`选择器（`<span class="selector-id">#content</span>`），类选择器（`<span class="selector-class">.content</span>`）, 标签选择器（`<span class="selector-tag">div</span>`, `<span class="selector-tag">p</span>`, `<span class="selector-tag">span</span>`等）, 相邻选择器（`<span class="selector-tag">h1</span>+<span class="selector-tag">p</span>`）, 子选择器（`<span class="selector-tag">ul</span>&gt;<span class="selector-tag">li</span>`）, 后代选择器（`<span class="selector-tag">li</span> <span class="selector-tag">a</span>`）， 通配符选择器（`*`）, 属性选择器（`<span class="selector-tag">a</span><span class="selector-attr">[rel = <span class="string">&quot;external&quot;</span>]</span>`）， 伪类选择器（`<span class="selector-tag">a</span><span class="selector-pseudo">:hover</span>`, `<span class="selector-tag">li</span><span class="selector-pseudo">:nth-child</span>`）</span><br><span class="line"></span><br><span class="line">可继承的样式属性： `<span class="attribute">font-size</span>`, `<span class="attribute">font-family</span>`, `<span class="attribute">color</span>`, `<span class="selector-tag">ul</span>`, `<span class="selector-tag">li</span>`, `<span class="selector-tag">dl</span>`, `<span class="selector-tag">dd</span>`, `<span class="selector-tag">dt</span>`;</span><br><span class="line"></span><br><span class="line">不可继承的样式属性： `<span class="attribute">border</span>`, `<span class="attribute">padding</span>`, `<span class="attribute">margin</span>`, `<span class="attribute">width</span>`, `<span class="attribute">height</span>`；</span><br></pre></td></tr></table></figure>
<h1 id="84-position的值relative和absolute定位原点？"><a href="#84-position的值relative和absolute定位原点？" class="headerlink" title="84.position的值relative和absolute定位原点？"></a>84.position的值relative和absolute定位原点？</h1><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">首先，使用<span class="code">`position`</span>的时候，应该记住一个规律是‘<span class="strong">**子绝父相**</span>’。</span><br><span class="line"></span><br><span class="line"><span class="code">`relative`</span>（相对定位）： 生成相对定位的元素，定位原点是元素本身所在的位置；</span><br><span class="line"></span><br><span class="line"><span class="code">`absolute`</span>（绝对定位）：生成绝对定位的元素，定位原点是离自己这一级元素最近的一级<span class="code">`position`</span>设置为<span class="code">`absolute`</span>或者<span class="code">`relative`</span>的父元素的左上角为原点的。</span><br><span class="line"></span><br><span class="line"><span class="code">`fixed`</span> （老IE不支持）：生成绝对定位的元素，相对于浏览器窗口进行定位。</span><br><span class="line"></span><br><span class="line"><span class="code">`static`</span>：默认值。没有定位，元素出现在正常的流中（忽略 <span class="code">`top`</span>, <span class="code">`bottom`</span>, <span class="code">`left`</span>, <span class="code">`right`</span>、<span class="code">`z-index`</span> 声明）。</span><br><span class="line"></span><br><span class="line"><span class="code">`inherit`</span>：规定从父元素继承 <span class="code">`position`</span> 属性的值。</span><br><span class="line"></span><br><span class="line"><span class="strong">**更新一个属性**</span></span><br><span class="line"></span><br><span class="line"><span class="code">`sticky`</span>: (新增元素，目前兼容性可能不是那么的好)，可以设置 position:sticky 同时给一个 (top,bottom,right,left) 之一即可。</span><br><span class="line"></span><br><span class="line"><span class="strong">**注意**</span>：</span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> 使用<span class="code">`sticky`</span>时，必须指定top、bottom、left、right4个值之一，不然只会处于相对定位；</span><br><span class="line"><span class="bullet">-</span> <span class="code">`sticky`</span>只在其父元素内其效果，且保证父元素的高度要高于<span class="code">`sticky`</span>的高度；</span><br><span class="line"><span class="bullet">-</span> 父元素不能<span class="code">`overflow:hidden`</span>或者<span class="code">`overflow:auto`</span>等属性。</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<h1 id="85-CSS3有哪些新特性？"><a href="#85-CSS3有哪些新特性？" class="headerlink" title="85.CSS3有哪些新特性？"></a>85.CSS3有哪些新特性？</h1><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">关于<span class="code">`CSS`</span>新增的特性，有以下：</span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> 选择器;</span><br><span class="line"><span class="bullet">-</span> 圆角<span class="code">`（border-raduis）`</span>;</span><br><span class="line"><span class="bullet">-</span> 多列布局<span class="code">`（multi-column layout）`</span>;</span><br><span class="line"><span class="bullet">-</span> 阴影<span class="code">`（shadow）`</span>和反射<span class="code">`（reflect）`</span>;</span><br><span class="line"><span class="bullet">-</span> 文字特效<span class="code">`（text-shadow）`</span>;</span><br><span class="line"><span class="bullet">-</span> 文字渲染<span class="code">`（text-decoration`</span>）;</span><br><span class="line"><span class="bullet">-</span> 线性渐变<span class="code">`（gradient）`</span>;</span><br><span class="line"><span class="bullet">-</span> 旋转<span class="code">`（rotate`</span>）/缩放<span class="code">`（scale）`</span>/倾斜<span class="code">`（skew）`</span>/移动<span class="code">`（translate）`</span>;</span><br><span class="line"><span class="bullet">-</span> 媒体查询<span class="code">`（@media）`</span>;</span><br><span class="line"><span class="bullet">-</span> <span class="code">`RGBA`</span>和透明度 ;</span><br><span class="line"><span class="bullet">-</span> <span class="code">`@font-face`</span>属性;</span><br><span class="line"><span class="bullet">-</span> 多背景图 ;</span><br><span class="line"><span class="bullet">-</span> 盒子大小;</span><br><span class="line"><span class="bullet">-</span> 语音;</span><br></pre></td></tr></table></figure>
<h1 id="86-用纯CSS创建一个三角形的原理是什么？"><a href="#86-用纯CSS创建一个三角形的原理是什么？" class="headerlink" title="86.用纯CSS创建一个三角形的原理是什么？"></a>86.用纯CSS创建一个三角形的原理是什么？</h1><p>实现步骤： 1.首先保证元素是块级元素；2.设置元素的边框；3.不需要显示的边框使用透明色。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">css: </span><br><span class="line">    * &#123;<span class="attribute">margin</span>: <span class="number">0</span>; <span class="attribute">padding</span>: <span class="number">0</span>;&#125;</span><br><span class="line">    <span class="selector-class">.content</span> &#123;</span><br><span class="line">        <span class="attribute">width</span>:<span class="number">0</span>;</span><br><span class="line">        <span class="attribute">height</span>:<span class="number">0</span>;</span><br><span class="line">        <span class="attribute">margin</span>:<span class="number">0</span> auto;</span><br><span class="line">        <span class="attribute">border</span>:<span class="number">50px</span> solid transparent;</span><br><span class="line">        <span class="attribute">border-top</span>: <span class="number">50px</span> solid pink;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">html</span>: </span><br><span class="line">    &lt;div class=<span class="string">&quot;content&quot;</span>&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<h1 id="87-什么是响应式设计？响应式设计的基本原理是什么？如何兼容低版本的IE？"><a href="#87-什么是响应式设计？响应式设计的基本原理是什么？如何兼容低版本的IE？" class="headerlink" title="87.什么是响应式设计？响应式设计的基本原理是什么？如何兼容低版本的IE？"></a>87.什么是响应式设计？响应式设计的基本原理是什么？如何兼容低版本的IE？</h1><p>响应式网站设计<code>（Responsive Web design</code>）是一个网站能够兼容多个终端，而不是为每一个终端做一个特定的版本。</p>
<p>关于原理： 基本原理是通过媒体查询<code>（@media）</code>查询检测不同的设备屏幕尺寸做处理。</p>
<p>关于兼容： 页面头部必须有mate声明的<code>viewport</code>。</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta <span class="attr">name</span>=<span class="string">&quot;’viewport’&quot;</span> content=<span class="string">&quot;”width=device-width,&quot;</span> initial-scale=<span class="string">&quot;1.&quot;</span> maximum-scale=<span class="string">&quot;1,user-scalable=no”&quot;</span>/&gt; </span><br></pre></td></tr></table></figure>
<h1 id="88-CSS优化、提高性能的方法有哪些？"><a href="#88-CSS优化、提高性能的方法有哪些？" class="headerlink" title="88.CSS优化、提高性能的方法有哪些？"></a>88.CSS优化、提高性能的方法有哪些？</h1><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> 多个<span class="code">`css`</span>可合并，并尽量减少<span class="code">`http`</span>请求</span><br><span class="line"><span class="bullet">-</span> 属性值为0时，不加单位</span><br><span class="line"><span class="bullet">-</span> 将<span class="code">`css`</span>文件放在页面最上面</span><br><span class="line"><span class="bullet">-</span> 避免后代选择符，过度约束和链式选择符</span><br><span class="line"><span class="bullet">-</span> 使用紧凑的语法</span><br><span class="line"><span class="bullet">-</span> 避免不必要的重复</span><br><span class="line"><span class="bullet">-</span> 使用语义化命名，便于维护</span><br><span class="line"><span class="bullet">-</span> 尽量少的使用<span class="code">`!impotrant`</span>，可以选择其他选择器</span><br><span class="line"><span class="bullet">-</span> 精简规则，尽可能合并不同类的重复规则</span><br><span class="line"><span class="bullet">-</span> 遵守盒子模型规则</span><br></pre></td></tr></table></figure>
<h1 id="89-display-inline-block-什么时候会显示间隙？"><a href="#89-display-inline-block-什么时候会显示间隙？" class="headerlink" title="89.display:inline-block 什么时候会显示间隙？"></a>89.display:inline-block 什么时候会显示间隙？</h1><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> 有空格时候会有间隙， 可以删除空格解决；</span><br><span class="line"><span class="bullet">-</span> <span class="code">`margin`</span>正值的时候， 可以让<span class="code">`margin`</span>使用负值解决；</span><br><span class="line"><span class="bullet">-</span> 使用<span class="code">`font-size`</span>时候，可通过设置<span class="code">`font-size:0`</span>、<span class="code">`letter-spacing`</span>、<span class="code">`word-spacing`</span>解决； </span><br></pre></td></tr></table></figure>
<h1 id="90-什么是外边距重叠？-重叠的结果是什么？"><a href="#90-什么是外边距重叠？-重叠的结果是什么？" class="headerlink" title="90. 什么是外边距重叠？ 重叠的结果是什么？"></a>90. 什么是外边距重叠？ 重叠的结果是什么？</h1><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">首先，外边距重叠就是 <span class="code">`margin-collapse`</span>。相邻的两个盒子（可能是兄弟关系也可能是祖先关系）的外边距可以结合成一个单独的外边距。 这种合并外边距的方式被称为折叠，结合而成的外边距称为折叠外边距。</span><br><span class="line"></span><br><span class="line">折叠结果遵循下列计算原则：</span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> 两个相邻的外面边距是正数时，折叠结果就是他们之中的较大值；</span><br><span class="line"><span class="bullet">-</span> 两个相邻的外边距都是负数时，折叠结果是两者绝对值的较大值；</span><br><span class="line"><span class="bullet">-</span> 两个外边距一正一负时，折叠结果是两者的相加的和；</span><br></pre></td></tr></table></figure>
<h1 id="91-有哪几种隐藏元素的方法？"><a href="#91-有哪几种隐藏元素的方法？" class="headerlink" title="91.有哪几种隐藏元素的方法？"></a>91.有哪几种隐藏元素的方法？</h1><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="code">`visibility: hidden;`</span> 这个属性只是简单的隐藏某个元素，但是元素占用的空间任然存在；</span><br><span class="line"><span class="bullet">-</span> <span class="code">`opacity: 0;`</span><span class="code">`CSS3`</span>属性，设置0可以使一个元素完全透明；</span><br><span class="line"><span class="bullet">-</span> <span class="code">`position: absolute;`</span> 设置一个很大的 left 负值定位，使元素定位在可见区域之外；</span><br><span class="line"><span class="bullet">-</span> <span class="code">`display: none;`</span> 元素会变得不可见，并且不会再占用文档的空间；</span><br><span class="line"><span class="bullet">-</span> <span class="code">`transform: scale(0);`</span> 将一个元素设置为缩放无限小，元素将不可见，元素原来所在的位置将被保留；</span><br><span class="line"><span class="bullet">-</span> <span class="code">`&lt;div hidden=&quot;hidden&quot;&gt;`</span> <span class="code">`HTML5`</span>属性,效果和<span class="code">`display:none;`</span>相同，但这个属性用于记录一个元素的状态；</span><br><span class="line"><span class="bullet">-</span> <span class="code">`height: 0;`</span> 将元素高度设为 0 ，并消除边框；</span><br><span class="line"><span class="bullet">-</span> <span class="code">`filter: blur(0);`</span> <span class="code">`CSS3`</span>属性，括号内的数值越大，图像高斯模糊的程度越大，到达一定程度可使图像消失`；</span><br></pre></td></tr></table></figure>
<h1 id="92-对BFC规范-块级格式化上下文：block-formatting-context-的理解"><a href="#92-对BFC规范-块级格式化上下文：block-formatting-context-的理解" class="headerlink" title="92.对BFC规范(块级格式化上下文：block formatting context)的理解"></a>92.对BFC规范(块级格式化上下文：block formatting context)的理解</h1><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="code">`BFC`</span>规定了内部的<span class="code">`Block Box`</span>如何布局。一个页面是由很多个<span class="code">`Box`</span>组成的，元素的类型和<span class="code">`display`</span>属性，决定了这个<span class="code">`Box`</span>的类型。不同类型的<span class="code">`box`</span>，会参与不同的<span class="code">`Formatting Context`</span>（决定如何渲染文档的容器），因此<span class="code">`Box`</span>内的元素会以不用的方式渲染，也是就是说<span class="code">`BFC`</span>内部的元素和外部的元素不会相互影响。</span><br><span class="line"></span><br><span class="line">定位方案：</span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> 内部的<span class="code">`box`</span>会在垂直方向上一个接一个的放置；</span><br><span class="line"><span class="bullet">-</span> <span class="code">`box`</span>垂直方向的距离由<span class="code">`margin`</span>决定，属于同一个<span class="code">`BFC`</span>的两个相邻<span class="code">`Box`</span>的<span class="code">`margin`</span>会发生重叠；</span><br><span class="line"><span class="bullet">-</span> 每个元素<span class="code">`margin box`</span>的左边，与包含块<span class="code">`border box`</span>的左边相接触；</span><br><span class="line"><span class="bullet">-</span> <span class="code">`BFC`</span>的区域不会与float box重叠；</span><br><span class="line"><span class="bullet">-</span> <span class="code">`BFC`</span>是页面上的一个隔离的独立容器，容器里面的元素不会影响到外面的元素；</span><br><span class="line"><span class="bullet">-</span> 计算<span class="code">`BFC`</span>的高度时，浮动元素也会参与计算。</span><br><span class="line"></span><br><span class="line">满足下列条件之一就可以出发BFC：</span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> 根元素变化，即<span class="code">`html`</span>；</span><br><span class="line"><span class="bullet">-</span> <span class="code">`float`</span>的值不为<span class="code">`none`</span>（默认）；</span><br><span class="line"><span class="bullet">-</span> <span class="code">`overflow`</span>的值不为<span class="code">`visible`</span>（默认）；</span><br><span class="line"><span class="bullet">-</span> <span class="code">`display`</span>的值为<span class="code">`inline-block`</span>, <span class="code">`tabke-cell`</span>，<span class="code">`table-caption`</span>；</span><br><span class="line"><span class="bullet">-</span> <span class="code">`position`</span>的值为<span class="code">`absolute`</span>或<span class="code">`fixed`</span>;</span><br></pre></td></tr></table></figure>
<h1 id="93-经常遇到的浏览器的兼容性有哪些？原因，解决方法是什么，常用hack的技巧-？"><a href="#93-经常遇到的浏览器的兼容性有哪些？原因，解决方法是什么，常用hack的技巧-？" class="headerlink" title="93.经常遇到的浏览器的兼容性有哪些？原因，解决方法是什么，常用hack的技巧 ？"></a>93.经常遇到的浏览器的兼容性有哪些？原因，解决方法是什么，常用hack的技巧 ？</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">（<span class="number">1</span>）、问题：<span class="string">`png24`</span>位的图片在<span class="string">`ie`</span>浏览器上出现背景。解决： 做成<span class="string">`png8`</span>；</span><br><span class="line"></span><br><span class="line">（<span class="number">2</span>）、问题：浏览器默认的<span class="string">`margin`</span>和<span class="string">`padding`</span>不同。 解决： 添加一个全局的<span class="string">`*&#123; margin： 0; padding： 0;&#125;`</span>；</span><br><span class="line"></span><br><span class="line">（<span class="number">3</span>）、问题：<span class="string">`IE`</span>下,可以使用获取常规属性的方法来获取自定义属性,也可以使用<span class="string">`getAttribute()`</span>获取自定义属性，而<span class="string">`Firefox`</span>下,只能使用<span class="string">`getAttribute()`</span>获取自定义属性。 解决： 统一通过<span class="string">`getAttribute()`</span>获取自定义属性；</span><br><span class="line"></span><br><span class="line">（<span class="number">4</span>）、问题： <span class="string">`IE`</span>下,<span class="string">`event`</span>对象有<span class="string">`x`</span>,<span class="string">`y`</span>属性,但是没有<span class="string">`pageX`</span>,<span class="string">`pageY`</span>属性，而<span class="string">`Firefox`</span>下,<span class="string">`event`</span>对象有<span class="string">`pageX`</span>,<span class="string">`pageY`</span>属性,但是没有<span class="string">`x`</span>,<span class="string">`y`</span>属性。 解决： 使用<span class="string">`mX(mX = event.x ? event.x : event.pageX;)`</span>来代替<span class="string">`IE`</span>下的<span class="string">`event.x`</span>或者<span class="string">`Firefox`</span>下的<span class="string">`event.pageX`</span>。</span><br></pre></td></tr></table></figure>
<h1 id="94-怎么让Chrome支持小于12px-的文字？"><a href="#94-怎么让Chrome支持小于12px-的文字？" class="headerlink" title="94. 怎么让Chrome支持小于12px 的文字？"></a>94. 怎么让Chrome支持小于12px 的文字？</h1><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.shrink</span> &#123;</span><br><span class="line">    -webkit-<span class="attribute">transform</span>: <span class="built_in">scale</span>(<span class="number">0.8</span>);</span><br><span class="line">    -o-<span class="attribute">transform</span>: <span class="built_in">scale</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="attribute">display</span>: inilne-block;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="95-link、-visited、-hover、-active的执行顺序是怎么样的？"><a href="#95-link、-visited、-hover、-active的执行顺序是怎么样的？" class="headerlink" title="95. :link、:visited、:hover、:active的执行顺序是怎么样的？"></a>95. :link、:visited、:hover、:active的执行顺序是怎么样的？</h1><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`L-V-H-<span class="selector-tag">A</span>`，`<span class="built_in">l</span>(link)<span class="built_in">ov</span>(visited)e <span class="built_in">h</span>(hover)<span class="selector-tag">a</span>(active)te`，即用喜欢和讨厌两个词来概括</span><br></pre></td></tr></table></figure>
<h1 id="96-CSS属性overflow属性定义溢出元素内容区的内容会如何处理"><a href="#96-CSS属性overflow属性定义溢出元素内容区的内容会如何处理" class="headerlink" title="96. CSS属性overflow属性定义溢出元素内容区的内容会如何处理?"></a>96. CSS属性overflow属性定义溢出元素内容区的内容会如何处理?</h1><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> 参数是<span class="code">`scroll`</span>的时候，一定会出滚动条；</span><br><span class="line"><span class="bullet">-</span> 参数是<span class="code">`auto`</span>的时候，子元素内容大于父元素时出现滚动条；</span><br><span class="line"><span class="bullet">-</span> 参数是<span class="code">`visible`</span>的时候，溢出的内容出现在父元素之外；</span><br><span class="line"><span class="bullet">-</span> 参数是<span class="code">`hidden`</span>的时候，溢出隐藏；</span><br></pre></td></tr></table></figure>
<h1 id="97-css样式引入方式的优缺点对比"><a href="#97-css样式引入方式的优缺点对比" class="headerlink" title="97. css样式引入方式的优缺点对比"></a>97. css样式引入方式的优缺点对比</h1><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">内嵌样式： 优点： 方便书写，权重高；缺点： 没有做到结构和样式分离；</span><br><span class="line">内联样式： 优点：结构样式相分离； 缺点：没有彻底分离；</span><br><span class="line">外联样式： 优点： 完全实现了结构和样式相分离； 缺点： 需要引入才能使用；</span><br></pre></td></tr></table></figure>
<h1 id="98-position-跟-display、overflow、float-这些特性相互叠加后会怎么样？"><a href="#98-position-跟-display、overflow、float-这些特性相互叠加后会怎么样？" class="headerlink" title="98. position 跟 display、overflow、float 这些特性相互叠加后会怎么样？"></a>98. position 跟 display、overflow、float 这些特性相互叠加后会怎么样？</h1><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="code">`display`</span>属性规定元素应该生成的框的类型；</span><br><span class="line"><span class="bullet">-</span> <span class="code">`position`</span>属性规定元素的定位类型；</span><br><span class="line"><span class="bullet">-</span> <span class="code">`float`</span>属性是一种布局方式，定义元素往哪个方向浮动；</span><br><span class="line"></span><br><span class="line"><span class="strong">**叠加结果**</span>：有点类似于优先机制。<span class="code">`position`</span>的值-- <span class="code">`absolute/fixed`</span>优先级最高，有他们在时，<span class="code">`float`</span>不起作用，<span class="code">`display`</span>值需要调整。<span class="code">`float`</span>或者<span class="code">`absolute`</span>定位的元素，只能是块元素或者表格。</span><br></pre></td></tr></table></figure>
<h1 id="99-什么是回流（重排）和重绘以及其区别？"><a href="#99-什么是回流（重排）和重绘以及其区别？" class="headerlink" title="99. 什么是回流（重排）和重绘以及其区别？"></a>99. 什么是回流（重排）和重绘以及其区别？</h1><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> 回流（重排），<span class="code">`reflow`</span>:当<span class="code">`render tree`</span>中的一部分（或全部）因为元素的规模尺寸，布局，隐藏等改变时而需要重新构建；</span><br><span class="line"><span class="bullet">-</span> 重绘<span class="code">`（repaint`</span>）:当<span class="code">`render tree`</span>中的一些元素需要更新属性，而这些属性只影响元素的外观，风格，而不会影响布局时，称其为<span class="strong">**重绘**</span>，例如颜色改变等。</span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> 增加或者删除可见的<span class="code">`dom`</span>元素；</span><br><span class="line"><span class="bullet">-</span> 元素的位置发生了改变；</span><br><span class="line"><span class="bullet">-</span> 元素的尺寸发生了改变，例如边距，宽高等几何属性改变；</span><br><span class="line"><span class="bullet">-</span> 内容改变，例如图片大小，字体大小改变等；</span><br><span class="line"><span class="bullet">-</span> 页面渲染初始化；</span><br><span class="line"><span class="bullet">-</span> 浏览器窗口尺寸改变，例如<span class="code">`resize`</span>事件发生时等；</span><br><span class="line"><span class="bullet">-</span> 重排（回流）一定会引发重绘<span class="strong">**。</span></span><br></pre></td></tr></table></figure>
<h1 id="100-说说-px、em、rem的区别及使用场景"><a href="#100-说说-px、em、rem的区别及使用场景" class="headerlink" title="100.说说 px、em、rem的区别及使用场景"></a>100.说说 px、em、rem的区别及使用场景</h1><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="strong">**三者的区别：**</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> px是固定的像素，一旦设置了就无法因为适应页面大小而改变。</span><br><span class="line"><span class="bullet">-</span> em和rem相对于px更具有灵活性，他们是相对长度单位，其长度不是固定的，更适用于响应式布局。</span><br><span class="line"><span class="bullet">-</span> em是相对于其父元素来设置字体大小，这样就会存在一个问题，进行任何元素设置，都有可能需要知道他父元素的大小。而rem是相对于根元素，这样就意味着，只需要在根元素确定一个参考值。</span><br><span class="line"></span><br><span class="line"><span class="strong">**使用场景：**</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> 对于只需要适配少部分移动设备，且分辨率对页面影响不大的，使用px即可 。</span><br><span class="line"><span class="bullet">-</span> 对于需要适配各种移动设备，使用rem，例如需要适配iPhone和iPad等分辨率差别比较挺大的设备</span><br></pre></td></tr></table></figure></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://admin741-cl.github.io">admin741</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://admin741-cl.github.io/posts/99be.html">https://admin741-cl.github.io/posts/99be.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://admin741-cl.github.io" target="_blank">孔乙己的长衫</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/blog-construct/banner.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><button class="tip-button reward-button"><span class="tip-button__text">不给糖果就捣蛋</span><div class="coin-wrapper"><div class="coin"><div class="coin__middle"></div><div class="coin__back"></div><div class="coin__front"></div></div></div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div></button></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/923a.html" title="json-server文档"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://w.wallhaven.cc/full/ex/wallhaven-ex9gwo.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">json-server文档</div></div></a></div><div class="next-post pull-right"><a href="/posts/f0ec.html" title="vue3笔记（更新中）"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://w.wallhaven.cc/full/ex/wallhaven-exe1xo.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">vue3笔记（更新中）</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="avatar"/></div><div class="author-info__name">admin741</div><div class="author-info__description">学历不仅是敲门砖 也是我下不来的高台 更是孔乙己脱不下的长衫</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">7</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">2</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">还没有公告哦，耐心等等吧</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-Vue3-0%E6%80%A7%E8%83%BD%E6%8F%90%E5%8D%87%E4%B8%BB%E8%A6%81%E6%98%AF%E4%BD%93%E7%8E%B0%E5%9C%A8%E5%93%AA%E4%BA%9B%E6%96%B9%E9%9D%A2"><span class="toc-text">1.Vue3.0性能提升主要是体现在哪些方面</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%93%8D%E5%BA%94%E5%BC%8F%E7%B3%BB%E7%BB%9F"><span class="toc-text">1.响应式系统</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E7%BC%96%E8%AF%91%E9%98%B6%E6%AE%B5"><span class="toc-text">2.编译阶段</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E6%BA%90%E7%A0%81%E4%BD%93%E7%A7%AF"><span class="toc-text">3.源码体积</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-vue3%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B0%E7%9A%84%E7%BB%84%E4%BB%B6"><span class="toc-text">2.vue3有哪些新的组件</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-Fragment"><span class="toc-text">1.Fragment</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-Teleport"><span class="toc-text">2.Teleport</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-Suspense"><span class="toc-text">3.Suspense</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-Vue2-0-%E5%92%8C-Vue3-0-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-text">3.Vue2.0 和 Vue3.0 有什么区别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-Vue-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-text">4.Vue 生命周期</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-vue2-x%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-text">1.vue2.x的生命周期</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-vue3-0%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-text">2.vue3.0的生命周期</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-%E9%83%BD%E8%AF%B4-Composition-API-%E5%92%8C-React-Hook-%E5%BE%88%E5%83%8F%EF%BC%8C%E8%AF%B7%E9%97%AE%E4%BB%96%E4%BB%AC%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">5.都说 Composition API 和 React Hook 很像，请问他们的区别是什么</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6-Composition-Api-%E4%B8%8EOptions-Api-%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C"><span class="toc-text">6. Composition Api 与Options Api 有什么不同</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-Options-Api"><span class="toc-text">1.Options Api</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-Composition-Api"><span class="toc-text">2.Composition Api</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%AF%B9%E6%AF%94"><span class="toc-text">3.对比</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E7%BB%84%E7%BB%87"><span class="toc-text">逻辑组织</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Options-API"><span class="toc-text">Options API</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Compostion-API"><span class="toc-text">Compostion API</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E5%A4%8D%E7%94%A8"><span class="toc-text">逻辑复用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7-%E4%BB%80%E4%B9%88%E6%98%AFSPA%E5%8D%95%E9%A1%B5%E9%9D%A2%E5%BA%94%E7%94%A8%EF%BC%8C%E9%A6%96%E5%B1%8F%E5%8A%A0%E8%BD%BD%E4%BD%A0%E6%98%AF%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96%E7%9A%84"><span class="toc-text">7.什么是SPA单页面应用，首屏加载你是如何优化的</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8-%E5%AF%B9Vue%E9%A1%B9%E7%9B%AE%E4%BD%A0%E5%81%9A%E8%BF%87%E5%93%AA%E4%BA%9B%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96"><span class="toc-text">8.对Vue项目你做过哪些性能优化</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#9-Vue%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-text">9.Vue组件通信的方式有哪些</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#10-Vue%E5%B8%B8%E7%94%A8%E7%9A%84%E4%BF%AE%E9%A5%B0%E7%AC%A6%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-text">10.Vue常用的修饰符有哪些</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#11-Vue%E4%B8%AD%E7%9A%84-nextTick%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8"><span class="toc-text">11.Vue中的$nextTick有什么作用</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#12-%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A"><span class="toc-text">12.如何理解双向数据绑定</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#13-v-show%E5%92%8Cv-if%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F%E4%BD%A0%E5%8F%AF%E4%BB%A5%E8%AE%B2%E8%AE%B2%E5%90%97"><span class="toc-text">13.v-show和v-if有什么区别？你可以讲讲吗</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#14-%E6%9C%89%E7%94%A8%E8%BF%87keep-alive%E5%90%97%EF%BC%9F%E5%AE%83%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8"><span class="toc-text">14.有用过keep-alive吗？它有什么作用</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#15-%E4%BD%A0%E5%8F%AF%E4%BB%A5%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E8%99%9A%E6%8B%9FDOM%E5%90%97"><span class="toc-text">15.你可以实现一个虚拟DOM吗</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E8%99%9A%E6%8B%9FDOM"><span class="toc-text">如何实现虚拟DOM</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-1"><span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#16-%E4%B8%BA%E4%BB%80%E4%B9%88data%E5%B1%9E%E6%80%A7%E6%98%AF%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0%E8%80%8C%E4%B8%8D%E6%98%AF%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%EF%BC%8C%E5%85%B7%E4%BD%93%E5%8E%9F%E5%9B%A0%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">16.为什么data属性是一个函数而不是一个对象，具体原因是什么</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#17-Vue2%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E8%BF%87%E7%A8%8B%E4%BD%A0%E6%9C%89%E8%BF%87%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%8C%E5%81%9A%E4%BA%86%E5%93%AA%E4%BA%9B%E4%BA%8B%E6%83%85"><span class="toc-text">17.Vue2的初始化过程你有过了解吗，做了哪些事情</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#18-Vue3%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9A%84%E4%B8%80%E4%B8%AA%E5%A4%A7%E6%A6%82%E6%B5%81%E7%A8%8B"><span class="toc-text">18.Vue3初始化的一个大概流程</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#19-vue3%E5%93%8D%E5%BA%94%E5%BC%8Fapi%E5%A6%82%E4%BD%95%E7%BC%96%E5%86%99"><span class="toc-text">19.vue3响应式api如何编写</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#20-%E5%9C%A8Vue%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%BD%A0%E6%98%AF%E5%A6%82%E4%BD%95%E5%81%9A%E7%9A%84SSR%E6%B8%B2%E6%9F%93"><span class="toc-text">20.在Vue项目中你是如何做的SSR渲染</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#21-%E6%80%8E%E4%B9%88%E7%9C%8BVue%E7%9A%84diff%E7%AE%97%E6%B3%95"><span class="toc-text">21.怎么看Vue的diff算法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#22-%E4%BB%8E0%E5%88%B01%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AAVue%E9%A1%B9%E7%9B%AE%E4%BD%A0%E9%9C%80%E8%A6%81%E5%81%9A%E5%93%AA%E4%BA%9B%E5%86%85%E5%AE%B9"><span class="toc-text">22.从0到1构建一个Vue项目你需要做哪些内容</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#23-%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B-js-%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%8C%E5%80%BC%E6%98%AF%E5%A6%82%E4%BD%95%E5%AD%98%E5%82%A8%E7%9A%84"><span class="toc-text">23. 介绍一下 js 的数据类型有哪些，值是如何存储的</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#24-JS-%E4%B8%ADObject-prototype-toString-call-%E5%88%A4%E6%96%AD%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-text">24. JS 中Object.prototype.toString.call()判断数据类型</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#25-null-%E5%92%8C-undefined-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">25. null 和 undefined 的区别？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#26-%E5%92%8C-%E7%9A%84-valueOf-%E5%92%8C-toString-%E7%9A%84%E7%BB%93%E6%9E%9C%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">26. {}和 [] 的 valueOf 和 toString 的结果是什么？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#27-Javascript-%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE"><span class="toc-text">27. Javascript 的作用域和作用域链</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#28-%E8%B0%88%E8%B0%88%E4%BD%A0%E5%AF%B9-this%E3%80%81call%E3%80%81apply-%E5%92%8C-bind-%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-text">28. 谈谈你对 this、call、apply 和 bind 的理解</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#29-JavaScript-%E5%8E%9F%E5%9E%8B%EF%BC%8C%E5%8E%9F%E5%9E%8B%E9%93%BE%EF%BC%9F-%E6%9C%89%E4%BB%80%E4%B9%88%E7%89%B9%E7%82%B9%EF%BC%9F"><span class="toc-text">29. JavaScript 原型，原型链？ 有什么特点？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#30-%E4%BB%80%E4%B9%88%E6%98%AF%E9%97%AD%E5%8C%85%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8%E5%AE%83%EF%BC%9F"><span class="toc-text">30. 什么是闭包，为什么要用它？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#31-%E4%B8%89%E7%A7%8D%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">31. 三种事件模型是什么？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#32-js-%E6%95%B0%E7%BB%84%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9C%89%E5%93%AA%E4%BA%9B%E5%8E%9F%E7%94%9F%E6%96%B9%E6%B3%95-%E5%88%97%E4%B8%BE%E4%B8%80%E4%B8%8B"><span class="toc-text">32. js 数组和字符串有哪些原生方法, 列举一下</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#33-js-%E5%BB%B6%E8%BF%9F%E5%8A%A0%E8%BD%BD%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-text">33. js 延迟加载的方式有哪些</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#34-js-%E7%9A%84%E5%87%A0%E7%A7%8D%E6%A8%A1%E5%9D%97%E8%A7%84%E8%8C%83%EF%BC%9F"><span class="toc-text">34. js 的几种模块规范？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#35-AMD-%E5%92%8C-CMD-%E8%A7%84%E8%8C%83%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">35. AMD 和 CMD 规范的区别？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#36-ES6-%E6%A8%A1%E5%9D%97%E4%B8%8E-CommonJS-%E6%A8%A1%E5%9D%97%E3%80%81AMD%E3%80%81CMD-%E7%9A%84%E5%B7%AE%E5%BC%82%E3%80%82"><span class="toc-text">36. ES6 模块与 CommonJS 模块、AMD、CMD 的差异。</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#37-JS-%E7%9A%84%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6"><span class="toc-text">37. JS 的运行机制</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#38-%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B-V8-%E5%BC%95%E6%93%8E%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6"><span class="toc-text">38. 简单介绍一下 V8 引擎的垃圾回收机制</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#39-%E5%93%AA%E4%BA%9B%E6%93%8D%E4%BD%9C%E4%BC%9A%E9%80%A0%E6%88%90%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%EF%BC%9F"><span class="toc-text">39. 哪些操作会造成内存泄漏？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#40-ES6%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%9F"><span class="toc-text">40.ES6有哪些新特性？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#41-%E4%BB%80%E4%B9%88%E6%98%AF%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%EF%BC%9F"><span class="toc-text">41. 什么是箭头函数？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#42-%E4%BB%80%E4%B9%88%E6%98%AF%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0%EF%BC%9F"><span class="toc-text">42. 什么是高阶函数？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#43-%E6%89%8B%E5%86%99-call%E3%80%81apply-%E5%8F%8A-bind-%E5%87%BD%E6%95%B0"><span class="toc-text">43. 手写 call、apply 及 bind 函数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%AE%9E%E7%8E%B0call%E5%87%BD%E6%95%B0"><span class="toc-text">1.实现call函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%AE%9E%E7%8E%B0apply%E5%87%BD%E6%95%B0"><span class="toc-text">2.实现apply函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%AE%9E%E7%8E%B0bind%E5%87%BD%E6%95%B0"><span class="toc-text">3.实现bind函数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#44-%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-text">44. 函数柯里化的实现</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#45-%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA-new-%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-text">45. 实现一个 new 操作符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#46-%E5%8F%AF%E4%BB%A5%E8%AE%B2%E8%AE%B2Promise%E5%90%97%EF%BC%8C%E5%8F%AF%E4%BB%A5%E6%89%8B%E5%86%99%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%8B%E5%90%97%EF%BC%9F"><span class="toc-text">46. 可以讲讲Promise吗，可以手写实现一下吗？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#47-%E4%BB%80%E4%B9%88%E6%98%AF-async-await-%E5%8F%8A%E5%85%B6%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C-%E5%8F%AF%E4%BB%A5%E6%89%8B%E5%86%99async%E5%90%97"><span class="toc-text">47. 什么是 async&#x2F;await 及其如何工作, 可以手写async吗</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#48-instanceof-%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0"><span class="toc-text">48. instanceof 的优缺点是什么，如何实现</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#49-js-%E7%9A%84%E8%8A%82%E6%B5%81%E4%B8%8E%E9%98%B2%E6%8A%96"><span class="toc-text">49. js 的节流与防抖</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E9%98%B2%E6%8A%96"><span class="toc-text">1.防抖</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E8%8A%82%E6%B5%81"><span class="toc-text">2.节流</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#50-HTML%E3%80%81XML%E3%80%81XHTML-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">50.HTML、XML、XHTML 的区别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#51-HTML%E3%80%81XHTML%E5%92%8CHTML5%E5%8C%BA%E5%88%AB%E4%BB%A5%E5%8F%8A%E6%9C%89%E4%BB%80%E4%B9%88%E8%81%94%E7%B3%BB"><span class="toc-text">51. HTML、XHTML和HTML5区别以及有什么联系</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#52-%E8%A1%8C%E5%86%85%E5%85%83%E7%B4%A0%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%E5%9D%97%E7%BA%A7%E5%85%83%E7%B4%A0%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F-%E7%A9%BA-void-%E5%85%83%E7%B4%A0%E6%9C%89%E9%82%A3%E4%BA%9B%EF%BC%9F"><span class="toc-text">52.行内元素有哪些？块级元素有哪些？ 空(void)元素有那些？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#53-%E9%A1%B5%E9%9D%A2%E5%AF%BC%E5%85%A5%E6%A0%B7%E5%BC%8F%E6%97%B6%EF%BC%8C%E4%BD%BF%E7%94%A8link%E5%92%8C-import%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-text">53. 页面导入样式时，使用link和@import有什么区别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#54-%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E8%AF%AD%E4%B9%89%E5%8C%96%E6%A0%87%E7%AD%BE"><span class="toc-text">54. 如何理解语义化标签</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#55-property%E5%92%8Cattribute%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">55. property和attribute的区别是什么</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#56-html5%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B0%E7%89%B9%E6%80%A7%E3%80%81%E7%A7%BB%E9%99%A4%E4%BA%86%E9%82%A3%E4%BA%9B%E5%85%83%E7%B4%A0"><span class="toc-text">56. html5有哪些新特性、移除了那些元素</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#57-%E4%BB%80%E4%B9%88%E6%98%AF%E5%89%8D%E7%AB%AF%E7%9A%84%E7%BB%93%E6%9E%84%EF%BC%8C%E6%A0%B7%E5%BC%8F%E5%92%8C%E8%A1%8C%E4%B8%BA%E7%9B%B8%E5%88%86%E7%A6%BB%EF%BC%9F%E4%BB%A5%E5%8F%8A%E5%88%86%E7%A6%BB%E7%9A%84%E5%A5%BD%E5%A4%84%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">57. 什么是前端的结构，样式和行为相分离？以及分离的好处是什么？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#58-%E5%A6%82%E4%BD%95%E5%AF%B9%E7%BD%91%E7%AB%99%E7%9A%84%E6%96%87%E4%BB%B6%E5%92%8C%E8%B5%84%E6%BA%90%E8%BF%9B%E8%A1%8C%E4%BC%98%E5%8C%96"><span class="toc-text">58. 如何对网站的文件和资源进行优化</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#59-Html5%E4%B8%AD%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8%E6%A6%82%E5%BF%B5%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C%E6%9C%89%E4%BB%80%E4%B9%88%E4%BC%98%E7%82%B9%EF%BC%8C%E4%B8%8Ecookie%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">59. Html5中本地存储概念是什么，有什么优点，与cookie有什么区别？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#60-%E5%B8%B8%E8%A7%81%E7%9A%84%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%85%E6%A0%B8%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-text">60. 常见的浏览器内核有哪些</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#61-LocalStorage%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8%E5%9C%A8HTML5%E4%B8%AD%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8%E9%80%94"><span class="toc-text">61. LocalStorage本地存储在HTML5中有什么用途</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#62-%E4%B8%BA%E4%BB%80%E4%B9%88%E5%88%A9%E7%94%A8%E5%A4%9A%E4%B8%AA%E5%9F%9F%E5%90%8D%E6%9D%A5%E5%AD%98%E5%82%A8%E7%BD%91%E7%AB%99%E8%B5%84%E6%BA%90%E4%BC%9A%E6%9B%B4%E6%9C%89%E6%95%88"><span class="toc-text">62. 为什么利用多个域名来存储网站资源会更有效</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#63-HTML%E4%B8%AD%E5%87%A0%E7%A7%8D%E5%9B%BE%E7%89%87%E6%A0%BC%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB%E4%BB%A5%E5%8F%8A%E4%BD%BF%E7%94%A8"><span class="toc-text">63. HTML中几种图片格式的区别以及使用</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#64-DNS%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">64.DNS是什么</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#65-%E4%BB%80%E4%B9%88%E6%98%AF%E5%BC%BA%E7%BC%93%E5%AD%98"><span class="toc-text">65.什么是强缓存</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#66-%E4%BB%80%E4%B9%88%E6%98%AF%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98"><span class="toc-text">66.什么是协商缓存</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#67-%E6%89%93%E5%BC%80-Chrome-%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%80%E4%B8%AA-Tab-%E9%A1%B5%E9%9D%A2%EF%BC%8C%E8%87%B3%E5%B0%91%E4%BC%9A%E5%87%BA%E7%8E%B0%E5%87%A0%E4%B8%AA%E8%BF%9B%E7%A8%8B%EF%BC%9F"><span class="toc-text">67.打开 Chrome 浏览器一个 Tab 页面，至少会出现几个进程？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#68-%E5%8D%B3%E4%BD%BF%E5%A6%82%E4%BB%8A%E5%A4%9A%E8%BF%9B%E7%A8%8B%E6%9E%B6%E6%9E%84%EF%BC%8C%E8%BF%98%E6%98%AF%E4%BC%9A%E7%A2%B0%E5%88%B0%E5%8D%95%E9%A1%B5%E9%9D%A2%E5%8D%A1%E6%AD%BB%E7%9A%84%E6%9C%80%E7%BB%88%E5%B4%A9%E6%BA%83%E5%AF%BC%E8%87%B4%E6%89%80%E6%9C%89%E9%A1%B5%E9%9D%A2%E5%B4%A9%E6%BA%83%E7%9A%84%E6%83%85%E5%86%B5%EF%BC%8C%E8%AE%B2%E4%B8%80%E8%AE%B2%E4%BD%A0%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F"><span class="toc-text">68.即使如今多进程架构，还是会碰到单页面卡死的最终崩溃导致所有页面崩溃的情况，讲一讲你的理解？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#69-TCP-%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5%E8%BF%87%E7%A8%8B%E8%AE%B2%E4%B8%80%E8%AE%B2%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E6%8F%A1%E6%89%8B%E9%9C%80%E8%A6%81%E4%B8%89%E6%AC%A1%EF%BC%9F"><span class="toc-text">69.TCP 建立连接过程讲一讲，为什么握手需要三次？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#70-%E4%BB%8E%E8%BE%93%E5%85%A5-URL-%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%B1%95%E7%A4%BA%EF%BC%8C%E8%BF%99%E4%B8%AD%E9%97%B4%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88"><span class="toc-text">70.从输入 URL 到页面展示，这中间发生了什么</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#71-%E4%BB%80%E4%B9%88%E6%98%AF-CDN"><span class="toc-text">71.什么是 CDN</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#72-%E8%AF%B4%E8%AF%B4HTTP%E4%B8%8EHTTPS%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">72. 说说HTTP与HTTPS的区别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#73-webpack%E6%96%87%E4%BB%B6%E6%8C%87%E7%BA%B9%E7%AD%96%E7%95%A5%EF%BC%9Ahash-chunkhash-contenthash"><span class="toc-text">73.webpack文件指纹策略：hash chunkhash contenthash</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#74-%E8%AF%B4%E8%AF%B4webpack%E7%9A%84%E6%9E%84%E5%BB%BA%E6%B5%81%E7%A8%8B"><span class="toc-text">74.说说webpack的构建流程</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#75-%E8%AF%B4%E8%AF%B4Loader%E5%92%8CPlugin%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F%E7%BC%96%E5%86%99Loader%EF%BC%8CPlugin%E7%9A%84%E6%80%9D%E8%B7%AF"><span class="toc-text">75.说说Loader和Plugin的区别？编写Loader，Plugin的思路</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E5%8C%BA%E5%88%AB"><span class="toc-text">一、区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E7%BC%96%E5%86%99loader"><span class="toc-text">二、编写loader</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E7%BC%96%E5%86%99plugin"><span class="toc-text">三、编写plugin</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#76-%E6%8F%90%E9%AB%98webpack%E7%9A%84%E6%9E%84%E5%BB%BA%E9%80%9F%E5%BA%A6"><span class="toc-text">76.提高webpack的构建速度</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#77-webpack-%E7%83%AD%E6%9B%B4%E6%96%B0%E6%98%AF%E6%80%8E%E4%B9%88%E5%81%9A%E5%88%B0%E7%9A%84"><span class="toc-text">77.webpack 热更新是怎么做到的</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#78-webpack%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84Loader"><span class="toc-text">78.webpack中常见的Loader</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#79-webpack%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84Plugin"><span class="toc-text">79.webpack中常见的Plugin</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#80-Git%E5%B8%B8%E7%94%A8%E7%9A%84%E5%91%BD%E4%BB%A4%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-text">80.Git常用的命令有哪些</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#81-%E6%A0%87%E5%87%86%E7%9A%84CSS%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B%E5%8F%8A%E5%85%B6%E5%92%8C%E4%BD%8E%E7%89%88%E6%9C%AC%E7%9A%84IE%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">81.标准的CSS盒子模型及其和低版本的IE盒子模型的区别？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#82-%E5%87%A0%E7%A7%8D%E8%A7%A3%E5%86%B3IE6%E5%AD%98%E5%9C%A8%E7%9A%84bug%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-text">82.几种解决IE6存在的bug的方法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#83-CSS%E9%80%89%E6%8B%A9%E7%AC%A6%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%E5%93%AA%E4%BA%9B%E5%B1%9E%E6%80%A7%E5%8F%AF%E4%BB%A5%E7%BB%A7%E6%89%BF%EF%BC%9F"><span class="toc-text">83.CSS选择符有哪些？哪些属性可以继承？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#84-position%E7%9A%84%E5%80%BCrelative%E5%92%8Cabsolute%E5%AE%9A%E4%BD%8D%E5%8E%9F%E7%82%B9%EF%BC%9F"><span class="toc-text">84.position的值relative和absolute定位原点？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#85-CSS3%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%9F"><span class="toc-text">85.CSS3有哪些新特性？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#86-%E7%94%A8%E7%BA%AFCSS%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E4%B8%89%E8%A7%92%E5%BD%A2%E7%9A%84%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">86.用纯CSS创建一个三角形的原理是什么？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#87-%E4%BB%80%E4%B9%88%E6%98%AF%E5%93%8D%E5%BA%94%E5%BC%8F%E8%AE%BE%E8%AE%A1%EF%BC%9F%E5%93%8D%E5%BA%94%E5%BC%8F%E8%AE%BE%E8%AE%A1%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E5%A6%82%E4%BD%95%E5%85%BC%E5%AE%B9%E4%BD%8E%E7%89%88%E6%9C%AC%E7%9A%84IE%EF%BC%9F"><span class="toc-text">87.什么是响应式设计？响应式设计的基本原理是什么？如何兼容低版本的IE？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#88-CSS%E4%BC%98%E5%8C%96%E3%80%81%E6%8F%90%E9%AB%98%E6%80%A7%E8%83%BD%E7%9A%84%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-text">88.CSS优化、提高性能的方法有哪些？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#89-display-inline-block-%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BC%9A%E6%98%BE%E7%A4%BA%E9%97%B4%E9%9A%99%EF%BC%9F"><span class="toc-text">89.display:inline-block 什么时候会显示间隙？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#90-%E4%BB%80%E4%B9%88%E6%98%AF%E5%A4%96%E8%BE%B9%E8%B7%9D%E9%87%8D%E5%8F%A0%EF%BC%9F-%E9%87%8D%E5%8F%A0%E7%9A%84%E7%BB%93%E6%9E%9C%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">90. 什么是外边距重叠？ 重叠的结果是什么？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#91-%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E9%9A%90%E8%97%8F%E5%85%83%E7%B4%A0%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="toc-text">91.有哪几种隐藏元素的方法？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#92-%E5%AF%B9BFC%E8%A7%84%E8%8C%83-%E5%9D%97%E7%BA%A7%E6%A0%BC%E5%BC%8F%E5%8C%96%E4%B8%8A%E4%B8%8B%E6%96%87%EF%BC%9Ablock-formatting-context-%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-text">92.对BFC规范(块级格式化上下文：block formatting context)的理解</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#93-%E7%BB%8F%E5%B8%B8%E9%81%87%E5%88%B0%E7%9A%84%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%85%BC%E5%AE%B9%E6%80%A7%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%E5%8E%9F%E5%9B%A0%EF%BC%8C%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C%E5%B8%B8%E7%94%A8hack%E7%9A%84%E6%8A%80%E5%B7%A7-%EF%BC%9F"><span class="toc-text">93.经常遇到的浏览器的兼容性有哪些？原因，解决方法是什么，常用hack的技巧 ？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#94-%E6%80%8E%E4%B9%88%E8%AE%A9Chrome%E6%94%AF%E6%8C%81%E5%B0%8F%E4%BA%8E12px-%E7%9A%84%E6%96%87%E5%AD%97%EF%BC%9F"><span class="toc-text">94. 怎么让Chrome支持小于12px 的文字？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#95-link%E3%80%81-visited%E3%80%81-hover%E3%80%81-active%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%E6%98%AF%E6%80%8E%E4%B9%88%E6%A0%B7%E7%9A%84%EF%BC%9F"><span class="toc-text">95. :link、:visited、:hover、:active的执行顺序是怎么样的？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#96-CSS%E5%B1%9E%E6%80%A7overflow%E5%B1%9E%E6%80%A7%E5%AE%9A%E4%B9%89%E6%BA%A2%E5%87%BA%E5%85%83%E7%B4%A0%E5%86%85%E5%AE%B9%E5%8C%BA%E7%9A%84%E5%86%85%E5%AE%B9%E4%BC%9A%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86"><span class="toc-text">96. CSS属性overflow属性定义溢出元素内容区的内容会如何处理?</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#97-css%E6%A0%B7%E5%BC%8F%E5%BC%95%E5%85%A5%E6%96%B9%E5%BC%8F%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9%E5%AF%B9%E6%AF%94"><span class="toc-text">97. css样式引入方式的优缺点对比</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#98-position-%E8%B7%9F-display%E3%80%81overflow%E3%80%81float-%E8%BF%99%E4%BA%9B%E7%89%B9%E6%80%A7%E7%9B%B8%E4%BA%92%E5%8F%A0%E5%8A%A0%E5%90%8E%E4%BC%9A%E6%80%8E%E4%B9%88%E6%A0%B7%EF%BC%9F"><span class="toc-text">98. position 跟 display、overflow、float 这些特性相互叠加后会怎么样？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#99-%E4%BB%80%E4%B9%88%E6%98%AF%E5%9B%9E%E6%B5%81%EF%BC%88%E9%87%8D%E6%8E%92%EF%BC%89%E5%92%8C%E9%87%8D%E7%BB%98%E4%BB%A5%E5%8F%8A%E5%85%B6%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">99. 什么是回流（重排）和重绘以及其区别？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#100-%E8%AF%B4%E8%AF%B4-px%E3%80%81em%E3%80%81rem%E7%9A%84%E5%8C%BA%E5%88%AB%E5%8F%8A%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">100.说说 px、em、rem的区别及使用场景</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/3eeb.html" title="Hello World">Hello World</a><time datetime="2023-04-14T13:20:30.813Z" title="发表于 2023-04-14 21:20:30">2023-04-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/cdc4.html" title="canvas学习"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://w.wallhaven.cc/full/85/wallhaven-85dgxj.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="canvas学习"/></a><div class="content"><a class="title" href="/posts/cdc4.html" title="canvas学习">canvas学习</a><time datetime="2023-01-08T10:59:41.000Z" title="发表于 2023-01-08 18:59:41">2023-01-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/d238.html" title="源码笔记（更新中）"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://w.wallhaven.cc/full/p9/wallhaven-p9jdw3.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="源码笔记（更新中）"/></a><div class="content"><a class="title" href="/posts/d238.html" title="源码笔记（更新中）">源码笔记（更新中）</a><time datetime="2023-01-08T10:59:41.000Z" title="发表于 2023-01-08 18:59:41">2023-01-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/ae65.html" title="为你的夏日带去清凉!"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://w.wallhaven.cc/full/we/wallhaven-wel1wq.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="为你的夏日带去清凉!"/></a><div class="content"><a class="title" href="/posts/ae65.html" title="为你的夏日带去清凉!">为你的夏日带去清凉!</a><time datetime="2022-10-20T14:06:17.000Z" title="发表于 2022-10-20 22:06:17">2022-10-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/923a.html" title="json-server文档"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://w.wallhaven.cc/full/ex/wallhaven-ex9gwo.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="json-server文档"/></a><div class="content"><a class="title" href="/posts/923a.html" title="json-server文档">json-server文档</a><time datetime="2022-09-19T10:47:45.000Z" title="发表于 2022-09-19 18:47:45">2022-09-19</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By admin741</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><div class="loading-img"></div><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',()=> { preloader.endLoading() })

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><div class="js-pjax"></div><div class="aplayer no-destroy" data-id="7308383325" data-server="tencent" data-type="playlist"   data-order="list" data-fixed="true" data-preload="auto" data-autoplay="false" data-mutex="true" ></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><div class="app-refresh" id="app-refresh" style="position: fixed;top: -2.2rem;left: 0;right: 0;z-index: 99999;padding: 0 1rem;font-size: 15px;height: 2.2rem;transition: all 0.3s ease;"><div class="app-refresh-wrap" style=" display: flex;color: #fff;height: 100%;align-items: center;justify-content: center;"><label>✨ 有新文章啦！ 👉</label><a href="javascript:void(0)" onclick="location.reload()"><span style="color: #fff;text-decoration: underline;cursor: pointer;">🍗点击食用🍔</span></a></div></div><script>if ('serviceWorker' in navigator) {
if (navigator.serviceWorker.controller) {
navigator.serviceWorker.addEventListener('controllerchange', function() {
showNotification()
})
}
window.addEventListener('load', function() {
navigator.serviceWorker.register('/sw.js')
})
}
function showNotification() {
if (GLOBAL_CONFIG.Snackbar) {
var snackbarBg =
document.documentElement.getAttribute('data-theme') === 'light' ?
GLOBAL_CONFIG.Snackbar.bgLight :
GLOBAL_CONFIG.Snackbar.bgDark
var snackbarPos = GLOBAL_CONFIG.Snackbar.position
Snackbar.show({
text: '✨ 有新文章啦！ 👉',
backgroundColor: snackbarBg,
duration: 500000,
pos: snackbarPos,
actionText: '🍗点击食用🍔',
actionTextColor: '#fff',
onActionClick: function(e) {
location.reload()
},
})
} else {
var showBg =
document.documentElement.getAttribute('data-theme') === 'light' ?
'#3b70fc' :
'#1f1f1f'
var cssText = `top: 0; background: ${showBg};`
document.getElementById('app-refresh').style.cssText = cssText
}
}</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div><!-- hexo injector body_end start --><script data-pjax>
    function butterfly_categories_card_injector_config(){
      var parent_div_git = document.getElementById('99be');
      var item_html = '<style>li.categoryBar-list-item{width:32.3%;}.categoryBar-list{max-height: 190px;overflow:auto;}.categoryBar-list::-webkit-scrollbar{width:0!important}@media screen and (max-width: 650px){.categoryBar-list{max-height: 160px;}}</style><div class="recent-post-item" style="height:auto;width:100%;padding:0px;"><div id="categoryBar"><ul class="categoryBar-list"></ul></div></div>';
      console.log('已挂载butterfly_categories_card')
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
      }
    if( document.getElementById('99be') && (location.pathname ==='/'|| '/' ==='all')){
    butterfly_categories_card_injector_config()
    }
  </script><script data-pjax>
  function butterfly_clock_anzhiyu_injector_config(){
    var parent_div_git = document.getElementsByClassName('sticky_layout')[0];
    var item_html = '<div class="card-widget card-clock"><div class="card-glass"><div class="card-background"><div class="card-content"><div id="hexo_electric_clock"><img class="entered loading" id="card-clock-loading" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/loading.gif" style="height: 120px; width: 100%;" data-ll-status="loading"/></div></div></div></div></div>';
    console.log('已挂载butterfly_clock_anzhiyu')
    if(parent_div_git) {
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  }
  var elist = 'null'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var qweather_key = 'b16a1fa0e63c46a4b8f28abfb06ae3fe';
  var gaud_map_key = 'e2b04289e870b005374ee030148d64fd&s=rsv3';
  var baidu_ak_key = 'undefined';
  var flag = 0;
  var clock_rectangle = '112.982279,28.19409';
  var clock_default_rectangle_enable = 'false';

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_clock_anzhiyu_injector_config();
  }
  else if (epage === cpage){
    butterfly_clock_anzhiyu_injector_config();
  }
  </script><script src="https://widget.qweather.net/simple/static/js/he-simple-common.js?v=2.0"></script><script data-pjax src="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/clock.min.js"></script><script data-pjax>
  function butterfly_footer_beautify_injector_config(){
    var parent_div_git = document.getElementById('footer-wrap');
    var item_html = '<div id="workboard"></div><p id="ghbdages"><a class="github-badge" target="_blank" href="https://hexo.io/" style="margin-inline:5px" data-title="博客框架为Hexo_v5.4.0" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&amp;logo=hexo" alt=""/></a><a class="github-badge" target="_blank" href="https://butterfly.js.org/" style="margin-inline:5px" data-title="主题版本Butterfly_v4.2.2" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&amp;logo=bitdefender" alt=""/></a><a class="github-badge" target="_blank" href="https://www.jsdelivr.com/" style="margin-inline:5px" data-title="本站使用JsDelivr为静态资源提供CDN加速" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/CDN-jsDelivr-orange?style=flat&amp;logo=jsDelivr" alt=""/></a><a class="github-badge" target="_blank" href="https://beian.miit.gov.cn/#/Integrated/index" style="margin-inline:5px" data-title="本站已在湘进行备案" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/豫ICP备-2022000423号-e1d492?style=flat&amp;logo=data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAdCAYAAAC9pNwMAAABS2lUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4KPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNS42LWMxNDIgNzkuMTYwOTI0LCAyMDE3LzA3LzEzLTAxOjA2OjM5ICAgICAgICAiPgogPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4KICA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIi8+CiA8L3JkZjpSREY+CjwveDp4bXBtZXRhPgo8P3hwYWNrZXQgZW5kPSJyIj8+nhxg7wAACNlJREFUSInF1mmMVeUdx/Hv2e+5+519mJWBYQZkGxZZxLKJqBXGoLS1iXWrmihotFXaJiTWWlsbl6q1aetWd5u0VkKjNG4YEJSlOCibDLMwM8x679z9nnPP1jcVJUxf+7z6J8+LT37/Z4VvaQhfFS8+sBXbctCDGrVTKlBUH4mxAbI9Hfj0IJLsp6paJ5/tmn20N/D0wKDRMq9F/c3M2U1/V0vDfWMFh+tv/Ig1zYPMabDImPJ52OaXO87W580KggCiiOsJOJ6I3wcNFaaeNKxrt72f2fLGu4FpJ/sDQABRzD22fH7/Yze069vGc6mrDLNIJCDik10sxz2by3VdPM87xzkP9jwPTZFRVI1YUJKH+oy7n3tbvv/P2wW/UQxRWe6w4ZJRptYLHDoCuz8v5cP92XbI762O+h6UVWHnUFbPpU0fEb2A60mMJ7MUi9b/b7UgKhiZMaIxm8YLplLMDPz8hl/EH+rs8TNlUpFf32uyZJGLPDwCiTGUyTWodTN49eUCdz2YwXb9NNcObp1X98WDoufynzMVCEKGn27ayPTWBi5ad8P5iQUkJEnFLjqM9Z+hrVX0vfDe6K2dPRWsW2bwyp9EUifSJB84gdxrkR0eRgv1o/3I4fbbprJ6scqamzVO9pffec1S5ZWY2Nfz5qEy/FqOC2Y3s3j53HMSi18VRjFPwSwg+1RfVbl115vvJrsfej7UGIsYPPGgQ7JXoO+Xx5B3dHEomyJ9x1qiQozkr95h5937aFnVyouPlgJK+Ss7Fxz64OTSxSX+LHYxT2IsRW5kbGI4oHcR0jqoqTjV9se3I7/f8rS/ClS23GxSXhph6L5d9Akm7qqZhHWBQGUJ+CWGFzcg7e7m6D3/ZuW1Ea5YKdA3EojuONi813TqNi+YPYOKUhXDtCeGL26/hakLLiEcdsaHRkRAoLRc4fJrmhnekyF0apgZowWSwwkaa+rw3f8WA1GZZsPP5JEChX8dhZTN6iU6kAcs5s+dHd183SJ0VVKL57pfw6YdRQw23aeWTns47DPTALWlRTR7kMLew6hGgYqUhWXYFFUdPZ6lUBahLA8hVcOftckfi7No7VRAAQqsX1dybfvG1qwriM9mM5mJ4e4jO5Cc01dPqixbr8tWGBQUL4vjGigEEShi+xUmZ2RiR/sJ1pbS8NkgZrKAGw0TsgQsQyFaF/nfYTGprAlMFysbA1pI3mhkR6snhGsaymYGvPyFEb9IdbUE2AzFFTwpRqCtBY0wmdER+hZW4j63gcJj38V+/ErSUZXsYBfjIZHIRW0c2Z8BskCAqN+CbBJBFnyyKjR+Ez57nBxLqpfMUeSISElMBFz6x2Q6OxzWrYjyxWVzEewioU3LCS5vQY6nMUrLwNaxXvoQ59IloFSx54PPAZtQLExVZZDxsVE8J4dn6v4JYatgbSjk0owPw7RGH2ADMo88Z7L20ip8f7gC7fAo0q4+0rt7kEQDvaghVZbiPHUHcyeXcfLjT3jmpR7AYsnSScya3UR8bARVMck7Y/cB75/X6rDf3Fg2dw2jKZm5dXGm1LuAzO5DCo9v6aT0ibco5kzOvLOP+NGTFJtDpPYeZKijk/Rn3QxsfZV7txwhX7ABiZUXBsGvIvguQApNQQva9RMmTvZ2dpVUls+tX/UD7GN/Y8Ws05w6rQF+9vyzg1vZjbvMRJhXiRSU8DpTFFe0QE8S6SfPkOkZoktrB2oAhZWrwljxOPmchiSMYOWNoxNuruFU5vWeXdsojiUon345113dBBQBmTYlTimgdB8nfPo4WjaNFgN9OMEkJ02dnadVt5ki54Esqy+bzKJltVhSPbI3iN2zCyMTeXNCuG7Omm2Zok7PR2+R7jvD8ouruHhmCrB5jVZeYxLdrTP4sr4Vtd9g4MA4qc4c+6cu5NPamfw4P59t2WrA4YdXKkASf7SFivo6PDdEPmf1fRM++zp1bH/0r4I1dD1ODtOWaW4IsvPjL7nqXhloQiSPwjjgMYkMASyGEBkjhISCQwkwzve/18AbT+pk8pVY4UacQi9y+gyZ0eRAw4qHa89LXEx1LXMSPfhDJYRb59BtlLKg2WPT2l6qYl1svtGkrLYckyA1S+t5+2ATm37WCui0LSynsckDNH5zTxAchbQtkx08hDHYiW6NgC0enHBzEZ102UDH8QORdEckjEzZrNWkRydzyx17uGnDXqbUnGZ6dRPjSY91q2TqwjFuvTxLo5Zn5Qo/pumRSFcTLQtybEhGE0fQrDhhJ0VvH2lTnnHPhGtsmWan469apERjI2MH3qN7+7MEfH6ql29CbV7PvsMG32k6yU2XDhEKyZw66eJaRdrXR7CzCcqUNC3zwgymPJRCH4KRRLINimpL14A5Y4GDeOqbsPRVcfuN7Xj44pav/hFfrNT2kr2rsqf2Ibp5pEA14ZIImUyW3t5REkkTXRGQ/DGGhtLginhqCWknQDE5hKf5UFSF9Lj020Q2ul5V1AR2hr+8vuP8Vlc2zMPRxoSjnx7XBC14sDoydahSGq7KdO/HFyrBchxCVfX4fDKp4T7SCQejYODZLrYgIqgKFsNIgQqEYob8mW6yiUyb7Z64LVK/+B85xznnJ3AWzqTzuIX46mr5wLs+UUTyIriBCjRNxguHMJIFDLEEvXEOVRWnSJ0+jCd4CJoGjoedM1CLcXQziW3nMV2TSMBeOx7vWZvPt1r+cMPzE8KunaUkFn0vNrvtqXj34c1W6gzxlEQ6naIoBahtnkMwoFMwIVzSRNguMt53Aj2s4nkSlgPoGqLkICsRNF0gl8rYWuP8+11/w/OOJDEhHPKLCIpOXmi+M9AgP+maiesLifF2T1Rn5ZNj5Lo/Qc/GcPMmhdoqlEgIGzCK4PiCmJKK68p4KfF3qYGuF0qCRUkJTzleUbvQyWRTuE5xYthxQbBs7EISAbkzUFG3VfXXbK2YFi3X/eryfKKnqVBItNjJxDzH8erddC4SqWwcN5WyTtlyO1RP/Lh3eHD76MB40swmiDVJyDLYRhpc5+ub6tse/wWKbvSQEAw1awAAAABJRU5ErkJggg==" alt=""/></a><a class="github-badge" target="_blank" href="https://github.com/" style="margin-inline:5px" data-title="本站项目由Github托管" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Source-Github-d021d6?style=flat&amp;logo=GitHub" alt=""/></a><a class="github-badge" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" style="margin-inline:5px" data-title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&amp;logo=Claris" alt=""/></a></p>';
    console.log('已挂载butterfly_footer_beautify')
    parent_div_git.insertAdjacentHTML("beforeend",item_html)
    }
  var elist = 'null'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_footer_beautify_injector_config();
  }
  else if (epage === cpage){
    butterfly_footer_beautify_injector_config();
  }
  </script><script async src="/js/a.js"></script><div class="js-pjax"><script async="async">var arr = document.getElementsByClassName('recent-post-item');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '1.5s');
    arr[i].setAttribute('data-wow-delay', '200ms');
    arr[i].setAttribute('data-wow-offset', '30');
    arr[i].setAttribute('data-wow-iteration', '1');
  }</script><script async="async">var arr = document.getElementsByClassName('card-widget');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '');
    arr[i].setAttribute('data-wow-delay', '200ms');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script><script async="async">var arr = document.getElementsByClassName('flink-list-card');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__flipInY');
    arr[i].setAttribute('data-wow-duration', '3s');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script><script async="async">var arr = document.getElementsByClassName('flink-list-card');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__animated');
    arr[i].setAttribute('data-wow-duration', '3s');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script><script async="async">var arr = document.getElementsByClassName('article-sort-item');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__slideInRight');
    arr[i].setAttribute('data-wow-duration', '1.5s');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script><script async="async">var arr = document.getElementsByClassName('site-card');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__flipInY');
    arr[i].setAttribute('data-wow-duration', '3s');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script><script async="async">var arr = document.getElementsByClassName('site-card');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__animated');
    arr[i].setAttribute('data-wow-duration', '3s');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script></div><script defer src="https://cdn.cbd.int/hexo-butterfly-wowjs/lib/wow.min.js"></script><script defer src="https://cdn.cbd.int/hexo-butterfly-wowjs/lib/wow_init.js"></script><script data-pjax>
  function butterfly_swiper_injector_config(){
    var parent_div_git = document.getElementById('recent-posts');
    var item_html = '<div class="recent-post-item swiper_container_card" style="height: auto;width: 100%"><div id="random"><div id="random-banner"><canvas id="peoplecanvas"></canvas></div><a id="random-hover" style="width:100%;height:auto;" href="javascript:toRandomPost()" rel="external nofollow noreferrer" one-link-mark="yes"><i class="fa fa-paper-plane" style="margin-left:10px"></i><div style="margin-left:10px">随便逛逛<i class="fa-solid fa-arrow-right" style="margin-left:10px"></i></div></a></div><div class="blog-slider swiper-container-fade swiper-container-horizontal" id="swiper_container"><div class="blog-slider__wrp swiper-wrapper" style="transition-duration: 0ms;"><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/923a.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://w.wallhaven.cc/full/ex/wallhaven-ex9gwo.png" alt="" onerror="this.src=https://cdn.cbd.int/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2022-09-19</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/923a.html&quot;);" href="javascript:void(0);" alt="">json-server文档</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/923a.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/f0ec.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://w.wallhaven.cc/full/ex/wallhaven-exe1xo.jpg" alt="" onerror="this.src=https://cdn.cbd.int/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2021-10-19</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/f0ec.html&quot;);" href="javascript:void(0);" alt="">vue3笔记（更新中）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/f0ec.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/d238.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://w.wallhaven.cc/full/p9/wallhaven-p9jdw3.jpg" alt="" onerror="this.src=https://cdn.cbd.int/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-01-08</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/d238.html&quot;);" href="javascript:void(0);" alt="">源码笔记（更新中）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/d238.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/cdc4.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://w.wallhaven.cc/full/85/wallhaven-85dgxj.png" alt="" onerror="this.src=https://cdn.cbd.int/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-01-08</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/cdc4.html&quot;);" href="javascript:void(0);" alt="">canvas学习</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/cdc4.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/99be.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/blog-construct/banner.jpg" alt="" onerror="this.src=https://cdn.cbd.int/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2022-05-08</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/99be.html&quot;);" href="javascript:void(0);" alt="">常见面试题（开胃菜）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/99be.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/ae65.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://w.wallhaven.cc/full/we/wallhaven-wel1wq.jpg" alt="" onerror="this.src=https://cdn.cbd.int/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2022-10-20</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/ae65.html&quot;);" href="javascript:void(0);" alt="">为你的夏日带去清凉!</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/ae65.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div></div><div class="blog-slider__pagination swiper-pagination-clickable swiper-pagination-bullets"></div></div></div>';
    console.log('已挂载butterfly_swiper')
    parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  var elist = 'undefined'.split(',');
  var cpage = location.pathname;
  var epage = '/';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_swiper_injector_config();
  }
  else if (epage === cpage){
    butterfly_swiper_injector_config();
  }
  </script><script defer src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/js/swiper.min.js"></script><script defer data-pjax src="https://cdn.cbd.int/hexo-butterfly-swiper-anzhiyu@1.0.4/lib/swiper_init.js"></script><script data-pjax src="https://lf26-cdn-tos.bytecdntp.com/cdn/expire-1-M/gsap/3.9.1/gsap.min.js"></script><script defer src="https://npm.elemecdn.com/hexo-butterfly-swiper-anzhiyu@1.0.4/lib/people.min.js"></script><script async src="/anzhiyu/random.js"></script><script async src="/js/ali_font.js"></script><!-- hexo injector body_end end --><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/koharu.model.json"},"display":{"position":"left","width":150,"height":300},"mobile":{"show":false},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/"});</script></body></html>