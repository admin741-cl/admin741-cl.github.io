<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>孔乙己的长衫</title>
  <icon>https://www.gravatar.com/avatar/9447b1ec634af90af6ab29e41424ba47</icon>
  <subtitle>人人都笑孔乙己，人人又都是孔乙己</subtitle>
  <link href="https://admin741-cl.github.io/atom.xml" rel="self"/>
  
  <link href="https://admin741-cl.github.io/"/>
  <updated>2023-06-17T06:50:23.172Z</updated>
  <id>https://admin741-cl.github.io/</id>
  
  <author>
    <name>admin741</name>
    <email>1957875100@qq.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>vue3中动态显示当前时间</title>
    <link href="https://admin741-cl.github.io/posts/e5df.html"/>
    <id>https://admin741-cl.github.io/posts/e5df.html</id>
    <published>2023-06-17T06:46:29.636Z</published>
    <updated>2023-06-17T06:50:23.172Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在setup中写入</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> time = <span class="title function_">ref</span>();</span><br><span class="line"><span class="comment">// 获取当前时间</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">getTime</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  time.<span class="property">value</span> = <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> timer = <span class="number">0</span>;</span><br><span class="line"><span class="title function_">onMounted</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  timer = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//设置定时器</span></span><br><span class="line">    <span class="title function_">getTime</span>(); <span class="comment">//自定义事件</span></span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="title function_">onBeforeUnmount</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">clearInterval</span>(timer); <span class="comment">//清除定时器</span></span><br><span class="line">  timer = <span class="number">0</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>当然展示出来的数据是这样的</p><p><img src="https://img-blog.csdnimg.cn/c75bdd7a6f7240debacd6921828be97f.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动">编辑</p><p> 我们可以对时间进行格式化</p><h1 id="首先呢-我们用new-Date-所展示的时间为"><a href="#首先呢-我们用new-Date-所展示的时间为" class="headerlink" title="首先呢 我们用new Date() 所展示的时间为"></a>首先呢 我们用new Date() 所展示的时间为</h1><p><img src="https://img-blog.csdnimg.cn/f91cb71fb224423491bc5719ab80c2d9.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动">编辑</p><h1 id="推荐使用：第三方插件-dayjs"><a href="#推荐使用：第三方插件-dayjs" class="headerlink" title="推荐使用：第三方插件 dayjs"></a>推荐使用：第三方插件 <code>dayjs</code></h1><p>Day.js 是一个轻量的处理时间和日期的 JavaScript 库，和 Moment.js 的 API 设计保持完全一样. 如果您曾经用过 Moment.js, 那么您已经知道如何使用 Day.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install dayjs --save</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><h2 id="在xxx-vue中引入"><a href="#在xxx-vue中引入" class="headerlink" title="在xxx.vue中引入"></a>在xxx.vue中引入</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>获取当前时间<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123; time &#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">import</span> dayjs <span class="keyword">from</span> <span class="string">&quot;dayjs&quot;</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="comment">//没有使用dayjs</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span> <span class="title class_">Date</span>());</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="comment">//使用dayjs</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">dayjs</span>(<span class="keyword">new</span> <span class="title class_">Date</span>()).<span class="title function_">format</span>(<span class="string">&quot;YYYY-MM-DD hh:mm:ss&quot;</span>));</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="comment">// 案例：动态获取当前时间</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">const</span> time = <span class="title function_">ref</span>();</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">const</span> <span class="title function_">getTime</span> = (<span class="params"></span>) =&gt; &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  time.<span class="property">value</span> = <span class="title function_">dayjs</span>(<span class="keyword">new</span> <span class="title class_">Date</span>()).<span class="title function_">format</span>(<span class="string">&quot;YYYY-MM-DD hh:mm:ss&quot;</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">var</span> timer = <span class="number">0</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="title function_">onMounted</span>(<span class="function">() =&gt;</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  timer = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="comment">//设置定时器</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="title function_">getTime</span>(); <span class="comment">//自定义事件</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;, <span class="number">10</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="title function_">onBeforeUnmount</span>(<span class="function">() =&gt;</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="built_in">clearInterval</span>(timer); <span class="comment">//清除定时器</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  timer = <span class="number">0</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/4066475f411840b38871410a2ab1c90a.png" alt="img"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;l</summary>
      
    
    
    
    
    <category term="笔记" scheme="https://admin741-cl.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>canvas学习</title>
    <link href="https://admin741-cl.github.io/posts/cdc4.html"/>
    <id>https://admin741-cl.github.io/posts/cdc4.html</id>
    <published>2023-01-08T10:59:41.000Z</published>
    <updated>2023-06-17T02:32:00.666Z</updated>
    
    <content type="html"><![CDATA[<h1 id="01-认识canvas"><a href="#01-认识canvas" class="headerlink" title="01-认识canvas"></a>01-认识canvas</h1><p>身为一个WEB开发人员，肯定都是想着能够开发出酷炫和激动人心的应用程序来。可以很多动画特效，例如黑客帝国的数字，彩色炫酷的例子动效。也可以实现各种图画面板，如实现类似于photoshop的web在线图像编辑。各种酷炫的表单等等。</p><h2 id=""><a href="#" class="headerlink" title=" "></a> </h2><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><p><img src="https://threejs-1251830808.cos.ap-guangzhou.myqcloud.com/1667114597950-85a1d0a9-63c7-4ef3-82fe-3a9340047826.png" alt="img"></p><p>画布是H5中一个重要的概念，它面向开发人员提供了非常底层的绘图接口，使得绘制速度可以大幅提高，这对游戏等领域极为重要。</p><p><img src="https://threejs-1251830808.cos.ap-guangzhou.myqcloud.com/1634643034769-157be8ec-b103-4574-84ab-8876ac728ffa.gif" alt="img"></p><p>本次课程中将非常系统和全面的详解canvas的各种属性和项目中的应用。并且以实战的案例如刮刮卡、抽奖转盘、表单饼图、画板、粒子特效等案例帮助大家真正掌握canvas并能写出各种特效和动画。</p><h2 id="-1"><a href="#-1" class="headerlink" title=" "></a> </h2><h2 id="canvas元素"><a href="#canvas元素" class="headerlink" title="canvas元素"></a>canvas元素</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;canvas id=&quot;tutorial&quot; width=&quot;150&quot; height=&quot;150&quot;&gt;&lt;/canvas&gt;</span><br></pre></td></tr></table></figure><p>canvas看起来和 img 元素很相像，唯一的不同就是它并没有 src 和 alt 属性。实际上，canvas 标签只有两个属性<strong>——</strong> width和height。这些都是可选的，并且同样利用 DOM properties 来设置。</p><p>当没有设置宽度和高度的时候，canvas 会初始化宽度为 300 像素和高度为 150 像素。该元素可以使用CSS来定义大小，但在绘制时图像会伸缩以适应它的框架尺寸：如果 CSS 的尺寸与初始画布的比例不一致，它会出现扭曲。</p><p>如果你绘制出来的图像是扭曲的，尝试用 width 和 height 属性为canvas明确规定宽高，而不是使用 CSS。</p><p>id属性并不是canvas元素所特有的，而是每一个 HTML 元素都默认具有的属性（比如 class 属性）。给每个标签都加上一个 id 属性是个好主意，因为这样你就能在我们的脚本中很容易的找到它。</p><p>canvas元素可以像任何一个普通的图像一样（有margin，border，background等等属性）被设计。然而，这些样式不会影响在 canvas 中的实际图像。我们将会在一个专门的章节里看到这是如何解决的。当开始时没有为 canvas 规定样式规则，其将会完全透明。</p><h3 id="-2"><a href="#-2" class="headerlink" title=" "></a> </h3><h3 id="替换内容"><a href="#替换内容" class="headerlink" title="替换内容"></a>替换内容</h3><p>canvas元素与img标签的不同之处在于，就像video，audio，或者 picture元素一样，很容易定义一些替代内容。由于某些较老的浏览器（尤其是 IE9 之前的 IE 浏览器）或者文本浏览器不支持 HTML  元素”canvas”，在这些浏览器上你应该总是能展示替代内容。</p><p>这非常简单：我们只是在canvas标签中提供了替换内容。不支持canvas的浏览器将会忽略容器并在其中渲染后备内容。而支持canvas的浏览器将会忽略在容器中包含的内容，并且只是正常渲染 canvas。</p><p>举个例子，我们可以提供对 canvas 内容的文字描述或者是提供动态生成内容相对应的静态图片，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;canvas id=&quot;stockGraph&quot; width=&quot;150&quot; height=&quot;150&quot;&gt;</span><br><span class="line">  current stock price: $3.15 +0.15</span><br><span class="line">&lt;/canvas&gt;</span><br><span class="line"></span><br><span class="line">&lt;canvas id=&quot;clock&quot; width=&quot;150&quot; height=&quot;150&quot;&gt;</span><br><span class="line">  &lt;img src=&quot;images/clock.png&quot; width=&quot;150&quot; height=&quot;150&quot; alt=&quot;&quot;/&gt;</span><br><span class="line">&lt;/canvas&gt;</span><br></pre></td></tr></table></figure><h3 id="结束标签不可省"><a href="#结束标签不可省" class="headerlink" title="结束标签不可省"></a>结束标签不可省</h3><p>与 img元素不同，canvas 元素<strong>需要</strong>结束标签 (<code>&lt;/canvas&gt;</code>)。如果结束标签不存在，则文档的其余部分会被认为是替代内容，将不会显示出来。</p><p>如果不需要替代内容，一个简单的<code>&lt;canvas id=&quot;foo&quot; ...&gt;&lt;/canvas&gt;</code>在所有支持 canvas 的浏览器中都是完全兼容的。</p><h2 id="-3"><a href="#-3" class="headerlink" title=" "></a> </h2><h2 id="渲染上下文（The-rendering-context）"><a href="#渲染上下文（The-rendering-context）" class="headerlink" title="渲染上下文（The rendering context）"></a>渲染上下文（The rendering context）</h2><p><code>&lt;canvas&gt;</code>元素创造了一个固定大小的画布，它公开了一个或多个<strong>渲染上下文</strong>，其可以用来绘制和处理要展示的内容。我们将会将注意力放在 2D 渲染上下文中。其他种类的上下文也许提供了不同种类的渲染方式；比如， WebGL 使用了基于OpenGL ES的 3D 上下文 (“webgl”) 。</p><p>canvas 起初是空白的。为了展示，首先脚本需要找到渲染上下文，然后在它的上面绘制。<code>&lt;canvas&gt;</code>元素有一个叫做 getContext() 的方法，这个方法是用来获得渲染上下文和它的绘画功能。getContext()接受一个参数，即上下文的类型。对于 2D 图像而言，如本教程，你可以使用 CanvasRenderingContext2D。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var canvas = document.getElementById(&#x27;tutorial&#x27;);</span><br><span class="line">var ctx = canvas.getContext(&#x27;2d&#x27;);</span><br></pre></td></tr></table></figure><p>代码的第一行通过使用 document.getElementById() 方法来为<code>&lt;canvas&gt;</code>元素得到 DOM 对象。一旦有了元素对象，你可以通过使用它的 getContext() 方法来访问绘画上下文。</p><h2 id="-4"><a href="#-4" class="headerlink" title=" "></a> </h2><h2 id="检查支持性"><a href="#检查支持性" class="headerlink" title="检查支持性"></a>检查支持性</h2><p>替换内容是用于在不支持<code>&lt;canvas&gt;</code>标签的浏览器中展示的。通过简单的测试 getContext() 方法的存在，脚本可以检查编程支持性。上面的代码片段现在变成了这个样子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canvas = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;tutorial&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (canvas.<span class="property">getContext</span>)&#123;</span><br><span class="line">  <span class="keyword">var</span> ctx = canvas.<span class="title function_">getContext</span>(<span class="string">&#x27;2d&#x27;</span>);</span><br><span class="line">  <span class="comment">// drawing code here</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// canvas-unsupported code here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="一个模板骨架"><a href="#一个模板骨架" class="headerlink" title="一个模板骨架"></a>一个模板骨架</h2><p>这里的是一个最简单的模板，我们之后就可以把它作为之后的例子的起点。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Canvas tutorial<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">function</span> <span class="title function_">draw</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> canvas = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;tutorial&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">if</span> (canvas.<span class="property">getContext</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">          <span class="keyword">var</span> ctx = canvas.<span class="title function_">getContext</span>(<span class="string">&#x27;2d&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">      &#125;</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">      <span class="selector-tag">canvas</span> &#123; <span class="attribute">border</span>: <span class="number">1px</span> solid black; &#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span> <span class="attr">onload</span>=<span class="string">&quot;draw();&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">canvas</span> <span class="attr">id</span>=<span class="string">&quot;tutorial&quot;</span> <span class="attr">width</span>=<span class="string">&quot;150&quot;</span> <span class="attr">height</span>=<span class="string">&quot;150&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上面的脚本中包含一个叫做 draw()  的函数，当页面加载结束的时候就会执行这个函数。通过使用在文档上加载事件来完成。只要页面加载结束，这个函数，或者像是这个的，同样可以使用  window.setTimeout()(en-US)， window.setInterval()(en-US)，或者其他任何事件处理程序来调用。</p><p>模板看起来会是这样。如这里所示，它最初是空白的。</p><h2 id="-5"><a href="#-5" class="headerlink" title=" "></a> </h2><h2 id="一个简单例子"><a href="#一个简单例子" class="headerlink" title="一个简单例子"></a>一个简单例子</h2><p>一开始，让我们来看个简单的例子，我们绘制了两个有趣的长方形，其中的一个有着 alpha 透明度。我们将在接下来的例子里深入探索一下这是如何工作的。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;application/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">function</span> <span class="title function_">draw</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> canvas = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;canvas&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">if</span> (canvas.<span class="property">getContext</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">          <span class="keyword">var</span> ctx = canvas.<span class="title function_">getContext</span>(<span class="string">&quot;2d&quot;</span>);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">          ctx.<span class="property">fillStyle</span> = <span class="string">&quot;rgb(200,0,0)&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">          ctx.<span class="property">fillRect</span> (<span class="number">10</span>, <span class="number">10</span>, <span class="number">55</span>, <span class="number">50</span>);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">          ctx.<span class="property">fillStyle</span> = <span class="string">&quot;rgba(0, 0, 200, 0.5)&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">          ctx.<span class="property">fillRect</span> (<span class="number">30</span>, <span class="number">30</span>, <span class="number">55</span>, <span class="number">50</span>);</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">      &#125;</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span> <span class="attr">onload</span>=<span class="string">&quot;draw();&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">canvas</span> <span class="attr">id</span>=<span class="string">&quot;canvas&quot;</span> <span class="attr">width</span>=<span class="string">&quot;150&quot;</span> <span class="attr">height</span>=<span class="string">&quot;150&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://threejs-1251830808.cos.ap-guangzhou.myqcloud.com/1667109836400-3a821caa-f061-4084-833e-e26de65f57fb.png" alt="img"></p><h1 id="01-canvas绘制基本图形"><a href="#01-canvas绘制基本图形" class="headerlink" title="01-canvas绘制基本图形"></a>01-canvas绘制基本图形</h1><p>既然我们已经设置了 canvas 环境，我们可以深入了解如何在 canvas 上绘制。到本文的最后，你将学会如何绘制矩形，三角形，直线，圆弧和曲线，变得熟悉这些基本的形状。绘制物体到 Canvas 前，需掌握路径，我们看看到底怎么做。</p><h2 id="-6"><a href="#-6" class="headerlink" title=" "></a> </h2><h2 id="栅格"><a href="#栅格" class="headerlink" title="栅格"></a>栅格</h2><p><img src="https://threejs-1251830808.cos.ap-guangzhou.myqcloud.com/1667121349188-0130b309-19cf-49db-a6bb-c02ea6c317ed.png" alt="img"></p><p>在我们开始画图之前，我们需要了解一下画布栅格（canvas grid）以及坐标空间。上一页中的 HTML 模板中有个宽 150px, 高 150px 的 canvas 元素。如右图所示，canvas  元素默认被网格所覆盖。通常来说网格中的一个单元相当于 canvas  元素中的一像素。栅格的起点为左上角（坐标为（0,0））。所有元素的位置都相对于原点定位。所以图中蓝色方形左上角的坐标为距离左边（X 轴）x  像素，距离上边（Y 轴）y 像素（坐标为（x,y））。在课程的最后我们会平移原点到不同的坐标上，旋转网格以及缩放。现在我们还是使用原来的设置。</p><h2 id="-7"><a href="#-7" class="headerlink" title=" "></a> </h2><h2 id="绘制矩形"><a href="#绘制矩形" class="headerlink" title="绘制矩形"></a>绘制矩形</h2><p>不同于 SVG，canvas 只支持两种形式的图形绘制：矩形和路径（由一系列点连成的线段）。所有其他类型的图形都是通过一条或者多条路径组合而成的。不过，我们拥有众多路径生成的方法让复杂图形的绘制成为了可能。</p><p>首先，我们回到矩形的绘制中。canvas 提供了三种方法绘制矩形：</p><p>fillRect(x, y, width, height)</p><p>绘制一个填充的矩形</p><p>strokeRect(x, y, width, height)</p><p>绘制一个矩形的边框</p><p>clearRect(x, y, width, height)</p><p>清除指定矩形区域，让清除部分完全透明。</p><p>上面提供的方法之中每一个都包含了相同的参数。x 与 y 指定了在 canvas 画布上所绘制的矩形的左上角（相对于原点）的坐标。width 和 height 设置矩形的尺寸。</p><p>下面的 draw() 函数是前一页中取得的，现在就来使用上面的三个函数。</p><h3 id="-8"><a href="#-8" class="headerlink" title=" "></a> </h3><h3 id="矩形（Rectangular）例子"><a href="#矩形（Rectangular）例子" class="headerlink" title="矩形（Rectangular）例子"></a>矩形（Rectangular）例子</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">draw</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> canvas = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;canvas&#x27;</span>);</span><br><span class="line">  <span class="keyword">if</span> (canvas.<span class="property">getContext</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> ctx = canvas.<span class="title function_">getContext</span>(<span class="string">&#x27;2d&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    ctx.<span class="title function_">fillRect</span>(<span class="number">25</span>, <span class="number">25</span>, <span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line">    ctx.<span class="title function_">clearRect</span>(<span class="number">45</span>, <span class="number">45</span>, <span class="number">60</span>, <span class="number">60</span>);</span><br><span class="line">    ctx.<span class="title function_">strokeRect</span>(<span class="number">50</span>, <span class="number">50</span>, <span class="number">50</span>, <span class="number">50</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://threejs-1251830808.cos.ap-guangzhou.myqcloud.com/1667121532600-d949eddb-9dba-42db-82c2-0aa93b1fe19e.png" alt="img"></p><p>fillRect()函数绘制了一个边长为 100px 的黑色正方形。clearRect()函数从正方形的中心开始擦除了一个 60<em>60px 的正方形，接着strokeRect()在清除区域内生成一个 50</em>50 的正方形边框。</p><p>接下来我们能够看到 clearRect() 的两个可选方法，然后我们会知道如何改变渲染图形的填充颜色及描边颜色。</p><p>不同于下一节所要介绍的路径函数（path function），以上的三个函数绘制之后会马上显现在 canvas 上，即时生效。</p><h3 id="-9"><a href="#-9" class="headerlink" title=" "></a> </h3><h3 id="矩形"><a href="#矩形" class="headerlink" title="矩形"></a>矩形</h3><p>直接在画布上绘制矩形的三个额外方法，正如我们开始所见的绘制矩形，同样，也有 rect() 方法，将一个矩形路径增加到当前路径上。</p><p>rect(x, y, width, height)</p><p>绘制一个左上角坐标为（x,y），宽高为 width 以及 height 的矩形。</p><p>当该方法执行的时候，moveTo() 方法自动设置坐标参数（0,0）。也就是说，当前笔触自动重置回默认坐标。</p><h2 id="-10"><a href="#-10" class="headerlink" title=" "></a> </h2><h2 id="绘制路径"><a href="#绘制路径" class="headerlink" title="绘制路径"></a>绘制路径</h2><p>图形的基本元素是路径。路径是通过不同颜色和宽度的线段或曲线相连形成的不同形状的点的集合。一个路径，甚至一个子路径，都是闭合的。使用路径绘制图形需要一些额外的步骤。</p><ol><li>首先，你需要创建路径起始点。</li><li>然后你使用画图命令去画出路径。</li><li>之后你把路径封闭。</li><li>一旦路径生成，你就能通过描边或填充路径区域来渲染图形。</li></ol><p>以下是所要用到的函数：</p><p>beginPath()</p><p>新建一条路径，生成之后，图形绘制命令被指向到路径上生成路径。</p><p>closePath()</p><p>闭合路径之后图形绘制命令又重新指向到上下文中。</p><p>stroke()</p><p>通过线条来绘制图形轮廓。</p><p>fill()</p><p>通过填充路径的内容区域生成实心的图形。</p><p>生成路径的第一步叫做 beginPath()。本质上，路径是由很多子路径构成，这些子路径都是在一个列表中，所有的子路径（线、弧形、等等）构成图形。而每次这个方法调用之后，列表清空重置，然后我们就可以重新绘制新的图形。</p><p><strong>备注：</strong> 当前路径为空，即调用 beginPath() 之后，或者 canvas 刚建的时候，第一条路径构造命令通常被视为是 moveTo（），无论实际上是什么。出于这个原因，你几乎总是要在设置路径之后专门指定你的起始位置。</p><p>第二步就是调用函数指定绘制路径，本文稍后我们就能看到了。</p><p>第三，就是闭合路径 closePath(),不是必需的。这个方法会通过绘制一条从当前点到开始点的直线来闭合图形。如果图形是已经闭合了的，即当前点为开始点，该函数什么也不做。</p><p><strong>备注：</strong> 当你调用 fill() 函数时，所有没有闭合的形状都会自动闭合，所以你不需要调用 closePath() 函数。但是调用 stroke() 时不会自动闭合。</p><h3 id="-11"><a href="#-11" class="headerlink" title=" "></a> </h3><h3 id="绘制一个三角形"><a href="#绘制一个三角形" class="headerlink" title="绘制一个三角形"></a>绘制一个三角形</h3><p>例如，绘制三角形的代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">draw</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> canvas = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;canvas&#x27;</span>);</span><br><span class="line">  <span class="keyword">if</span> (canvas.<span class="property">getContext</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> ctx = canvas.<span class="title function_">getContext</span>(<span class="string">&#x27;2d&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    ctx.<span class="title function_">beginPath</span>();</span><br><span class="line">    ctx.<span class="title function_">moveTo</span>(<span class="number">75</span>, <span class="number">50</span>);</span><br><span class="line">    ctx.<span class="title function_">lineTo</span>(<span class="number">100</span>, <span class="number">75</span>);</span><br><span class="line">    ctx.<span class="title function_">lineTo</span>(<span class="number">100</span>, <span class="number">25</span>);</span><br><span class="line">    ctx.<span class="title function_">fill</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="移动笔触"><a href="#移动笔触" class="headerlink" title="移动笔触"></a>移动笔触</h3><p>一个非常有用的函数，而这个函数实际上并不能画出任何东西，也是上面所描述的路径列表的一部分，这个函数就是moveTo()。或者你可以想象一下在纸上作业，一支钢笔或者铅笔的笔尖从一个点到另一个点的移动过程。</p><p>moveTo(x, y)</p><p>将笔触移动到指定的坐标 x 以及 y 上。</p><p>当 canvas 初始化或者beginPath()调用后，你通常会使用moveTo()函数设置起点。我们也能够使用moveTo()绘制一些不连续的路径。看一下下面的笑脸例子。我将用到moveTo()方法（红线处）的地方标记了。</p><p>你可以尝试一下，使用下边的代码片。只需要将其复制到之前的draw()函数即可。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">draw</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> canvas = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;canvas&#x27;</span>);</span><br><span class="line">  <span class="keyword">if</span> (canvas.<span class="property">getContext</span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> ctx = canvas.<span class="title function_">getContext</span>(<span class="string">&#x27;2d&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    ctx.<span class="title function_">beginPath</span>();</span><br><span class="line">    ctx.<span class="title function_">arc</span>(<span class="number">75</span>, <span class="number">75</span>, <span class="number">50</span>, <span class="number">0</span>, <span class="title class_">Math</span>.<span class="property">PI</span> * <span class="number">2</span>, <span class="literal">true</span>); <span class="comment">// 绘制</span></span><br><span class="line">    ctx.<span class="title function_">moveTo</span>(<span class="number">110</span>, <span class="number">75</span>);</span><br><span class="line">    ctx.<span class="title function_">arc</span>(<span class="number">75</span>, <span class="number">75</span>, <span class="number">35</span>, <span class="number">0</span>, <span class="title class_">Math</span>.<span class="property">PI</span>, <span class="literal">false</span>);   <span class="comment">// 口 (顺时针)</span></span><br><span class="line">    ctx.<span class="title function_">moveTo</span>(<span class="number">65</span>, <span class="number">65</span>);</span><br><span class="line">    ctx.<span class="title function_">arc</span>(<span class="number">60</span>, <span class="number">65</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="title class_">Math</span>.<span class="property">PI</span> * <span class="number">2</span>, <span class="literal">true</span>);  <span class="comment">// 左眼</span></span><br><span class="line">    ctx.<span class="title function_">moveTo</span>(<span class="number">95</span>, <span class="number">65</span>);</span><br><span class="line">    ctx.<span class="title function_">arc</span>(<span class="number">90</span>, <span class="number">65</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="title class_">Math</span>.<span class="property">PI</span> * <span class="number">2</span>, <span class="literal">true</span>);  <span class="comment">// 右眼</span></span><br><span class="line">    ctx.<span class="title function_">stroke</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://threejs-1251830808.cos.ap-guangzhou.myqcloud.com/1667121749673-6dd96f71-4fc6-40a0-9b45-a036d4611a03.png" alt="img"></p><h3 id="-12"><a href="#-12" class="headerlink" title=" "></a> </h3><h3 id="线"><a href="#线" class="headerlink" title="线"></a>线</h3><p>绘制直线，需要用到的方法lineTo()。</p><p>lineTo(x, y)</p><p>绘制一条从当前位置到指定 x 以及 y 位置的直线。</p><p>该方法有两个参数：x 以及 y，代表坐标系中直线结束的点。开始点和之前的绘制路径有关，之前路径的结束点就是接下来的开始点，等等。。。开始点也可以通过moveTo()函数改变。</p><p>下面的例子绘制两个三角形，一个是填充的，另一个是描边的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">draw</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> canvas = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;canvas&#x27;</span>);</span><br><span class="line">  <span class="keyword">if</span> (canvas.<span class="property">getContext</span>)&#123;</span><br><span class="line">  <span class="keyword">var</span> ctx = canvas.<span class="title function_">getContext</span>(<span class="string">&#x27;2d&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 填充三角形</span></span><br><span class="line">  ctx.<span class="title function_">beginPath</span>();</span><br><span class="line">  ctx.<span class="title function_">moveTo</span>(<span class="number">25</span>, <span class="number">25</span>);</span><br><span class="line">  ctx.<span class="title function_">lineTo</span>(<span class="number">105</span>, <span class="number">25</span>);</span><br><span class="line">  ctx.<span class="title function_">lineTo</span>(<span class="number">25</span>, <span class="number">105</span>);</span><br><span class="line">  ctx.<span class="title function_">fill</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 描边三角形</span></span><br><span class="line">  ctx.<span class="title function_">beginPath</span>();</span><br><span class="line">  ctx.<span class="title function_">moveTo</span>(<span class="number">125</span>, <span class="number">125</span>);</span><br><span class="line">  ctx.<span class="title function_">lineTo</span>(<span class="number">125</span>, <span class="number">45</span>);</span><br><span class="line">  ctx.<span class="title function_">lineTo</span>(<span class="number">45</span>, <span class="number">125</span>);</span><br><span class="line">  ctx.<span class="title function_">closePath</span>();</span><br><span class="line">  ctx.<span class="title function_">stroke</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里从调用beginPath()函数准备绘制一个新的形状路径开始。然后使用moveTo()函数移动到目标位置上。然后下面，两条线段绘制后构成三角形的两条边。</p><p><img src="https://threejs-1251830808.cos.ap-guangzhou.myqcloud.com/1667121985104-5a86c456-016e-4028-bf7c-dd5aec14612e.png" alt="img"></p><h3 id="-13"><a href="#-13" class="headerlink" title=" "></a> </h3><h3 id="圆弧"><a href="#圆弧" class="headerlink" title="圆弧"></a>圆弧</h3><p>绘制圆弧或者圆，我们使用arc()方法。当然可以使用arcTo()，不过这个的实现并不是那么的可靠，所以我们这里不作介绍。</p><p>arc(x, y, radius, startAngle, endAngle, anticlockwise)</p><p>画一个以（x,y）为圆心的以 radius 为半径的圆弧（圆），从 startAngle 开始到 endAngle 结束，按照 anticlockwise 给定的方向（默认为顺时针）来生成。</p><p>arcTo(x1, y1, x2, y2, radius)</p><p>根据给定的控制点和半径画一段圆弧，再以直线连接两个控制点。</p><p>这里详细介绍一下 arc  方法，该方法有六个参数：x,y为绘制圆弧所在圆上的圆心坐标。radius为半径。startAngle以及endAngle参数用弧度定义了开始以及结束的弧度。这些都是以 x 轴为基准。参数anticlockwise为一个布尔值。为 true 时，是逆时针方向，否则顺时针方向。</p><p><strong>备注：</strong> arc() 函数中表示角的单位是弧度，不是角度。角度与弧度的 js 表达式：</p><p><strong>弧度=(Math.PI/180)*角度。</strong></p><p>下面的例子比上面的要复杂一下，下面绘制了 12 个不同的角度以及填充的圆弧。</p><p>下面两个for循环，生成圆弧的行列（x,y）坐标。每一段圆弧的开始都调用beginPath()。代码中，每个圆弧的参数都是可变的，实际编程中，我们并不需要这样做。</p><p>x,y 坐标是可变的。半径（radius）和开始角度（startAngle）都是固定的。结束角度（endAngle）在第一列开始时是 180 度（半圆）然后每列增加 90 度。最后一列形成一个完整的圆。</p><p>clockwise语句作用于第一、三行是顺时针的圆弧，anticlockwise作用于二、四行为逆时针圆弧。if语句让一、二行描边圆弧，下面两行填充路径。</p><p><strong>备注：</strong> 这个示例所需的画布大小略大于本页面的其他例子：150 x 200 像素。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">draw</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> canvas = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;canvas&#x27;</span>);</span><br><span class="line">  <span class="keyword">if</span> (canvas.<span class="property">getContext</span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> ctx = canvas.<span class="title function_">getContext</span>(<span class="string">&#x27;2d&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)&#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++)&#123;</span><br><span class="line">        ctx.<span class="title function_">beginPath</span>();</span><br><span class="line">        <span class="keyword">var</span> x = <span class="number">25</span> + j * <span class="number">50</span>; <span class="comment">// x 坐标值</span></span><br><span class="line">        <span class="keyword">var</span> y = <span class="number">25</span> + i * <span class="number">50</span>; <span class="comment">// y 坐标值</span></span><br><span class="line">        <span class="keyword">var</span> radius = <span class="number">20</span>; <span class="comment">// 圆弧半径</span></span><br><span class="line">        <span class="keyword">var</span> startAngle = <span class="number">0</span>; <span class="comment">// 开始点</span></span><br><span class="line">        <span class="keyword">var</span> endAngle = <span class="title class_">Math</span>.<span class="property">PI</span> + (<span class="title class_">Math</span>.<span class="property">PI</span> * j) / <span class="number">2</span>; <span class="comment">// 结束点</span></span><br><span class="line">        <span class="keyword">var</span> anticlockwise = i % <span class="number">2</span> == <span class="number">0</span> ? <span class="literal">false</span> : <span class="literal">true</span>; <span class="comment">// 顺时针或逆时针</span></span><br><span class="line"></span><br><span class="line">        ctx.<span class="title function_">arc</span>(x, y, radius, startAngle, endAngle, anticlockwise);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (i&gt;<span class="number">1</span>)&#123;</span><br><span class="line">          ctx.<span class="title function_">fill</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          ctx.<span class="title function_">stroke</span>();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://threejs-1251830808.cos.ap-guangzhou.myqcloud.com/1667122114277-99e48d4d-a449-41d9-96f4-e9e4373fb239.png" alt="img"></p><h3 id="-14"><a href="#-14" class="headerlink" title=" "></a> </h3><h3 id="使用arcTo方法"><a href="#使用arcTo方法" class="headerlink" title="使用arcTo方法"></a>使用arcTo方法</h3><p>这是一段绘制圆弧的简单的代码片段。基础点是蓝色的，两个控制点是红色的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canvas = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;canvas&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> ctx = canvas.<span class="title function_">getContext</span>(<span class="string">&quot;2d&quot;</span>);</span><br><span class="line"></span><br><span class="line">ctx.<span class="title function_">setLineDash</span>([])</span><br><span class="line">ctx.<span class="title function_">beginPath</span>();</span><br><span class="line">ctx.<span class="title function_">moveTo</span>(<span class="number">150</span>, <span class="number">20</span>);</span><br><span class="line">ctx.<span class="title function_">arcTo</span>(<span class="number">150</span>,<span class="number">100</span>,<span class="number">50</span>,<span class="number">20</span>,<span class="number">30</span>);</span><br><span class="line">ctx.<span class="title function_">stroke</span>();</span><br><span class="line"></span><br><span class="line">ctx.<span class="property">fillStyle</span> = <span class="string">&#x27;blue&#x27;</span>;</span><br><span class="line"><span class="comment">// base point</span></span><br><span class="line">ctx.<span class="title function_">fillRect</span>(<span class="number">150</span>, <span class="number">20</span>, <span class="number">10</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">ctx.<span class="property">fillStyle</span> = <span class="string">&#x27;red&#x27;</span>;</span><br><span class="line"><span class="comment">// control point one</span></span><br><span class="line">ctx.<span class="title function_">fillRect</span>(<span class="number">150</span>, <span class="number">100</span>, <span class="number">10</span>, <span class="number">10</span>);</span><br><span class="line"><span class="comment">// control point two</span></span><br><span class="line">ctx.<span class="title function_">fillRect</span>(<span class="number">50</span>, <span class="number">20</span>, <span class="number">10</span>, <span class="number">10</span>);</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">ctx.<span class="title function_">setLineDash</span>([<span class="number">5</span>,<span class="number">5</span>])</span><br><span class="line">ctx.<span class="title function_">moveTo</span>(<span class="number">150</span>, <span class="number">20</span>);</span><br><span class="line">ctx.<span class="title function_">lineTo</span>(<span class="number">150</span>,<span class="number">100</span>);</span><br><span class="line">ctx.<span class="title function_">lineTo</span>(<span class="number">50</span>, <span class="number">20</span>);</span><br><span class="line">ctx.<span class="title function_">stroke</span>();</span><br><span class="line">ctx.<span class="title function_">beginPath</span>();</span><br><span class="line">ctx.<span class="title function_">arc</span>(<span class="number">120</span>,<span class="number">38</span>,<span class="number">30</span>,<span class="number">0</span>,<span class="number">2</span>*<span class="title class_">Math</span>.<span class="property">PI</span>);</span><br><span class="line">ctx.<span class="title function_">stroke</span>();</span><br></pre></td></tr></table></figure><p><img src="https://threejs-1251830808.cos.ap-guangzhou.myqcloud.com/1667149844431-6d0f587b-e7e9-426f-b651-9a77a9bc0758.png" alt="img"></p><h3 id="-15"><a href="#-15" class="headerlink" title=" "></a> </h3><h3 id="二次贝塞尔曲线及三次贝塞尔曲线"><a href="#二次贝塞尔曲线及三次贝塞尔曲线" class="headerlink" title="二次贝塞尔曲线及三次贝塞尔曲线"></a>二次贝塞尔曲线及三次贝塞尔曲线</h3><p>下一个十分有用的路径类型就是贝塞尔曲线。二次及三次贝塞尔曲线都十分有用，一般用来绘制复杂有规律的图形。</p><p>quadraticCurveTo(cp1x, cp1y, x, y)</p><p>绘制二次贝塞尔曲线，cp1x,cp1y 为一个控制点，x,y 为结束点。</p><p><img src="https://threejs-1251830808.cos.ap-guangzhou.myqcloud.com/1667150886162-f5d91ebd-e23a-4468-9749-f20c62dbd7d1.gif" alt="img"></p><p>bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y)</p><p>绘制三次贝塞尔曲线，cp1x,cp1y为控制点一，cp2x,cp2y为控制点二，x,y为结束点。</p><p><img src="https://threejs-1251830808.cos.ap-guangzhou.myqcloud.com/1667150992425-4cd7f759-76d7-466d-836a-1be44e801f83.gif" alt="img"></p><p><img src="https://threejs-1251830808.cos.ap-guangzhou.myqcloud.com/1667122134189-e9cef021-bf64-4c7f-8bac-15f594a61899.png" alt="img"></p><p>右边的图能够很好的描述两者的关系，二次贝塞尔曲线有一个开始点（蓝色）、一个结束点（蓝色）以及一个控制点（红色），而三次贝塞尔曲线有两个控制点。</p><p>参数 x、y 在这两个方法中都是结束点坐标。cp1x,cp1y为坐标中的第一个控制点，cp2x,cp2y为坐标中的第二个控制点。</p><p>使用二次以及三次贝塞尔曲线是有一定的难度的，因为不同于像 Adobe Illustrators  这样的矢量软件，我们所绘制的曲线没有给我们提供直接的视觉反馈。这让绘制复杂的图形变得十分困难。在下面的例子中，我们会绘制一些简单有规律的图形，如果你有时间以及更多的耐心，很多复杂的图形你也可以绘制出来。</p><p>下面的这些例子没有多少困难。这两个例子中我们会连续绘制贝塞尔曲线，最后形成复杂的图形。</p><h4 id="-16"><a href="#-16" class="headerlink" title=" "></a> </h4><h4 id="二次贝塞尔曲线"><a href="#二次贝塞尔曲线" class="headerlink" title="二次贝塞尔曲线"></a>二次贝塞尔曲线</h4><p>这个例子使用多个贝塞尔曲线来渲染对话气泡。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">draw</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> canvas = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;canvas&#x27;</span>);</span><br><span class="line">  <span class="keyword">if</span> (canvas.<span class="property">getContext</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> ctx = canvas.<span class="title function_">getContext</span>(<span class="string">&#x27;2d&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 二次贝塞尔曲线</span></span><br><span class="line">    ctx.<span class="title function_">beginPath</span>();</span><br><span class="line">    ctx.<span class="title function_">moveTo</span>(<span class="number">75</span>, <span class="number">25</span>);</span><br><span class="line">    ctx.<span class="title function_">quadraticCurveTo</span>(<span class="number">25</span>, <span class="number">25</span>, <span class="number">25</span>, <span class="number">62.5</span>);</span><br><span class="line">    ctx.<span class="title function_">quadraticCurveTo</span>(<span class="number">25</span>, <span class="number">100</span>, <span class="number">50</span>, <span class="number">100</span>);</span><br><span class="line">    ctx.<span class="title function_">quadraticCurveTo</span>(<span class="number">50</span>, <span class="number">120</span>, <span class="number">30</span>, <span class="number">125</span>);</span><br><span class="line">    ctx.<span class="title function_">quadraticCurveTo</span>(<span class="number">60</span>, <span class="number">120</span>, <span class="number">65</span>, <span class="number">100</span>);</span><br><span class="line">    ctx.<span class="title function_">quadraticCurveTo</span>(<span class="number">125</span>, <span class="number">100</span>, <span class="number">125</span>, <span class="number">62.5</span>);</span><br><span class="line">    ctx.<span class="title function_">quadraticCurveTo</span>(<span class="number">125</span>, <span class="number">25</span>, <span class="number">75</span>, <span class="number">25</span>);</span><br><span class="line">    ctx.<span class="title function_">stroke</span>();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://threejs-1251830808.cos.ap-guangzhou.myqcloud.com/1667122154132-c116486b-a8a9-4c8a-9cbc-b4531d40c3f4.png" alt="img"></p><h4 id="-17"><a href="#-17" class="headerlink" title=" "></a> </h4><h4 id="三次贝塞尔曲线"><a href="#三次贝塞尔曲线" class="headerlink" title="三次贝塞尔曲线"></a>三次贝塞尔曲线</h4><p>这个例子使用贝塞尔曲线绘制心形。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">draw</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> canvas = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;canvas&#x27;</span>);</span><br><span class="line">  <span class="keyword">if</span> (canvas.<span class="property">getContext</span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> ctx = canvas.<span class="title function_">getContext</span>(<span class="string">&#x27;2d&#x27;</span>);</span><br><span class="line"></span><br><span class="line">     <span class="comment">//三次贝塞尔曲线</span></span><br><span class="line">    ctx.<span class="title function_">beginPath</span>();</span><br><span class="line">    ctx.<span class="title function_">moveTo</span>(<span class="number">75</span>, <span class="number">40</span>);</span><br><span class="line">    ctx.<span class="title function_">bezierCurveTo</span>(<span class="number">75</span>, <span class="number">37</span>, <span class="number">70</span>, <span class="number">25</span>, <span class="number">50</span>, <span class="number">25</span>);</span><br><span class="line">    ctx.<span class="title function_">bezierCurveTo</span>(<span class="number">20</span>, <span class="number">25</span>, <span class="number">20</span>, <span class="number">62.5</span>, <span class="number">20</span>, <span class="number">62.5</span>);</span><br><span class="line">    ctx.<span class="title function_">bezierCurveTo</span>(<span class="number">20</span>, <span class="number">80</span>, <span class="number">40</span>, <span class="number">102</span>, <span class="number">75</span>, <span class="number">120</span>);</span><br><span class="line">    ctx.<span class="title function_">bezierCurveTo</span>(<span class="number">110</span>, <span class="number">102</span>, <span class="number">130</span>, <span class="number">80</span>, <span class="number">130</span>, <span class="number">62.5</span>);</span><br><span class="line">    ctx.<span class="title function_">bezierCurveTo</span>(<span class="number">130</span>, <span class="number">62.5</span>, <span class="number">130</span>, <span class="number">25</span>, <span class="number">100</span>, <span class="number">25</span>);</span><br><span class="line">    ctx.<span class="title function_">bezierCurveTo</span>(<span class="number">85</span>, <span class="number">25</span>, <span class="number">75</span>, <span class="number">37</span>, <span class="number">75</span>, <span class="number">40</span>);</span><br><span class="line">    ctx.<span class="title function_">fill</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://threejs-1251830808.cos.ap-guangzhou.myqcloud.com/1667122230252-a53a7ed2-b4bf-4c36-9f5b-2bd2ca783432.png" alt="img"></p><h3 id="-18"><a href="#-18" class="headerlink" title=" "></a> </h3><h3 id="组合使用"><a href="#组合使用" class="headerlink" title="组合使用"></a>组合使用</h3><p>目前为止，每一个例子中的每个图形都只用到一种类型的路径。然而，绘制一个图形并没有限制使用数量以及类型。所以在最后的一个例子里，让我们组合使用所有的路径函数来重现一款著名的游戏。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">draw</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> canvas = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;canvas&#x27;</span>);</span><br><span class="line">  <span class="keyword">if</span> (canvas.<span class="property">getContext</span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> ctx = canvas.<span class="title function_">getContext</span>(<span class="string">&#x27;2d&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="title function_">roundedRect</span>(ctx, <span class="number">12</span>, <span class="number">12</span>, <span class="number">150</span>, <span class="number">150</span>, <span class="number">15</span>);</span><br><span class="line">    <span class="title function_">roundedRect</span>(ctx, <span class="number">19</span>, <span class="number">19</span>, <span class="number">150</span>, <span class="number">150</span>, <span class="number">9</span>);</span><br><span class="line">    <span class="title function_">roundedRect</span>(ctx, <span class="number">53</span>, <span class="number">53</span>, <span class="number">49</span>, <span class="number">33</span>, <span class="number">10</span>);</span><br><span class="line">    <span class="title function_">roundedRect</span>(ctx, <span class="number">53</span>, <span class="number">119</span>, <span class="number">49</span>, <span class="number">16</span>, <span class="number">6</span>);</span><br><span class="line">    <span class="title function_">roundedRect</span>(ctx, <span class="number">135</span>, <span class="number">53</span>, <span class="number">49</span>, <span class="number">33</span>, <span class="number">10</span>);</span><br><span class="line">    <span class="title function_">roundedRect</span>(ctx, <span class="number">135</span>, <span class="number">119</span>, <span class="number">25</span>, <span class="number">49</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    ctx.<span class="title function_">beginPath</span>();</span><br><span class="line">    ctx.<span class="title function_">arc</span>(<span class="number">37</span>, <span class="number">37</span>, <span class="number">13</span>, <span class="title class_">Math</span>.<span class="property">PI</span> / <span class="number">7</span>, -<span class="title class_">Math</span>.<span class="property">PI</span> / <span class="number">7</span>, <span class="literal">false</span>);</span><br><span class="line">    ctx.<span class="title function_">lineTo</span>(<span class="number">31</span>, <span class="number">37</span>);</span><br><span class="line">    ctx.<span class="title function_">fill</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)&#123;</span><br><span class="line">      ctx.<span class="title function_">fillRect</span>(<span class="number">51</span> + i * <span class="number">16</span>, <span class="number">35</span>, <span class="number">4</span>, <span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++)&#123;</span><br><span class="line">      ctx.<span class="title function_">fillRect</span>(<span class="number">115</span>, <span class="number">51</span> + i * <span class="number">16</span>, <span class="number">4</span>, <span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)&#123;</span><br><span class="line">      ctx.<span class="title function_">fillRect</span>(<span class="number">51</span> + i * <span class="number">16</span>, <span class="number">99</span>, <span class="number">4</span>, <span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ctx.<span class="title function_">beginPath</span>();</span><br><span class="line">    ctx.<span class="title function_">moveTo</span>(<span class="number">83</span>, <span class="number">116</span>);</span><br><span class="line">    ctx.<span class="title function_">lineTo</span>(<span class="number">83</span>, <span class="number">102</span>);</span><br><span class="line">    ctx.<span class="title function_">bezierCurveTo</span>(<span class="number">83</span>, <span class="number">94</span>, <span class="number">89</span>, <span class="number">88</span>, <span class="number">97</span>, <span class="number">88</span>);</span><br><span class="line">    ctx.<span class="title function_">bezierCurveTo</span>(<span class="number">105</span>, <span class="number">88</span>, <span class="number">111</span>, <span class="number">94</span>, <span class="number">111</span>, <span class="number">102</span>);</span><br><span class="line">    ctx.<span class="title function_">lineTo</span>(<span class="number">111</span>, <span class="number">116</span>);</span><br><span class="line">    ctx.<span class="title function_">lineTo</span>(<span class="number">106.333</span>, <span class="number">111.333</span>);</span><br><span class="line">    ctx.<span class="title function_">lineTo</span>(<span class="number">101.666</span>, <span class="number">116</span>);</span><br><span class="line">    ctx.<span class="title function_">lineTo</span>(<span class="number">97</span>, <span class="number">111.333</span>);</span><br><span class="line">    ctx.<span class="title function_">lineTo</span>(<span class="number">92.333</span>, <span class="number">116</span>);</span><br><span class="line">    ctx.<span class="title function_">lineTo</span>(<span class="number">87.666</span>, <span class="number">111.333</span>);</span><br><span class="line">    ctx.<span class="title function_">lineTo</span>(<span class="number">83</span>, <span class="number">116</span>);</span><br><span class="line">    ctx.<span class="title function_">fill</span>();</span><br><span class="line"></span><br><span class="line">    ctx.<span class="property">fillStyle</span> = <span class="string">&quot;white&quot;</span>;</span><br><span class="line">    ctx.<span class="title function_">beginPath</span>();</span><br><span class="line">    ctx.<span class="title function_">moveTo</span>(<span class="number">91</span>, <span class="number">96</span>);</span><br><span class="line">    ctx.<span class="title function_">bezierCurveTo</span>(<span class="number">88</span>, <span class="number">96</span>, <span class="number">87</span>, <span class="number">99</span>, <span class="number">87</span>, <span class="number">101</span>);</span><br><span class="line">    ctx.<span class="title function_">bezierCurveTo</span>(<span class="number">87</span>, <span class="number">103</span>, <span class="number">88</span>, <span class="number">106</span>, <span class="number">91</span>, <span class="number">106</span>);</span><br><span class="line">    ctx.<span class="title function_">bezierCurveTo</span>(<span class="number">94</span>, <span class="number">106</span>, <span class="number">95</span>, <span class="number">103</span>, <span class="number">95</span>, <span class="number">101</span>);</span><br><span class="line">    ctx.<span class="title function_">bezierCurveTo</span>(<span class="number">95</span>, <span class="number">99</span>, <span class="number">94</span>, <span class="number">96</span>, <span class="number">91</span>, <span class="number">96</span>);</span><br><span class="line">    ctx.<span class="title function_">moveTo</span>(<span class="number">103</span>, <span class="number">96</span>);</span><br><span class="line">    ctx.<span class="title function_">bezierCurveTo</span>(<span class="number">100</span>, <span class="number">96</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">101</span>);</span><br><span class="line">    ctx.<span class="title function_">bezierCurveTo</span>(<span class="number">99</span>, <span class="number">103</span>, <span class="number">100</span>, <span class="number">106</span>, <span class="number">103</span>, <span class="number">106</span>);</span><br><span class="line">    ctx.<span class="title function_">bezierCurveTo</span>(<span class="number">106</span>, <span class="number">106</span>, <span class="number">107</span>, <span class="number">103</span>, <span class="number">107</span>, <span class="number">101</span>);</span><br><span class="line">    ctx.<span class="title function_">bezierCurveTo</span>(<span class="number">107</span>, <span class="number">99</span>, <span class="number">106</span>, <span class="number">96</span>, <span class="number">103</span>, <span class="number">96</span>);</span><br><span class="line">    ctx.<span class="title function_">fill</span>();</span><br><span class="line"></span><br><span class="line">    ctx.<span class="property">fillStyle</span> = <span class="string">&quot;black&quot;</span>;</span><br><span class="line">    ctx.<span class="title function_">beginPath</span>();</span><br><span class="line">    ctx.<span class="title function_">arc</span>(<span class="number">101</span>, <span class="number">102</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="title class_">Math</span>.<span class="property">PI</span> * <span class="number">2</span>, <span class="literal">true</span>);</span><br><span class="line">    ctx.<span class="title function_">fill</span>();</span><br><span class="line"></span><br><span class="line">    ctx.<span class="title function_">beginPath</span>();</span><br><span class="line">    ctx.<span class="title function_">arc</span>(<span class="number">89</span>, <span class="number">102</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="title class_">Math</span>.<span class="property">PI</span> * <span class="number">2</span>, <span class="literal">true</span>);</span><br><span class="line">    ctx.<span class="title function_">fill</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 封装的一个用于绘制圆角矩形的函数。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">roundedRect</span>(<span class="params">ctx, x, y, width, height, radius</span>)&#123;</span><br><span class="line">  ctx.<span class="title function_">beginPath</span>();</span><br><span class="line">  ctx.<span class="title function_">moveTo</span>(x, y + radius);</span><br><span class="line">  ctx.<span class="title function_">lineTo</span>(x, y + height - radius);</span><br><span class="line">  ctx.<span class="title function_">quadraticCurveTo</span>(x, y + height, x + radius, y + height);</span><br><span class="line">  ctx.<span class="title function_">lineTo</span>(x + width - radius, y + height);</span><br><span class="line">  ctx.<span class="title function_">quadraticCurveTo</span>(x + width, y + height, x + width, y + height - radius);</span><br><span class="line">  ctx.<span class="title function_">lineTo</span>(x + width, y + radius);</span><br><span class="line">  ctx.<span class="title function_">quadraticCurveTo</span>(x + width, y, x + width - radius, y);</span><br><span class="line">  ctx.<span class="title function_">lineTo</span>(x + radius, y);</span><br><span class="line">  ctx.<span class="title function_">quadraticCurveTo</span>(x, y, x, y + radius);</span><br><span class="line">  ctx.<span class="title function_">stroke</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们不会很详细地讲解上面的代码，因为事实上这很容易理解。重点是绘制上下文中使用到了 fillStyle 属性，以及封装函数（例子中的roundedRect()）。使用封装函数对于减少代码量以及复杂度十分有用。</p><p>在稍后的课程里，我们会讨论fillStyle样式的更多细节。这章节中，我们对fillStyle样式所做的仅是改变填充颜色，由默认的黑色到白色，然后又是黑色。</p><h2 id="-19"><a href="#-19" class="headerlink" title=" "></a> </h2><h2 id="Path2D-对象"><a href="#Path2D-对象" class="headerlink" title="Path2D 对象"></a>Path2D 对象</h2><p>正如我们在前面例子中看到的，你可以使用一系列的路径和绘画命令来把对象“画”在画布上。为了简化代码和提高性能，Path2D对象已可以在较新版本的浏览器中使用，用来缓存或记录绘画命令，这样你将能快速地回顾路径。</p><p>怎样产生一个 Path2D 对象呢？</p><p>Path2D()</p><p>Path2D()会返回一个新初始化的 Path2D 对象（可能将某一个路径作为变量——创建一个它的副本，或者将一个包含 SVG path 数据的字符串作为变量）。</p><p>所有的路径方法比如moveTo, rect, arc或quadraticCurveTo等，如我们前面见过的，都可以在 Path2D 中使用。</p><p>Path2D API 添加了 addPath作为将path结合起来的方法。当你想要从几个元素中来创建对象时，这将会很实用。比如：</p><p>Path2D.addPath(path [, transform])</p><p>添加了一条路径到当前路径（可能添加了一个变换矩阵）。</p><h3 id="-20"><a href="#-20" class="headerlink" title=" "></a> </h3><h3 id="Path2D-示例"><a href="#Path2D-示例" class="headerlink" title="Path2D 示例"></a>Path2D 示例</h3><p>在这个例子中，我们创造了一个矩形和一个圆。它们都被存为 Path2D 对象，后面再派上用场。随着新的 Path2D API 产生，几种方法也相应地被更新来使用 Path2D  对象而不是当前路径。在这里，带路径参数的stroke和fill可以把对象画在画布上。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">draw</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> canvas = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;canvas&#x27;</span>);</span><br><span class="line">  <span class="keyword">if</span> (canvas.<span class="property">getContext</span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> ctx = canvas.<span class="title function_">getContext</span>(<span class="string">&#x27;2d&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> rectangle = <span class="keyword">new</span> <span class="title class_">Path2D</span>();</span><br><span class="line">    rectangle.<span class="title function_">rect</span>(<span class="number">10</span>, <span class="number">10</span>, <span class="number">50</span>, <span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> circle = <span class="keyword">new</span> <span class="title class_">Path2D</span>();</span><br><span class="line">    circle.<span class="title function_">moveTo</span>(<span class="number">125</span>, <span class="number">35</span>);</span><br><span class="line">    circle.<span class="title function_">arc</span>(<span class="number">100</span>, <span class="number">35</span>, <span class="number">25</span>, <span class="number">0</span>, <span class="number">2</span> * <span class="title class_">Math</span>.<span class="property">PI</span>);</span><br><span class="line"></span><br><span class="line">    ctx.<span class="title function_">stroke</span>(rectangle);</span><br><span class="line">    ctx.<span class="title function_">fill</span>(circle);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://threejs-1251830808.cos.ap-guangzhou.myqcloud.com/1667122399198-5dbffae0-64b1-4130-912a-dfef2786941e.png" alt="img"></p><h3 id="-21"><a href="#-21" class="headerlink" title=" "></a> </h3><h3 id="使用-SVG-paths"><a href="#使用-SVG-paths" class="headerlink" title="使用 SVG paths"></a>使用 SVG paths</h3><p>新的 Path2D API 有另一个强大的特点，就是使用 SVG path data 来初始化 canvas 上的路径。这将使你获取路径时可以以 SVG 或 canvas 的方式来重用它们。</p><p>这条路径将先移动到点 (M10 10) 然后再水平移动 80 个单位(h 80)，然后下移 80 个单位 (v 80)，接着左移 80 个单位 (h -80)，再回到起点处 (z)。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="title class_">Path2D</span>(<span class="string">&quot;M10 10 h 80 v 80 h -80 Z&quot;</span>);</span><br></pre></td></tr></table></figure><h1 id="02-样式和颜色控制"><a href="#02-样式和颜色控制" class="headerlink" title="02-样式和颜色控制"></a>02-样式和颜色控制</h1><p>在绘制图形的章节里，我只用到默认的线条和填充样式。而在这一章里，我们将会探讨 canvas 全部的可选项，来绘制出更加吸引人的内容。</p><p><img src="https://threejs-1251830808.cos.ap-guangzhou.myqcloud.com/1667177252309-650341b3-390e-4dc9-a092-d365f7d575bf.png" alt="img"></p><h2 id="-22"><a href="#-22" class="headerlink" title=" "></a> </h2><h2 id="色彩-Colors"><a href="#色彩-Colors" class="headerlink" title="色彩 Colors"></a>色彩 Colors</h2><p>到目前为止，我们只看到过绘制内容的方法。如果我们想要给图形上色，有两个重要的属性可以做到：fillStyle 和 strokeStyle。</p><p>fillStyle = color</p><p>设置图形的填充颜色。</p><p>strokeStyle = color</p><p>设置图形轮廓的颜色。</p><p>color 可以是表示 CSS 颜色值的字符串，渐变对象或者图案对象。我们迟些再回头探讨渐变和图案对象。默认情况下，线条和填充颜色都是黑色（CSS 颜色值 #000000）。</p><p><strong>备注：</strong> 一旦您设置了 strokeStyle 或者 fillStyle 的值，那么这个新值就会成为新绘制的图形的默认值。如果你要给每个图形上不同的颜色，你需要重新设置 fillStyle 或 strokeStyle 的值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这些 fillStyle 的值均为 &#x27;橙色&#x27;</span></span><br><span class="line">ctx.<span class="property">fillStyle</span> = <span class="string">&quot;orange&quot;</span>;</span><br><span class="line">ctx.<span class="property">fillStyle</span> = <span class="string">&quot;#FFA500&quot;</span>;</span><br><span class="line">ctx.<span class="property">fillStyle</span> = <span class="string">&quot;rgb(255,165,0)&quot;</span>;</span><br><span class="line">ctx.<span class="property">fillStyle</span> = <span class="string">&quot;rgba(255,165,0,1)&quot;</span>;</span><br></pre></td></tr></table></figure><h3 id="fillStyle示例"><a href="#fillStyle示例" class="headerlink" title="fillStyle示例"></a>fillStyle示例</h3><p>在本示例里，我会再度用两层 for 循环来绘制方格阵列，每个方格不同的颜色。结果如右图，但实现所用的代码却没那么绚丽。我用了两个变量 i 和 j 来为每一个方格产生唯一的 RGB  色彩值，其中仅修改红色和绿色通道的值，而保持蓝色通道的值不变。你可以通过修改这些颜色通道的值来产生各种各样的色板。通过增加渐变的频率，你还可以绘制出类似 Photoshop 里面的那样的调色板。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">draw</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> ctx = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;canvas&#x27;</span>).<span class="title function_">getContext</span>(<span class="string">&#x27;2d&#x27;</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">6</span>;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> j=<span class="number">0</span>;j&lt;<span class="number">6</span>;j++)&#123;</span><br><span class="line">      ctx.<span class="property">fillStyle</span> = <span class="string">&#x27;rgb(&#x27;</span> + <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="number">255</span>-<span class="number">42.5</span>*i) + <span class="string">&#x27;,&#x27;</span> +</span><br><span class="line">                       <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="number">255</span>-<span class="number">42.5</span>*j) + <span class="string">&#x27;,0)&#x27;</span>;</span><br><span class="line">      ctx.<span class="title function_">fillRect</span>(j*<span class="number">25</span>,i*<span class="number">25</span>,<span class="number">25</span>,<span class="number">25</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="strokeStyle示例"><a href="#strokeStyle示例" class="headerlink" title="strokeStyle示例"></a>strokeStyle示例</h3><p>这个示例与上面的有点类似，但这次用到的是 strokeStyle 属性，画的不是方格，而是用 arc 方法来画圆。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">draw</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> ctx = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;canvas&#x27;</span>).<span class="title function_">getContext</span>(<span class="string">&#x27;2d&#x27;</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">6</span>;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> j=<span class="number">0</span>;j&lt;<span class="number">6</span>;j++)&#123;</span><br><span class="line">      ctx.<span class="property">strokeStyle</span> = <span class="string">&#x27;rgb(0,&#x27;</span> + <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="number">255</span>-<span class="number">42.5</span>*i) + <span class="string">&#x27;,&#x27;</span> +</span><br><span class="line">                       <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="number">255</span>-<span class="number">42.5</span>*j) + <span class="string">&#x27;)&#x27;</span>;</span><br><span class="line">      ctx.<span class="title function_">beginPath</span>();</span><br><span class="line">      ctx.<span class="title function_">arc</span>(<span class="number">12.5</span>+j*<span class="number">25</span>,<span class="number">12.5</span>+i*<span class="number">25</span>,<span class="number">10</span>,<span class="number">0</span>,<span class="title class_">Math</span>.<span class="property">PI</span>*<span class="number">2</span>,<span class="literal">true</span>);</span><br><span class="line">      ctx.<span class="title function_">stroke</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="透明度-Transparency"><a href="#透明度-Transparency" class="headerlink" title="透明度 Transparency"></a>透明度 Transparency</h2><p>除了可以绘制实色图形，我们还可以用 canvas 来绘制半透明的图形。通过设置 globalAlpha 属性或者使用一个半透明颜色作为轮廓或填充的样式。</p><p>globalAlpha = transparencyValue</p><p>这个属性影响到 canvas 里所有图形的透明度，有效的值范围是 0.0（完全透明）到 1.0（完全不透明），默认是 1.0。</p><p>globalAlpha 属性在需要绘制大量拥有相同透明度的图形时候相当高效。不过，我认为下面的方法可操作性更强一点。</p><p>因为 strokeStyle 和 fillStyle 属性接受符合 CSS 3 规范的颜色值，那我们可以用下面的写法来设置具有透明度的颜色。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 指定透明颜色，用于描边和填充样式</span></span><br><span class="line">ctx.<span class="property">strokeStyle</span> = <span class="string">&quot;rgba(255,0,0,0.5)&quot;</span>;</span><br><span class="line">ctx.<span class="property">fillStyle</span> = <span class="string">&quot;rgba(255,0,0,0.5)&quot;</span>;</span><br></pre></td></tr></table></figure><p>rgba() 方法与 rgb() 方法类似，就多了一个用于设置色彩透明度的参数。它的有效范围是从 0.0（完全透明）到 1.0（完全不透明）。</p><h3 id="-23"><a href="#-23" class="headerlink" title=" "></a> </h3><h3 id="globalAlpha示例"><a href="#globalAlpha示例" class="headerlink" title="globalAlpha示例"></a>globalAlpha示例</h3><p>在这个例子里，将用四色格作为背景，设置 globalAlpha 为 0.2  后，在上面画一系列半径递增的半透明圆。最终结果是一个径向渐变效果。圆叠加得越更多，原先所画的圆的透明度会越低。通过增加循环次数，画更多的圆，从中心到边缘部分，背景图会呈现逐渐消失的效果。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">draw</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> ctx = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;canvas&#x27;</span>).<span class="title function_">getContext</span>(<span class="string">&#x27;2d&#x27;</span>);</span><br><span class="line">  <span class="comment">// 画背景</span></span><br><span class="line">  ctx.<span class="property">fillStyle</span> = <span class="string">&#x27;#FD0&#x27;</span>;</span><br><span class="line">  ctx.<span class="title function_">fillRect</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">75</span>,<span class="number">75</span>);</span><br><span class="line">  ctx.<span class="property">fillStyle</span> = <span class="string">&#x27;#6C0&#x27;</span>;</span><br><span class="line">  ctx.<span class="title function_">fillRect</span>(<span class="number">75</span>,<span class="number">0</span>,<span class="number">75</span>,<span class="number">75</span>);</span><br><span class="line">  ctx.<span class="property">fillStyle</span> = <span class="string">&#x27;#09F&#x27;</span>;</span><br><span class="line">  ctx.<span class="title function_">fillRect</span>(<span class="number">0</span>,<span class="number">75</span>,<span class="number">75</span>,<span class="number">75</span>);</span><br><span class="line">  ctx.<span class="property">fillStyle</span> = <span class="string">&#x27;#F30&#x27;</span>;</span><br><span class="line">  ctx.<span class="title function_">fillRect</span>(<span class="number">75</span>,<span class="number">75</span>,<span class="number">75</span>,<span class="number">75</span>);</span><br><span class="line">  ctx.<span class="property">fillStyle</span> = <span class="string">&#x27;#FFF&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置透明度值</span></span><br><span class="line">  ctx.<span class="property">globalAlpha</span> = <span class="number">0.2</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 画半透明圆</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">7</span>;i++)&#123;</span><br><span class="line">      ctx.<span class="title function_">beginPath</span>();</span><br><span class="line">      ctx.<span class="title function_">arc</span>(<span class="number">75</span>,<span class="number">75</span>,<span class="number">10</span>+<span class="number">10</span>*i,<span class="number">0</span>,<span class="title class_">Math</span>.<span class="property">PI</span>*<span class="number">2</span>,<span class="literal">true</span>);</span><br><span class="line">      ctx.<span class="title function_">fill</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://threejs-1251830808.cos.ap-guangzhou.myqcloud.com/1667122746594-d65213b9-8b1b-4bc1-9bde-9d949af11d8d.png" alt="img"></p><h3 id="-24"><a href="#-24" class="headerlink" title=" "></a> </h3><h3 id="rgba-示例"><a href="#rgba-示例" class="headerlink" title="rgba()示例"></a>rgba()示例</h3><p>第二个例子和上面那个类似，不过不是画圆，而是画矩形。这里还可以看出，rgba() 可以分别设置轮廓和填充样式，因而具有更好的可操作性和使用灵活性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">draw</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> ctx = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;canvas&#x27;</span>).<span class="title function_">getContext</span>(<span class="string">&#x27;2d&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 画背景</span></span><br><span class="line">  ctx.<span class="property">fillStyle</span> = <span class="string">&#x27;rgb(255,221,0)&#x27;</span>;</span><br><span class="line">  ctx.<span class="title function_">fillRect</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">150</span>,<span class="number">37.5</span>);</span><br><span class="line">  ctx.<span class="property">fillStyle</span> = <span class="string">&#x27;rgb(102,204,0)&#x27;</span>;</span><br><span class="line">  ctx.<span class="title function_">fillRect</span>(<span class="number">0</span>,<span class="number">37.5</span>,<span class="number">150</span>,<span class="number">37.5</span>);</span><br><span class="line">  ctx.<span class="property">fillStyle</span> = <span class="string">&#x27;rgb(0,153,255)&#x27;</span>;</span><br><span class="line">  ctx.<span class="title function_">fillRect</span>(<span class="number">0</span>,<span class="number">75</span>,<span class="number">150</span>,<span class="number">37.5</span>);</span><br><span class="line">  ctx.<span class="property">fillStyle</span> = <span class="string">&#x27;rgb(255,51,0)&#x27;</span>;</span><br><span class="line">  ctx.<span class="title function_">fillRect</span>(<span class="number">0</span>,<span class="number">112.5</span>,<span class="number">150</span>,<span class="number">37.5</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 画半透明矩形</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">    ctx.<span class="property">fillStyle</span> = <span class="string">&#x27;rgba(255,255,255,&#x27;</span>+(i+<span class="number">1</span>)/<span class="number">10</span>+<span class="string">&#x27;)&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> j=<span class="number">0</span>;j&lt;<span class="number">4</span>;j++)&#123;</span><br><span class="line">      ctx.<span class="title function_">fillRect</span>(<span class="number">5</span>+i*<span class="number">14</span>,<span class="number">5</span>+j*<span class="number">37.5</span>,<span class="number">14</span>,<span class="number">27.5</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://threejs-1251830808.cos.ap-guangzhou.myqcloud.com/1667122772053-b4534f0f-3286-4e1a-a7ba-5344a6e39e80.png" alt="img"></p><h2 id="-25"><a href="#-25" class="headerlink" title=" "></a> </h2><h2 id="线型-Line-styles"><a href="#线型-Line-styles" class="headerlink" title="线型 Line styles"></a>线型 Line styles</h2><p>可以通过一系列属性来设置线的样式。</p><p>lineWidth = value</p><p>设置线条宽度。</p><p>lineCap = type</p><p>设置线条末端样式。</p><p>lineJoin = type</p><p>设定线条与线条间接合处的样式。</p><p>miterLimit = value</p><p>限制当两条线相交时交接处最大长度；所谓交接处长度（斜接长度）是指线条交接处内角顶点到外角顶点的长度。</p><p>getLineDash()</p><p>返回一个包含当前虚线样式，长度为非负偶数的数组。</p><p>setLineDash(segments)</p><p>设置当前虚线样式。</p><p>lineDashOffset = value</p><p>设置虚线样式的起始偏移量。</p><p>通过以下的样例可能会更加容易理解。</p><h4 id="-26"><a href="#-26" class="headerlink" title=" "></a> </h4><h4 id="lineWidth-属性的例子"><a href="#lineWidth-属性的例子" class="headerlink" title="lineWidth 属性的例子"></a>lineWidth 属性的例子</h4><p>这个属性设置当前绘线的粗细。属性值必须为正数。默认值是 1.0。</p><p>线宽是指给定路径的中心到两边的粗细。换句话说就是在路径的两边各绘制线宽的一半。因为画布的坐标并不和像素直接对应，当需要获得精确的水平或垂直线的时候要特别注意。</p><p>在下面的例子中，用递增的宽度绘制了 10 条直线。最左边的线宽 1.0 单位。并且，最左边的以及所有宽度为奇数的线并不能精确呈现，这就是因为路径的定位问题。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">draw</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> ctx = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;canvas&#x27;</span>).<span class="title function_">getContext</span>(<span class="string">&#x27;2d&#x27;</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">    ctx.<span class="property">lineWidth</span> = <span class="number">1</span>+i;</span><br><span class="line">    ctx.<span class="title function_">beginPath</span>();</span><br><span class="line">    ctx.<span class="title function_">moveTo</span>(<span class="number">5</span>+i*<span class="number">14</span>,<span class="number">5</span>);</span><br><span class="line">    ctx.<span class="title function_">lineTo</span>(<span class="number">5</span>+i*<span class="number">14</span>,<span class="number">140</span>);</span><br><span class="line">    ctx.<span class="title function_">stroke</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>想要获得精确的线条，必须对线条是如何描绘出来的有所理解。见下图，用网格来代表 canvas 的坐标格，每一格对应屏幕上一个像素点。在第一个图中，填充了 (2,1) 至 (5,5)  的矩形，整个区域的边界刚好落在像素边缘上，这样就可以得到的矩形有着清晰的边缘。</p><p><img src="https://threejs-1251830808.cos.ap-guangzhou.myqcloud.com/1667122831821-f281e51b-8d1d-4a15-ae4b-3c79a4361e28.png" alt="img"></p><p>如果你想要绘制一条从 (3,1) 到 (3,5)，宽度是 1.0  的线条，你会得到像第二幅图一样的结果。实际填充区域（深蓝色部分）仅仅延伸至路径两旁各一半像素。而这半个像素又会以近似的方式进行渲染，这意味着那些像素只是部分着色，结果就是以实际笔触颜色一半色调的颜色来填充整个区域（浅蓝和深蓝的部分）。这就是上例中为何宽度为 1.0 的线并不准确的原因。</p><p>要解决这个问题，你必须对路径施以更加精确的控制。已知粗 1.0 的线条会在路径两边各延伸半像素，那么像第三幅图那样绘制从 (3.5,1) 到 (3.5,5) 的线条，其边缘正好落在像素边界，填充出来就是准确的宽为 1.0 的线条。</p><p><strong>备注：</strong> 在这个竖线的例子中，其 Y 坐标刚好落在网格线上，否则端点上同样会出现半渲染的像素点（但还要注意，这种行为的表现取决于当前的 lineCap  风格，它默认为 butt；您可能希望通过将 lineCap 样式设置为 square  正方形，来得到与奇数宽度线的半像素坐标相一致的笔画，这样，端点轮廓的外边框将被自动扩展以完全覆盖整个像素格）。</p><p>还请注意，只有路径的起点和终点受此影响：如果一个路径是通过 closePath() 来封闭的，它是没有起点和终点的；相反的情况下，路径上的所有端点都与上一个点相连，下一段路径使用当前的 lineJoin 设置（默认为  miter），如果相连路径是水平和/或垂直的话，会导致相连路径的外轮廓根据相交点自动延伸，因此渲染出的路径轮廓会覆盖整个像素格。接下来的两个小节将展示这些额外的行样式。</p><p>对于那些宽度为偶数的线条，每一边的像素数都是整数，那么你想要其路径是落在像素点之间 (如那从 (3,1) 到 (3,5)) 而不是在像素点的中间。同样，注意到那个例子的垂直线条，其 Y 坐标刚好落在网格线上，如果不是的话，端点上同样会出现半渲染的像素点。</p><p>虽然开始处理可缩放的 2D 图形时会有点小痛苦，但是及早注意到像素网格与路径位置之间的关系，可以确保图形在经过缩放或者其它任何变形后都可以保持看上去蛮好：线宽为 1.0 的垂线在放大 2 倍后，会变成清晰的线宽为 2.0，并且出现在它应该出现的位置上。</p><h4 id="-27"><a href="#-27" class="headerlink" title=" "></a> </h4><h4 id="lineCap-属性的例子"><a href="#lineCap-属性的例子" class="headerlink" title="lineCap 属性的例子"></a>lineCap 属性的例子</h4><p>属性 lineCap 的值决定了线段端点显示的样子。它可以为下面的三种的其中之一：butt，round 和 square。默认是 butt。</p><p>在这个例子里面，我绘制了三条直线，分别赋予不同的 lineCap 值。还有两条辅助线，为了可以看得更清楚它们之间的区别，三条线的起点终点都落在辅助线上。</p><p>最左边的线用了默认的 butt 。可以注意到它是与辅助线齐平的。中间的是 round 的效果，端点处加上了半径为一半线宽的半圆。右边的是 square 的效果，端点处加上了等宽且高度为一半线宽的方块。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">draw</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> ctx = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;canvas&#x27;</span>).<span class="title function_">getContext</span>(<span class="string">&#x27;2d&#x27;</span>);</span><br><span class="line">  <span class="keyword">var</span> lineCap = [<span class="string">&#x27;butt&#x27;</span>,<span class="string">&#x27;round&#x27;</span>,<span class="string">&#x27;square&#x27;</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建路径</span></span><br><span class="line">  ctx.<span class="property">strokeStyle</span> = <span class="string">&#x27;#09f&#x27;</span>;</span><br><span class="line">  ctx.<span class="title function_">beginPath</span>();</span><br><span class="line">  ctx.<span class="title function_">moveTo</span>(<span class="number">10</span>,<span class="number">10</span>);</span><br><span class="line">  ctx.<span class="title function_">lineTo</span>(<span class="number">140</span>,<span class="number">10</span>);</span><br><span class="line">  ctx.<span class="title function_">moveTo</span>(<span class="number">10</span>,<span class="number">140</span>);</span><br><span class="line">  ctx.<span class="title function_">lineTo</span>(<span class="number">140</span>,<span class="number">140</span>);</span><br><span class="line">  ctx.<span class="title function_">stroke</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 画线条</span></span><br><span class="line">  ctx.<span class="property">strokeStyle</span> = <span class="string">&#x27;black&#x27;</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;lineCap.<span class="property">length</span>;i++)&#123;</span><br><span class="line">    ctx.<span class="property">lineWidth</span> = <span class="number">15</span>;</span><br><span class="line">    ctx.<span class="property">lineCap</span> = lineCap[i];</span><br><span class="line">    ctx.<span class="title function_">beginPath</span>();</span><br><span class="line">    ctx.<span class="title function_">moveTo</span>(<span class="number">25</span>+i*<span class="number">50</span>,<span class="number">10</span>);</span><br><span class="line">    ctx.<span class="title function_">lineTo</span>(<span class="number">25</span>+i*<span class="number">50</span>,<span class="number">140</span>);</span><br><span class="line">    ctx.<span class="title function_">stroke</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://threejs-1251830808.cos.ap-guangzhou.myqcloud.com/1667122878490-b77352b0-f09d-4fbd-bfe8-f484d398dc37.png" alt="img"></p><h4 id="-28"><a href="#-28" class="headerlink" title=" "></a> </h4><h4 id="lineJoin-属性的例子"><a href="#lineJoin-属性的例子" class="headerlink" title="lineJoin 属性的例子"></a>lineJoin 属性的例子</h4><p>lineJoin 的属性值决定了图形中两线段连接处所显示的样子。它可以是这三种之一：round, bevel 和 miter。默认是 miter。</p><p>这里我同样用三条折线来做例子，分别设置不同的 lineJoin 值。最上面一条是 round 的效果，边角处被磨圆了，圆的半径等于线宽。中间和最下面一条分别是 bevel 和 miter  的效果。当值是 miter 的时候，线段会在连接处外侧延伸直至交于一点，延伸效果受到下面将要介绍的 miterLimit 属性的制约。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">draw</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> ctx = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;canvas&#x27;</span>).<span class="title function_">getContext</span>(<span class="string">&#x27;2d&#x27;</span>);</span><br><span class="line">  <span class="keyword">var</span> lineJoin = [<span class="string">&#x27;round&#x27;</span>, <span class="string">&#x27;bevel&#x27;</span>, <span class="string">&#x27;miter&#x27;</span>];</span><br><span class="line">  ctx.<span class="property">lineWidth</span> = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; lineJoin.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    ctx.<span class="property">lineJoin</span> = lineJoin[i];</span><br><span class="line">    ctx.<span class="title function_">beginPath</span>();</span><br><span class="line">    ctx.<span class="title function_">moveTo</span>(-<span class="number">5</span>, <span class="number">5</span> + i * <span class="number">40</span>);</span><br><span class="line">    ctx.<span class="title function_">lineTo</span>(<span class="number">35</span>, <span class="number">45</span> + i * <span class="number">40</span>);</span><br><span class="line">    ctx.<span class="title function_">lineTo</span>(<span class="number">75</span>, <span class="number">5</span> + i * <span class="number">40</span>);</span><br><span class="line">    ctx.<span class="title function_">lineTo</span>(<span class="number">115</span>, <span class="number">45</span> + i * <span class="number">40</span>);</span><br><span class="line">    ctx.<span class="title function_">lineTo</span>(<span class="number">155</span>, <span class="number">5</span> + i * <span class="number">40</span>);</span><br><span class="line">    ctx.<span class="title function_">stroke</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://threejs-1251830808.cos.ap-guangzhou.myqcloud.com/1667122903925-6f71a245-1bda-42fa-aebe-e89231b401fd.png" alt="img"></p><h4 id="-29"><a href="#-29" class="headerlink" title=" "></a> </h4><h4 id="miterLimit-属性的演示例子"><a href="#miterLimit-属性的演示例子" class="headerlink" title="miterLimit 属性的演示例子"></a>miterLimit 属性的演示例子</h4><p><img src="https://threejs-1251830808.cos.ap-guangzhou.myqcloud.com/1667192776029-37cc94ac-d0b6-4fd1-b771-e164cb2ad533.png" alt="img"></p><p>就如上一个例子所见的应用 miter 的效果，线段的外侧边缘会被延伸交汇于一点上。线段之间夹角比较大时，交点不会太远，但随着夹角变小，交点距离会呈指数级增大。</p><p>miterLimit 属性就是用来设定外延交点与连接点的最大距离，如果交点距离大于此值，连接效果会变成了  bevel。注意，最大斜接长度（即交点距离）是当前坐标系测量线宽与此miterLimit属性值（HTML canvas默认为  10.0）的乘积，所以miterLimit可以单独设置，不受显示比例改变或任何仿射变换的影响：它只影响线条边缘的有效绘制形状。</p><p>更准确的说，斜接限定值（miterLimit）是延伸长度（在 HTML Canvas  中，这个值是线段外连接点与路径中指定的点之间的距离）与一半线宽的最大允许比值。它也可以被等效定义为线条内外连接点距离（miterLength）与线宽（lineWidth）的最大允许比值（因为路径点是内外连接点的中点）。这等同于相交线段最小内夹角（<em>θ</em>）的一半的余割值，小于此角度的斜接将不会被渲染，而仅渲染斜边连接：</p><ul><li>miterLimit = <strong>max</strong> miterLength / lineWidth = 1 / <strong>sin</strong> ( <strong>min</strong> <em>θ</em> / 2 )</li><li>斜接限定值默认为 10.0，这将会去除所有小于大约 11 度的斜接。</li><li>斜接限定值为 √2 ≈ 1.4142136（四舍五入）时，将去除所有锐角的斜接，仅保留钝角或直角。</li><li>1.0 是合法的斜接限定值，但这会去除所有斜接。</li><li>小于 1.0 的值不是合法的斜接限定值。</li></ul><p>在下面的小示例中，您可以动态的设置miterLimit的值并查看它对画布中图形的影响。蓝色线条指出了锯齿图案中每个线条的起点与终点（同时也是不同线段之间的连接点）。</p><p>在此示例中，当您设定miterLimit的值小于 4.2 时，图形可见部分的边角不会延伸相交，而是在蓝色线条边呈现斜边连接效果；当miterLimit的值大于 10.0  时，此例中大部分的边角都会在远离蓝线的位置相交，且从左至右，距离随着夹角的增大而减小；而介于上述值之间的值所呈现的效果，也介于两者之间。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">draw</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> ctx = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;canvas&#x27;</span>).<span class="title function_">getContext</span>(<span class="string">&#x27;2d&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 清空画布</span></span><br><span class="line">  ctx.<span class="title function_">clearRect</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">150</span>, <span class="number">150</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 绘制参考线</span></span><br><span class="line">  ctx.<span class="property">strokeStyle</span> = <span class="string">&#x27;#09f&#x27;</span>;</span><br><span class="line">  ctx.<span class="property">lineWidth</span>   = <span class="number">2</span>;</span><br><span class="line">  ctx.<span class="title function_">strokeRect</span>(-<span class="number">5</span>, <span class="number">50</span>, <span class="number">160</span>, <span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置线条样式</span></span><br><span class="line">  ctx.<span class="property">strokeStyle</span> = <span class="string">&#x27;#000&#x27;</span>;</span><br><span class="line">  ctx.<span class="property">lineWidth</span> = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 检查输入</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;miterLimit&#x27;</span>).<span class="property">value</span>.<span class="title function_">match</span>(<span class="regexp">/\d+(\.\d+)?/</span>)) &#123;</span><br><span class="line">    ctx.<span class="property">miterLimit</span> = <span class="built_in">parseFloat</span>(<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;miterLimit&#x27;</span>).<span class="property">value</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">&#x27;Value must be a positive number&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 绘制线条</span></span><br><span class="line">  ctx.<span class="title function_">beginPath</span>();</span><br><span class="line">  ctx.<span class="title function_">moveTo</span>(<span class="number">0</span>, <span class="number">100</span>);</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">24</span> ; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> dy = i % <span class="number">2</span> == <span class="number">0</span> ? <span class="number">25</span> : -<span class="number">25</span>;</span><br><span class="line">    ctx.<span class="title function_">lineTo</span>(<span class="title class_">Math</span>.<span class="title function_">pow</span>(i, <span class="number">1.5</span>) * <span class="number">2</span>, <span class="number">75</span> + dy);</span><br><span class="line">  &#125;</span><br><span class="line">  ctx.<span class="title function_">stroke</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://threejs-1251830808.cos.ap-guangzhou.myqcloud.com/1667122934008-8d3b6d21-d2f8-4f14-8524-b924eac4cbc4.png" alt="img"></p><h2 id="-30"><a href="#-30" class="headerlink" title=" "></a> </h2><h2 id="使用虚线"><a href="#使用虚线" class="headerlink" title="使用虚线"></a>使用虚线</h2><p>用 setLineDash 方法和 lineDashOffset 属性来制定虚线样式。setLineDash 方法接受一个数组，来指定线段与间隙的交替；lineDashOffset 属性设置起始偏移量。</p><p>在这个例子中，我们要创建一个蚂蚁线的效果。它往往应用在计算机图形程序选区工具动效中。它可以帮助用户通过动画的边界来区分图像背景选区边框。在本教程的后面部分，你可以学习如何实现这一点和其他基本的动画。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ctx = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;canvas&#x27;</span>).<span class="title function_">getContext</span>(<span class="string">&#x27;2d&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> offset = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">draw</span>(<span class="params"></span>) &#123;</span><br><span class="line">  ctx.<span class="title function_">clearRect</span>(<span class="number">0</span>,<span class="number">0</span>, canvas.<span class="property">width</span>, canvas.<span class="property">height</span>);</span><br><span class="line">  ctx.<span class="title function_">setLineDash</span>([<span class="number">4</span>, <span class="number">2</span>]);</span><br><span class="line">  ctx.<span class="property">lineDashOffset</span> = -offset;</span><br><span class="line">  ctx.<span class="title function_">strokeRect</span>(<span class="number">10</span>,<span class="number">10</span>, <span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">march</span>(<span class="params"></span>) &#123;</span><br><span class="line">  offset++;</span><br><span class="line">  <span class="keyword">if</span> (offset &gt; <span class="number">16</span>) &#123;</span><br><span class="line">    offset = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">draw</span>();</span><br><span class="line">  <span class="built_in">setTimeout</span>(march, <span class="number">20</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">march</span>();</span><br></pre></td></tr></table></figure><p><img src="https://threejs-1251830808.cos.ap-guangzhou.myqcloud.com/1667122956661-62d2ca82-a024-4450-8b17-a576295960c0.png" alt="img"></p><h2 id="-31"><a href="#-31" class="headerlink" title=" "></a> </h2><h2 id="渐变-Gradients"><a href="#渐变-Gradients" class="headerlink" title="渐变 Gradients"></a>渐变 Gradients</h2><p>就好像一般的绘图软件一样，我们可以用线性或者径向的渐变来填充或描边。我们用下面的方法新建一个 canvasGradient 对象，并且赋给图形的 fillStyle 或 strokeStyle 属性。</p><p>createLinearGradient(x1, y1, x2, y2)</p><p>createLinearGradient 方法接受 4 个参数，表示渐变的起点 (x1,y1) 与终点 (x2,y2)。</p><p>createRadialGradient(x1, y1, r1, x2, y2, r2)</p><p>createRadialGradient 方法接受 6 个参数，前三个定义一个以 (x1,y1) 为原点，半径为 r1 的圆，后三个参数则定义另一个以 (x2,y2) 为原点，半径为 r2 的圆。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> lineargradient = ctx.<span class="title function_">createLinearGradient</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">150</span>,<span class="number">150</span>);</span><br><span class="line"><span class="keyword">var</span> radialgradient = ctx.<span class="title function_">createRadialGradient</span>(<span class="number">75</span>,<span class="number">75</span>,<span class="number">0</span>,<span class="number">75</span>,<span class="number">75</span>,<span class="number">100</span>);</span><br></pre></td></tr></table></figure><p>创建出 canvasGradient 对象后，我们就可以用 addColorStop 方法给它上色了。</p><p>gradient.addColorStop(position, color)</p><p>addColorStop 方法接受 2 个参数，position 参数必须是一个 0.0 与 1.0 之间的数值，表示渐变中颜色所在的相对位置。例如，0.5  表示颜色会出现在正中间。color 参数必须是一个有效的 CSS 颜色值（如 #FFF，rgba(0,0,0,1)，等等）。</p><p>你可以根据需要添加任意多个色标（color stops）。下面是最简单的线性黑白渐变的例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> lineargradient = ctx.<span class="title function_">createLinearGradient</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">150</span>,<span class="number">150</span>);</span><br><span class="line">lineargradient.<span class="title function_">addColorStop</span>(<span class="number">0</span>,<span class="string">&#x27;white&#x27;</span>);</span><br><span class="line">lineargradient.<span class="title function_">addColorStop</span>(<span class="number">1</span>,<span class="string">&#x27;black&#x27;</span>);</span><br></pre></td></tr></table></figure><h4 id="createLinearGradient-的例子"><a href="#createLinearGradient-的例子" class="headerlink" title="createLinearGradient 的例子"></a>createLinearGradient 的例子</h4><p>本例中，我弄了两种不同的渐变。第一种是背景色渐变，你会发现，我给同一位置设置了两种颜色，你也可以用这来实现突变的效果，就像这里从白色到绿色的突变。一般情况下，色标的定义是无所谓顺序的，但是色标位置重复时，顺序就变得非常重要了。所以，保持色标定义顺序和它理想的顺序一致，结果应该没什么大问题。</p><p>第二种渐变，我并不是从 0.0 位置开始定义色标，因为那并不是那么严格的。在 0.5 处设一黑色色标，渐变会默认认为从起点到色标之间都是黑色。</p><p>你会发现，strokeStyle 和 fillStyle 属性都可以接受 canvasGradient 对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">draw</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> ctx = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;canvas&#x27;</span>).<span class="title function_">getContext</span>(<span class="string">&#x27;2d&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Create gradients</span></span><br><span class="line">  <span class="keyword">var</span> lingrad = ctx.<span class="title function_">createLinearGradient</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">150</span>);</span><br><span class="line">  lingrad.<span class="title function_">addColorStop</span>(<span class="number">0</span>, <span class="string">&#x27;#00ABEB&#x27;</span>);</span><br><span class="line">  lingrad.<span class="title function_">addColorStop</span>(<span class="number">0.5</span>, <span class="string">&#x27;#fff&#x27;</span>);</span><br><span class="line">  lingrad.<span class="title function_">addColorStop</span>(<span class="number">0.5</span>, <span class="string">&#x27;#26C000&#x27;</span>);</span><br><span class="line">  lingrad.<span class="title function_">addColorStop</span>(<span class="number">1</span>, <span class="string">&#x27;#fff&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> lingrad2 = ctx.<span class="title function_">createLinearGradient</span>(<span class="number">0</span>,<span class="number">50</span>,<span class="number">0</span>,<span class="number">95</span>);</span><br><span class="line">  lingrad2.<span class="title function_">addColorStop</span>(<span class="number">0.5</span>, <span class="string">&#x27;#000&#x27;</span>);</span><br><span class="line">  lingrad2.<span class="title function_">addColorStop</span>(<span class="number">1</span>, <span class="string">&#x27;rgba(0,0,0,0)&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// assign gradients to fill and stroke styles</span></span><br><span class="line">  ctx.<span class="property">fillStyle</span> = lingrad;</span><br><span class="line">  ctx.<span class="property">strokeStyle</span> = lingrad2;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// draw shapes</span></span><br><span class="line">  ctx.<span class="title function_">fillRect</span>(<span class="number">10</span>,<span class="number">10</span>,<span class="number">130</span>,<span class="number">130</span>);</span><br><span class="line">  ctx.<span class="title function_">strokeRect</span>(<span class="number">50</span>,<span class="number">50</span>,<span class="number">50</span>,<span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://threejs-1251830808.cos.ap-guangzhou.myqcloud.com/1667123028886-37cfbbb6-319d-42f1-a084-c8c5019328ff.png" alt="img"></p><h3 id="-32"><a href="#-32" class="headerlink" title=" "></a> </h3><h3 id="createRadialGradient的例子"><a href="#createRadialGradient的例子" class="headerlink" title="createRadialGradient的例子"></a>createRadialGradient的例子</h3><p>这个例子，我定义了 4 个不同的径向渐变。由于可以控制渐变的起始与结束点，所以我们可以实现一些比（如在 Photoshop 中所见的）经典的径向渐变更为复杂的效果。（经典的径向渐变是只有一个中心点，简单地由中心点向外围的圆形扩张）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">draw</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> ctx = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;canvas&#x27;</span>).<span class="title function_">getContext</span>(<span class="string">&#x27;2d&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建渐变</span></span><br><span class="line">  <span class="keyword">var</span> radgrad = ctx.<span class="title function_">createRadialGradient</span>(<span class="number">45</span>,<span class="number">45</span>,<span class="number">10</span>,<span class="number">52</span>,<span class="number">50</span>,<span class="number">30</span>);</span><br><span class="line">  radgrad.<span class="title function_">addColorStop</span>(<span class="number">0</span>, <span class="string">&#x27;#A7D30C&#x27;</span>);</span><br><span class="line">  radgrad.<span class="title function_">addColorStop</span>(<span class="number">0.9</span>, <span class="string">&#x27;#019F62&#x27;</span>);</span><br><span class="line">  radgrad.<span class="title function_">addColorStop</span>(<span class="number">1</span>, <span class="string">&#x27;rgba(1,159,98,0)&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> radgrad2 = ctx.<span class="title function_">createRadialGradient</span>(<span class="number">105</span>,<span class="number">105</span>,<span class="number">20</span>,<span class="number">112</span>,<span class="number">120</span>,<span class="number">50</span>);</span><br><span class="line">  radgrad2.<span class="title function_">addColorStop</span>(<span class="number">0</span>, <span class="string">&#x27;#FF5F98&#x27;</span>);</span><br><span class="line">  radgrad2.<span class="title function_">addColorStop</span>(<span class="number">0.75</span>, <span class="string">&#x27;#FF0188&#x27;</span>);</span><br><span class="line">  radgrad2.<span class="title function_">addColorStop</span>(<span class="number">1</span>, <span class="string">&#x27;rgba(255,1,136,0)&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> radgrad3 = ctx.<span class="title function_">createRadialGradient</span>(<span class="number">95</span>,<span class="number">15</span>,<span class="number">15</span>,<span class="number">102</span>,<span class="number">20</span>,<span class="number">40</span>);</span><br><span class="line">  radgrad3.<span class="title function_">addColorStop</span>(<span class="number">0</span>, <span class="string">&#x27;#00C9FF&#x27;</span>);</span><br><span class="line">  radgrad3.<span class="title function_">addColorStop</span>(<span class="number">0.8</span>, <span class="string">&#x27;#00B5E2&#x27;</span>);</span><br><span class="line">  radgrad3.<span class="title function_">addColorStop</span>(<span class="number">1</span>, <span class="string">&#x27;rgba(0,201,255,0)&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> radgrad4 = ctx.<span class="title function_">createRadialGradient</span>(<span class="number">0</span>,<span class="number">150</span>,<span class="number">50</span>,<span class="number">0</span>,<span class="number">140</span>,<span class="number">90</span>);</span><br><span class="line">  radgrad4.<span class="title function_">addColorStop</span>(<span class="number">0</span>, <span class="string">&#x27;#F4F201&#x27;</span>);</span><br><span class="line">  radgrad4.<span class="title function_">addColorStop</span>(<span class="number">0.8</span>, <span class="string">&#x27;#E4C700&#x27;</span>);</span><br><span class="line">  radgrad4.<span class="title function_">addColorStop</span>(<span class="number">1</span>, <span class="string">&#x27;rgba(228,199,0,0)&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 画图形</span></span><br><span class="line">  ctx.<span class="property">fillStyle</span> = radgrad4;</span><br><span class="line">  ctx.<span class="title function_">fillRect</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">150</span>,<span class="number">150</span>);</span><br><span class="line">  ctx.<span class="property">fillStyle</span> = radgrad3;</span><br><span class="line">  ctx.<span class="title function_">fillRect</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">150</span>,<span class="number">150</span>);</span><br><span class="line">  ctx.<span class="property">fillStyle</span> = radgrad2;</span><br><span class="line">  ctx.<span class="title function_">fillRect</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">150</span>,<span class="number">150</span>);</span><br><span class="line">  ctx.<span class="property">fillStyle</span> = radgrad;</span><br><span class="line">  ctx.<span class="title function_">fillRect</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">150</span>,<span class="number">150</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里，我让起点稍微偏离终点，这样可以达到一种球状 3D 效果。但最好不要让里圆与外圆部分交叠，那样会产生什么效果就真是不得而知了。</p><p>4 个径向渐变效果的最后一个色标都是透明色。如果想要两色标直接的过渡柔和一些，只要两个颜色值一致就可以了。代码里面看不出来，是因为我用了两种不同的颜色表示方法，但其实是相同的，#019F62 = rgba(1,159,98,1)。</p><p><img src="https://threejs-1251830808.cos.ap-guangzhou.myqcloud.com/1667123057094-ac7a9bb7-5e32-4df5-a591-c73b4ca5ce53.png" alt="img"></p><h2 id="-33"><a href="#-33" class="headerlink" title=" "></a> </h2><h2 id="图案样式-Patterns"><a href="#图案样式-Patterns" class="headerlink" title="图案样式 Patterns"></a>图案样式 Patterns</h2><p>上一节的一个例子里面，我用了循环来实现图案的效果。其实，有一个更加简单的方法：createPattern。</p><p>createPattern(image, type)</p><p>该方法接受两个参数。Image 可以是一个 Image 对象的引用，或者另一个 canvas 对象。Type 必须是下面的字符串值之一：repeat，repeat-x，repeat-y 和 no-repeat。</p><p><strong>备注：</strong> 用 canvas 对象作为 Image 参数在 Firefox 1.5 (Gecko 1.8) 中是无效的。</p><p>图案的应用跟渐变很类似的，创建出一个 pattern 之后，赋给 fillStyle 或 strokeStyle 属性即可。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> img = <span class="keyword">new</span> <span class="title class_">Image</span>();</span><br><span class="line">img.<span class="property">src</span> = <span class="string">&#x27;someimage.png&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> ptrn = ctx.<span class="title function_">createPattern</span>(img,<span class="string">&#x27;repeat&#x27;</span>);</span><br></pre></td></tr></table></figure><p><strong>备注：</strong> 与 drawImage 有点不同，你需要确认 image 对象已经装载完毕，否则图案可能效果不对的。</p><h3 id="-34"><a href="#-34" class="headerlink" title=" "></a> </h3><h3 id="createPattern的例子"><a href="#createPattern的例子" class="headerlink" title="createPattern的例子"></a>createPattern的例子</h3><p>在最后的例子中，我创建一个图案然后赋给了 fillStyle 属性。唯一要注意的是，使用 Image 对象的 onload handler 来确保设置图案之前图像已经装载完毕。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">draw</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> ctx = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;canvas&#x27;</span>).<span class="title function_">getContext</span>(<span class="string">&#x27;2d&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建新 image 对象，用作图案</span></span><br><span class="line">  <span class="keyword">var</span> img = <span class="keyword">new</span> <span class="title class_">Image</span>();</span><br><span class="line">  img.<span class="property">src</span> = <span class="string">&#x27;https://mdn.mozillademos.org/files/222/Canvas_createpattern.png&#x27;</span>;</span><br><span class="line">  img.<span class="property">onload</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建图案</span></span><br><span class="line">    <span class="keyword">var</span> ptrn = ctx.<span class="title function_">createPattern</span>(img, <span class="string">&#x27;repeat&#x27;</span>);</span><br><span class="line">    ctx.<span class="property">fillStyle</span> = ptrn;</span><br><span class="line">    ctx.<span class="title function_">fillRect</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">150</span>, <span class="number">150</span>);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="阴影-Shadows"><a href="#阴影-Shadows" class="headerlink" title="阴影 Shadows"></a>阴影 Shadows</h2><p>shadowOffsetX = float</p><p>shadowOffsetX 和 shadowOffsetY 用来设定阴影在 X 和 Y 轴的延伸距离，它们是不受变换矩阵所影响的。负值表示阴影会往上或左延伸，正值则表示会往下或右延伸，它们默认都为 0。</p><p>shadowOffsetY = float</p><p>shadowOffsetX 和 shadowOffsetY 用来设定阴影在 X 和 Y 轴的延伸距离，它们是不受变换矩阵所影响的。负值表示阴影会往上或左延伸，正值则表示会往下或右延伸，它们默认都为 0。</p><p>shadowBlur = float</p><p>shadowBlur 用于设定阴影的模糊程度，其数值并不跟像素数量挂钩，也不受变换矩阵的影响，默认为 0。</p><p>shadowColor = color</p><p>shadowColor 是标准的 CSS 颜色值，用于设定阴影颜色效果，默认是全透明的黑色。</p><h3 id="-35"><a href="#-35" class="headerlink" title=" "></a> </h3><h3 id="文字阴影的例子"><a href="#文字阴影的例子" class="headerlink" title="文字阴影的例子"></a>文字阴影的例子</h3><p>这个例子绘制了带阴影效果的文字。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">draw</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> ctx = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;canvas&#x27;</span>).<span class="title function_">getContext</span>(<span class="string">&#x27;2d&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  ctx.<span class="property">shadowOffsetX</span> = <span class="number">2</span>;</span><br><span class="line">  ctx.<span class="property">shadowOffsetY</span> = <span class="number">2</span>;</span><br><span class="line">  ctx.<span class="property">shadowBlur</span> = <span class="number">2</span>;</span><br><span class="line">  ctx.<span class="property">shadowColor</span> = <span class="string">&quot;rgba(0, 0, 0, 0.5)&quot;</span>;</span><br><span class="line"></span><br><span class="line">  ctx.<span class="property">font</span> = <span class="string">&quot;20px Times New Roman&quot;</span>;</span><br><span class="line">  ctx.<span class="property">fillStyle</span> = <span class="string">&quot;Black&quot;</span>;</span><br><span class="line">  ctx.<span class="title function_">fillText</span>(<span class="string">&quot;Sample String&quot;</span>, <span class="number">5</span>, <span class="number">30</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://threejs-1251830808.cos.ap-guangzhou.myqcloud.com/1667123140725-95bd7bb5-fe21-4d91-b6d9-276c0f0e5900.png" alt="img"></p><p>我们可以通过下一章来了解文字属性和 fillText 方法相关的内容。</p><h2 id="-36"><a href="#-36" class="headerlink" title=" "></a> </h2><h2 id="Canvas-填充规则"><a href="#Canvas-填充规则" class="headerlink" title="Canvas 填充规则"></a>Canvas 填充规则</h2><p>当我们用到 fill（或者 clip和isPointinPath ）你可以选择一个填充规则，该填充规则根据某处在路径的外面或者里面来决定该处是否被填充，这对于自己与自己路径相交或者路径被嵌套的时候是有用的。</p><p>两个可能的值：</p><ul><li><strong>“nonzero</strong>“: non-zero winding rule, 默认值。</li><li><strong>“evenodd”</strong>: even-odd winding rule.</li></ul><p>这个例子，我们用填充规则 evenodd</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">draw</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> ctx = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;canvas&#x27;</span>).<span class="title function_">getContext</span>(<span class="string">&#x27;2d&#x27;</span>);</span><br><span class="line">  ctx.<span class="title function_">beginPath</span>();</span><br><span class="line">  ctx.<span class="title function_">arc</span>(<span class="number">50</span>, <span class="number">50</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="title class_">Math</span>.<span class="property">PI</span>*<span class="number">2</span>, <span class="literal">true</span>);</span><br><span class="line">  ctx.<span class="title function_">arc</span>(<span class="number">50</span>, <span class="number">50</span>, <span class="number">15</span>, <span class="number">0</span>, <span class="title class_">Math</span>.<span class="property">PI</span>*<span class="number">2</span>, <span class="literal">true</span>);</span><br><span class="line">  ctx.<span class="title function_">fill</span>(<span class="string">&quot;evenodd&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://threejs-1251830808.cos.ap-guangzhou.myqcloud.com/1667123175455-39bca738-50b5-4ccc-9f22-ccfa84e4c744.png" alt="img"></p><h1 id="03-绘制图像和视频"><a href="#03-绘制图像和视频" class="headerlink" title="03-绘制图像和视频"></a>03-绘制图像和视频</h1><p>canvas  更有意思的一项特性就是图像操作能力。可以用于动态的图像合成或者作为图形的背景，以及游戏界面（Sprites）等等。浏览器支持的任意格式的外部图片都可以使用，比如 PNG、GIF 或者 JPEG。你甚至可以将同一个页面中其他 canvas 元素生成的图片作为图片源。</p><p>引入图像到 canvas 里需要以下两步基本操作：</p><ol><li>获得一个指向HTMLImageElement的对象或者另一个 canvas 元素的引用作为源，也可以通过提供一个 URL 的方式来使用图片</li><li>使用drawImage()函数将图片绘制到画布上</li></ol><p>我们来看看具体是怎么做的。</p><p><img src="https://threejs-1251830808.cos.ap-guangzhou.myqcloud.com/1667223627890-1c5888f5-6ce5-49ee-b09c-c3734aca9de0.png" alt="img"></p><h2 id="-37"><a href="#-37" class="headerlink" title=" "></a> </h2><h2 id="获得需要绘制的图片"><a href="#获得需要绘制的图片" class="headerlink" title="获得需要绘制的图片"></a>获得需要绘制的图片</h2><p>canvas 的 API 可以使用下面这些类型中的一种作为图片的源：</p><p>HTMLImageElement</p><p>这些图片是由 Image() 函数构造出来的，或者任何的 img 元素</p><p>HTMLVideoElement</p><p>用一个 HTML 的 video元素作为你的图片源，可以从视频中抓取当前帧作为一个图像</p><p>HTMLCanvasElement</p><p>可以使用另一个 canvas 元素作为你的图片源。</p><p>ImageBitmap</p><p>这是一个高性能的位图，可以低延迟地绘制，它可以从上述的所有源以及其它几种源中生成。</p><h3 id="-38"><a href="#-38" class="headerlink" title=" "></a> </h3><h3 id="例子：一个简单的线图"><a href="#例子：一个简单的线图" class="headerlink" title="例子：一个简单的线图"></a>例子：一个简单的线图</h3><p>下面一个例子我用一个外部图像作为一线性图的背景。用背景图我们就不需要绘制复杂的背景，省下不少代码。这里只用到一个 image 对象，于是就在它的 onload 事件响应函数中触发绘制动作。drawImage 方法将背景图放置在 canvas 的左上角  (0,0) 处。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">draw</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> ctx = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;canvas&#x27;</span>).<span class="title function_">getContext</span>(<span class="string">&#x27;2d&#x27;</span>);</span><br><span class="line">  <span class="keyword">var</span> img = <span class="keyword">new</span> <span class="title class_">Image</span>();</span><br><span class="line">  img.<span class="property">onload</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    ctx.<span class="title function_">drawImage</span>(img,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    ctx.<span class="title function_">beginPath</span>();</span><br><span class="line">    ctx.<span class="title function_">moveTo</span>(<span class="number">30</span>,<span class="number">96</span>);</span><br><span class="line">    ctx.<span class="title function_">lineTo</span>(<span class="number">70</span>,<span class="number">66</span>);</span><br><span class="line">    ctx.<span class="title function_">lineTo</span>(<span class="number">103</span>,<span class="number">76</span>);</span><br><span class="line">    ctx.<span class="title function_">lineTo</span>(<span class="number">170</span>,<span class="number">15</span>);</span><br><span class="line">    ctx.<span class="title function_">stroke</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  img.<span class="property">src</span> = <span class="string">&#x27;https://mdn.mozillademos.org/files/5395/backdrop.png&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="缩放-Scaling"><a href="#缩放-Scaling" class="headerlink" title="缩放 Scaling"></a>缩放 Scaling</h2><p>drawImage 方法的又一变种是增加了两个用于控制图像在 canvas 中缩放的参数。</p><p>drawImage(image, x, y, width, height)</p><p>这个方法多了 2 个参数：width 和 height，这两个参数用来控制 当向 canvas 画入时应该缩放的大小</p><h3 id="-39"><a href="#-39" class="headerlink" title=" "></a> </h3><h3 id="例子：平铺图像"><a href="#例子：平铺图像" class="headerlink" title="例子：平铺图像"></a>例子：平铺图像</h3><p>在这个例子里，我会用一张图片像背景一样在 canvas 中以重复平铺开来。实现起来也很简单，只需要循环铺开经过缩放的图片即可。见下面的代码，第一层 for  循环是做行重复，第二层是做列重复的。图像大小被缩放至原来的三分之一，50x38  px。这种方法可以用来很好的达到背景图案的效果，在下面的教程中会看到。</p><p><strong>备注：</strong> 图像可能会因为大幅度的缩放而变得起杂点或者模糊。如果您的图像里面有文字，那么最好还是不要进行缩放，因为那样处理之后很可能图像里的文字就会变得无法辨认了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">draw</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> ctx = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;canvas&#x27;</span>).<span class="title function_">getContext</span>(<span class="string">&#x27;2d&#x27;</span>);</span><br><span class="line">  <span class="keyword">var</span> img = <span class="keyword">new</span> <span class="title class_">Image</span>();</span><br><span class="line">  img.<span class="property">onload</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">var</span> j=<span class="number">0</span>;j&lt;<span class="number">3</span>;j++)&#123;</span><br><span class="line">        ctx.<span class="title function_">drawImage</span>(img,j*<span class="number">50</span>,i*<span class="number">38</span>,<span class="number">50</span>,<span class="number">38</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  img.<span class="property">src</span> = <span class="string">&#x27;https://mdn.mozillademos.org/files/5397/rhino.jpg&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="切片-Slicing"><a href="#切片-Slicing" class="headerlink" title="切片 Slicing"></a>切片 Slicing</h2><p>drawImage 方法的第三个也是最后一个变种有 8 个新参数，用于控制做切片显示的。</p><p>drawImage(image, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight)</p><p>第一个参数和其它的是相同的，都是一个图像或者另一个 canvas 的引用。其它 8 个参数最好是参照右边的图解，前 4 个是定义图像源的切片位置和大小，后 4 个则是定义切片的目标显示位置和大小。</p><p>切片是个做图像合成的强大工具。假设有一张包含了所有元素的图像，那么你可以用这个方法来合成一个完整图像。例如，你想画一张图表，而手上有一个包含所有必需的文字的 PNG 文件，那么你可以很轻易的根据实际数据的需要来改变最终显示的图表。这方法的另一个好处就是你不需要单独装载每一个图像。</p><h3 id="-40"><a href="#-40" class="headerlink" title=" "></a> </h3><h3 id="例子：相框"><a href="#例子：相框" class="headerlink" title="例子：相框"></a>例子：相框</h3><p>在这个例子里面我用到上面已经用过的犀牛图像，不过这次我要给犀牛头做个切片特写，然后合成到一个相框里面去。相框带有阴影效果，是一个以 24-bit PNG 格式保存的图像。因为 24-bit PNG 图像带有一个完整的 8-bit alpha 通道，与 GIF 和 8-bit PNG 不同，我可以将它放成背景而不必担心底色的问题。</p><p>我用一个与上面用到的不同的方法来装载图像，直接将图像插入到 HTML  里面，然后通过 CSS 隐藏（display:none）它。两个图像我都赋了 id  ，方便后面使用。看下面的脚本，相当简单，首先对犀牛头做好切片（第一次drawImage）放在 canvas  上，然后再上面套个相框（第二次drawImage）。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span> <span class="attr">onload</span>=<span class="string">&quot;draw();&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">canvas</span> <span class="attr">id</span>=<span class="string">&quot;canvas&quot;</span> <span class="attr">width</span>=<span class="string">&quot;150&quot;</span> <span class="attr">height</span>=<span class="string">&quot;150&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;display:none;&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">img</span> <span class="attr">id</span>=<span class="string">&quot;source&quot;</span> <span class="attr">src</span>=<span class="string">&quot;https://mdn.mozillademos.org/files/5397/rhino.jpg&quot;</span> <span class="attr">width</span>=<span class="string">&quot;300&quot;</span> <span class="attr">height</span>=<span class="string">&quot;227&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">img</span> <span class="attr">id</span>=<span class="string">&quot;frame&quot;</span> <span class="attr">src</span>=<span class="string">&quot;https://mdn.mozillademos.org/files/242/Canvas_picture_frame.png&quot;</span> <span class="attr">width</span>=<span class="string">&quot;132&quot;</span> <span class="attr">height</span>=<span class="string">&quot;150&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line">function draw() &#123;</span><br><span class="line">  var canvas = document.getElementById(&#x27;canvas&#x27;);</span><br><span class="line">  var ctx = canvas.getContext(&#x27;2d&#x27;);</span><br><span class="line"></span><br><span class="line">  // Draw slice</span><br><span class="line">  ctx.drawImage(document.getElementById(&#x27;source&#x27;),</span><br><span class="line">                33,71,104,124,21,20,87,104);</span><br><span class="line"></span><br><span class="line">  // Draw frame</span><br><span class="line">  ctx.drawImage(document.getElementById(&#x27;frame&#x27;),0,0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="示例：画廊-Art-gallery-example"><a href="#示例：画廊-Art-gallery-example" class="headerlink" title="示例：画廊 Art gallery example"></a>示例：画廊 Art gallery example</h2><p>我这一章最后的示例是弄一个小画廊。画廊由挂着几张画作的格子组成。当页面装载好之后，为每张画创建一个 canvas 元素并用加上画框然后插入到画廊中去。</p><p>在我这个例子里面，所有“画”都是固定宽高的，画框也是。你可以做些改进，通过脚本用画的宽高来准确控制围绕它的画框的大小。</p><p>下面的代码应该是蛮简单易懂的了。就是遍历图像对象数组，依次创建新的 canvas 元素并添加进去。可能唯一需要注意的，对于那些并不熟悉 DOM 的朋友来说，是 insertBefore  方法的用法。insertBefore 是父节点（单元格）的方法，用于将新节点（canvas 元素）插入到我们想要插入的节点之前。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span> <span class="attr">onload</span>=<span class="string">&quot;draw();&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;https://mdn.mozillademos.org/files/5399/gallery_1.jpg&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;https://mdn.mozillademos.org/files/5401/gallery_2.jpg&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;https://mdn.mozillademos.org/files/5403/gallery_3.jpg&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;https://mdn.mozillademos.org/files/5405/gallery_4.jpg&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;https://mdn.mozillademos.org/files/5407/gallery_5.jpg&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;https://mdn.mozillademos.org/files/5409/gallery_6.jpg&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;https://mdn.mozillademos.org/files/5411/gallery_7.jpg&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;https://mdn.mozillademos.org/files/5413/gallery_8.jpg&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">id</span>=<span class="string">&quot;frame&quot;</span> <span class="attr">src</span>=<span class="string">&quot;https://mdn.mozillademos.org/files/242/Canvas_picture_frame.png&quot;</span> <span class="attr">width</span>=<span class="string">&quot;132&quot;</span> <span class="attr">height</span>=<span class="string">&quot;150&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line">body &#123;</span><br><span class="line">  background: 0 -100px repeat-x url(https://mdn.mozillademos.org/files/5415/bg_gallery.png) #4F191A;</span><br><span class="line">  margin: 10px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">img &#123;</span><br><span class="line">  display: none;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">table &#123;</span><br><span class="line">  margin: 0 auto;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">td &#123;</span><br><span class="line">  padding: 15px;</span><br><span class="line">&#125;</span><br><span class="line">function draw() &#123;</span><br><span class="line"></span><br><span class="line">  // Loop through all images</span><br><span class="line">  for (i=0;i&lt;document.images.length;i++)&#123;</span><br><span class="line"></span><br><span class="line">    // Don&#x27;t add a canvas for the frame image</span><br><span class="line">    if (document.images[i].getAttribute(&#x27;id&#x27;)!=&#x27;frame&#x27;)&#123;</span><br><span class="line"></span><br><span class="line">      // Create canvas element</span><br><span class="line">      canvas = document.createElement(&#x27;CANVAS&#x27;);</span><br><span class="line">      canvas.setAttribute(&#x27;width&#x27;,132);</span><br><span class="line">      canvas.setAttribute(&#x27;height&#x27;,150);</span><br><span class="line"></span><br><span class="line">      // Insert before the image</span><br><span class="line">      document.images[i].parentNode.insertBefore(canvas,document.images[i]);</span><br><span class="line"></span><br><span class="line">      ctx = canvas.getContext(&#x27;2d&#x27;);</span><br><span class="line"></span><br><span class="line">      // Draw image to canvas</span><br><span class="line">      ctx.drawImage(document.images[i],15,20);</span><br><span class="line"></span><br><span class="line">      // Add frame</span><br><span class="line">      ctx.drawImage(document.getElementById(&#x27;frame&#x27;),0,0);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="控制图像的缩放行为-Controlling-image-scaling-behavior"><a href="#控制图像的缩放行为-Controlling-image-scaling-behavior" class="headerlink" title="控制图像的缩放行为 Controlling image scaling behavior"></a>控制图像的缩放行为 Controlling image scaling behavior</h2><p>如同前文所述，过度缩放图像可能会导致图像模糊或像素化。您可以通过使用绘图环境的imageSmoothingEnabled属性来控制是否在缩放图像时使用平滑算法。默认值为true，即启用平滑缩放。您也可以像这样禁用此功能：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ctx.<span class="property">mozImageSmoothingEnabled</span> = <span class="literal">false</span>;</span><br><span class="line">ctx.<span class="property">webkitImageSmoothingEnabled</span> = <span class="literal">false</span>;</span><br><span class="line">ctx.<span class="property">msImageSmoothingEnabled</span> = <span class="literal">false</span>;</span><br><span class="line">ctx.<span class="property">imageSmoothingEnabled</span> = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><h1 id="04-绘制文字"><a href="#04-绘制文字" class="headerlink" title="04-绘制文字"></a>04-绘制文字</h1><p><img src="https://threejs-1251830808.cos.ap-guangzhou.myqcloud.com/1668398881094-5a483c57-8a7a-4db3-93c1-f140ecbf4a00.gif" alt="img"></p><h2 id="-41"><a href="#-41" class="headerlink" title=" "></a> </h2><h2 id="绘制文本"><a href="#绘制文本" class="headerlink" title="绘制文本"></a>绘制文本</h2><p>canvas 提供了两种方法来渲染文本：</p><p>fillText(text, x, y [, maxWidth])</p><p>在指定的 (x,y) 位置填充指定的文本，绘制的最大宽度是可选的。</p><p>strokeText(text, x, y [, maxWidth])</p><p>在指定的 (x,y) 位置绘制文本边框，绘制的最大宽度是可选的。</p><h3 id="-42"><a href="#-42" class="headerlink" title=" "></a> </h3><h3 id="一个填充文本的示例"><a href="#一个填充文本的示例" class="headerlink" title="一个填充文本的示例"></a>一个填充文本的示例</h3><p>文本用当前的填充方式被填充：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function draw() &#123;</span><br><span class="line">  var ctx = document.getElementById(&#x27;canvas&#x27;).getContext(&#x27;2d&#x27;);</span><br><span class="line">  ctx.font = &quot;48px serif&quot;;</span><br><span class="line">  ctx.fillText(&quot;Hello world&quot;, 10, 50);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://threejs-1251830808.cos.ap-guangzhou.myqcloud.com/1667105790357-823d37a9-cd8d-420e-99cd-c86a03368c82.png" alt="img"></p><h3 id="-43"><a href="#-43" class="headerlink" title=" "></a> </h3><h3 id="一个文本边框的示例"><a href="#一个文本边框的示例" class="headerlink" title="一个文本边框的示例"></a>一个文本边框的示例</h3><p>文本用当前的边框样式被绘制：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function draw() &#123;</span><br><span class="line">  var ctx = document.getElementById(&#x27;canvas&#x27;).getContext(&#x27;2d&#x27;);</span><br><span class="line">  ctx.font = &quot;48px serif&quot;;</span><br><span class="line">  ctx.strokeText(&quot;Hello world&quot;, 10, 50);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://threejs-1251830808.cos.ap-guangzhou.myqcloud.com/1667105810468-4de7261e-5a6e-4f3e-b0aa-46907bc005ea.png" alt="img"></p><h2 id="-44"><a href="#-44" class="headerlink" title=" "></a> </h2><h2 id="有样式的文本"><a href="#有样式的文本" class="headerlink" title="有样式的文本"></a>有样式的文本</h2><p>在上面的例子用我们已经使用了 font 来使文本比默认尺寸大一些。还有更多的属性可以让你改变 canvas 显示文本的方式：</p><p>font = value</p><p>当前我们用来绘制文本的样式。这个字符串使用和 CSS font 属性相同的语法。默认的字体是 10px sans-serif。</p><p>textAlign = value</p><p>文本对齐选项。可选的值包括：start, end, left, right or center. 默认值是 start。</p><p>textBaseline = value</p><p>基线对齐选项。可选的值包括：top, hanging, middle, alphabetic, ideographic, bottom。默认值是 alphabetic。</p><p>direction = value</p><p>文本方向。可能的值包括：ltr, rtl, inherit。默认值是 inherit。</p><p>如果你之前使用过 CSS，那么这些选项你会很熟悉。</p><p>下面的图片（from the WHATWG）展示了 textBaseline 属性支持的不同的基线情况：</p><h3 id="-45"><a href="#-45" class="headerlink" title=" "></a> </h3><h3 id="textBaseline-例子"><a href="#textBaseline-例子" class="headerlink" title="textBaseline 例子"></a>textBaseline 例子</h3><p>编辑下面的代码，看看它们在 canvas 中的变化：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ctx.font = &quot;48px serif&quot;;</span><br><span class="line">ctx.textBaseline = &quot;hanging&quot;;</span><br><span class="line">ctx.strokeText(&quot;Hello world&quot;, 0, 100);</span><br></pre></td></tr></table></figure><h2 id="预测量文本宽度"><a href="#预测量文本宽度" class="headerlink" title="预测量文本宽度"></a>预测量文本宽度</h2><p>当你需要获得更多的文本细节时，下面的方法可以给你测量文本的方法。</p><p>measureText()</p><p>将返回一个 TextMetrics对象的宽度、所在像素，这些体现文本特性的属性。</p><p>下面的代码段将展示如何测量文本来获得它的宽度：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function draw() &#123;</span><br><span class="line">  var ctx = document.getElementById(&#x27;canvas&#x27;).getContext(&#x27;2d&#x27;);</span><br><span class="line">  var text = ctx.measureText(&quot;foo&quot;); // TextMetrics object</span><br><span class="line">  text.width; // 16;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="05-变形"><a href="#05-变形" class="headerlink" title="05-变形"></a>05-变形</h1><h3 id="几何变换"><a href="#几何变换" class="headerlink" title="几何变换"></a>几何变换</h3><p><img src="https://threejs-1251830808.cos.ap-guangzhou.myqcloud.com/1668396482058-84cf0ed9-6b63-4b8d-9dfe-33dd928727d9.png" alt="img"></p><p><strong>canvas现在被大量地运用于游戏等动画领域，最主要的归功于它提供的一系列几何变换方法，使得动画更加地容易。所以其几何变换是非常重要的一节。</strong></p><p>在本教程前面的部分中，我们已经了解了 Canvas 网格和坐标空间。到目前为止，我们只是根据我们的需要使用默认的网格，改变整个画布的大小。变形是一种更强大的方法，可以将原点移动到另一点、对网格进行旋转和缩放。</p><h2 id="-46"><a href="#-46" class="headerlink" title=" "></a> </h2><h2 id="状态的保存和恢复-Saving-and-restoring-state"><a href="#状态的保存和恢复-Saving-and-restoring-state" class="headerlink" title="状态的保存和恢复 Saving and restoring state"></a>状态的保存和恢复 Saving and restoring state</h2><p>在了解变形之前，我先介绍两个在你开始绘制复杂图形时必不可少的方法。</p><p>save()</p><p>保存画布 (canvas) 的所有状态</p><p>restore()</p><p>save 和 restore 方法是用来保存和恢复 canvas 状态的，都没有参数。Canvas 的状态就是当前画面应用的所有样式和变形的一个快照。</p><p>Canvas 状态存储在栈中，每当save()方法被调用后，当前的状态就被推送到栈中保存。一个绘画状态包括：</p><ul><li>当前应用的变形（即移动，旋转和缩放，见下）</li><li>以及下面这些属性：strokeStyle, fillStyle, globalAlpha, lineWidth, lineCap, lineJoin, miterLimit,  lineDashOffset, shadowOffsetX, shadowOffsetY, shadowBlur, shadowColor,  globalCompositeOperation, font, textAlign, textBaseline, direction,  imageSmoothingEnabled</li><li>当前的裁切路径（clipping path），会在下一节介绍</li></ul><p>你可以调用任意多次 save方法。每一次调用 restore 方法，上一个保存的状态就从栈中弹出，所有设定都恢复。</p><h3 id="-47"><a href="#-47" class="headerlink" title=" "></a> </h3><h3 id="save和restore的应用例子"><a href="#save和restore的应用例子" class="headerlink" title="save和restore的应用例子"></a>save和restore的应用例子</h3><p>我们尝试用这个连续矩形的例子来描述 canvas 的状态栈是如何工作的。</p><p>第一步是用默认设置画一个大四方形，然后保存一下状态。改变填充颜色画第二个小一点的蓝色四方形，然后再保存一下状态。再次改变填充颜色绘制更小一点的半透明的白色四方形。</p><p>到目前为止所做的动作和前面章节的都很类似。不过一旦我们调用 restore，状态栈中最后的状态会弹出，并恢复所有设置。如果不是之前用 save  保存了状态，那么我们就需要手动改变设置来回到前一个状态，这个对于两三个属性的时候还是适用的，一旦多了，我们的代码将会猛涨。</p><p>当第二次调用 restore 时，已经恢复到最初的状态，因此最后是再一次绘制出一个黑色的四方形。</p><p><img src="https://threejs-1251830808.cos.ap-guangzhou.myqcloud.com/1667227362304-1dddf3b7-f6c4-42cf-bb8c-88077c268860.png" alt="img"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">draw</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> ctx = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;canvas&#x27;</span>).<span class="title function_">getContext</span>(<span class="string">&#x27;2d&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  ctx.<span class="title function_">fillRect</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">150</span>,<span class="number">150</span>);   <span class="comment">// 使用默认设置绘制一个矩形</span></span><br><span class="line">  ctx.<span class="title function_">save</span>();                  <span class="comment">// 保存默认状态</span></span><br><span class="line"></span><br><span class="line">  ctx.<span class="property">fillStyle</span> = <span class="string">&#x27;#09F&#x27;</span>       <span class="comment">// 在原有配置基础上对颜色做改变</span></span><br><span class="line">  ctx.<span class="title function_">fillRect</span>(<span class="number">15</span>,<span class="number">15</span>,<span class="number">120</span>,<span class="number">120</span>); <span class="comment">// 使用新的设置绘制一个矩形</span></span><br><span class="line"></span><br><span class="line">  ctx.<span class="title function_">save</span>();                  <span class="comment">// 保存当前状态</span></span><br><span class="line">  ctx.<span class="property">fillStyle</span> = <span class="string">&#x27;#FFF&#x27;</span>       <span class="comment">// 再次改变颜色配置</span></span><br><span class="line">  ctx.<span class="property">globalAlpha</span> = <span class="number">0.5</span>;</span><br><span class="line">  ctx.<span class="title function_">fillRect</span>(<span class="number">30</span>,<span class="number">30</span>,<span class="number">90</span>,<span class="number">90</span>);   <span class="comment">// 使用新的配置绘制一个矩形</span></span><br><span class="line"></span><br><span class="line">  ctx.<span class="title function_">restore</span>();               <span class="comment">// 重新加载之前的颜色状态</span></span><br><span class="line">  ctx.<span class="title function_">fillRect</span>(<span class="number">45</span>,<span class="number">45</span>,<span class="number">60</span>,<span class="number">60</span>);   <span class="comment">// 使用上一次的配置绘制一个矩形</span></span><br><span class="line"></span><br><span class="line">  ctx.<span class="title function_">restore</span>();               <span class="comment">// 加载默认颜色配置</span></span><br><span class="line">  ctx.<span class="title function_">fillRect</span>(<span class="number">60</span>,<span class="number">60</span>,<span class="number">30</span>,<span class="number">30</span>);   <span class="comment">// 使用加载的配置绘制一个矩形</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="移动-Translating"><a href="#移动-Translating" class="headerlink" title="移动 Translating"></a>移动 Translating</h2><p>我们先介绍 translate方法，它用来移动 canvas 和它的原点到一个不同的位置。</p><p>translate(x, y)</p><p>translate方法接受两个参数。<em>x </em>是左右偏移量，<em>y</em> 是上下偏移量，如右图所示。</p><p>在做变形之前先保存状态是一个良好的习惯。大多数情况下，调用 restore 方法比手动恢复原先的状态要简单得多。又，如果你是在一个循环中做位移但没有保存和恢复 canvas  的状态，很可能到最后会发现怎么有些东西不见了，那是因为它很可能已经超出 canvas 范围以外了。</p><h3 id="-48"><a href="#-48" class="headerlink" title=" "></a> </h3><h3 id="translate的例子"><a href="#translate的例子" class="headerlink" title="translate的例子"></a>translate的例子</h3><p>这个例子显示了一些移动 canvas 原点的好处。如果不使用  translate方法，那么所有矩形都将被绘制在相同的位置（0,0）。translate方法同时让我们可以任意放置这些图案，而不需要在  fillRect() 方法中手工调整坐标值，既好理解也方便使用。</p><p>我在 draw方法中调用 fillRect() 方法 9 次，用了 2 层循环。每一次循环，先移动 canvas，画螺旋图案，然后恢复到原始状态。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">draw</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> ctx = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;canvas&#x27;</span>).<span class="title function_">getContext</span>(<span class="string">&#x27;2d&#x27;</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++) &#123;</span><br><span class="line">      ctx.<span class="title function_">save</span>();</span><br><span class="line">      ctx.<span class="property">fillStyle</span> = <span class="string">&#x27;rgb(&#x27;</span> + (<span class="number">51</span> * i) + <span class="string">&#x27;, &#x27;</span> + (<span class="number">255</span> - <span class="number">51</span> * i) + <span class="string">&#x27;, 255)&#x27;</span>;</span><br><span class="line">      ctx.<span class="title function_">translate</span>(<span class="number">10</span> + j * <span class="number">50</span>, <span class="number">10</span> + i * <span class="number">50</span>);</span><br><span class="line">      ctx.<span class="title function_">fillRect</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">25</span>, <span class="number">25</span>);</span><br><span class="line">      ctx.<span class="title function_">restore</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://threejs-1251830808.cos.ap-guangzhou.myqcloud.com/1667227442902-fa85b858-88b7-4134-b5c2-c96ce10d9380.png" alt="img"></p><h2 id="-49"><a href="#-49" class="headerlink" title=" "></a> </h2><h2 id="旋转-Rotating"><a href="#旋转-Rotating" class="headerlink" title="旋转 Rotating"></a>旋转 Rotating</h2><p>第二个介绍 rotate方法，它用于以原点为中心旋转 canvas。</p><p>rotate(angle)</p><p>这个方法只接受一个参数：旋转的角度 (angle)，它是顺时针方向的，以弧度为单位的值。</p><p>旋转的中心点始终是 canvas 的原点，如果要改变它，我们需要用到 translate方法。</p><h3 id="-50"><a href="#-50" class="headerlink" title=" "></a> </h3><h3 id="rotate的例子"><a href="#rotate的例子" class="headerlink" title="rotate的例子"></a>rotate的例子</h3><p>在这个例子里，见右图，我用 rotate方法来画圆并构成圆形图案。当然你也可以分别计算出 <em>x</em> 和 <em>y</em> 坐标（x = r<em>Math.cos(a); y = r</em>Math.sin(a)）。这里无论用什么方法都无所谓的，因为我们画的是圆。计算坐标的结果只是旋转圆心位置，而不是圆本身。即使用 rotate旋转两者，那些圆看上去还是一样的，不管它们绕中心旋转有多远。</p><p>这里我们又用到了两层循环。第一层循环决定环的数量，第二层循环决定每环有多少个点。每环开始之前，我都保存一下 canvas 的状态，这样恢复起来方便。每次画圆点，我都以一定夹角来旋转 canvas，而这个夹角则是由环上的圆点数目的决定的。最里层的环有 6 个圆点，这样，每次旋转的夹角就是 360/6 = 60 度。往外每一环的圆点数目是里面一环的 2 倍，那么每次旋转的夹角随之减半。</p><p><img src="https://threejs-1251830808.cos.ap-guangzhou.myqcloud.com/1667227528080-9fea6887-8d30-42ab-a278-69d95a5f1656.png" alt="img"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">draw</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> ctx = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;canvas&#x27;</span>).<span class="title function_">getContext</span>(<span class="string">&#x27;2d&#x27;</span>);</span><br><span class="line">  ctx.<span class="title function_">translate</span>(<span class="number">75</span>,<span class="number">75</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">1</span>;i&lt;<span class="number">6</span>;i++)&#123; <span class="comment">// Loop through rings (from inside to out)</span></span><br><span class="line">    ctx.<span class="title function_">save</span>();</span><br><span class="line">    ctx.<span class="property">fillStyle</span> = <span class="string">&#x27;rgb(&#x27;</span>+(<span class="number">51</span>*i)+<span class="string">&#x27;,&#x27;</span>+(<span class="number">255</span>-<span class="number">51</span>*i)+<span class="string">&#x27;,255)&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> j=<span class="number">0</span>;j&lt;i*<span class="number">6</span>;j++)&#123; <span class="comment">// draw individual dots</span></span><br><span class="line">      ctx.<span class="title function_">rotate</span>(<span class="title class_">Math</span>.<span class="property">PI</span>*<span class="number">2</span>/(i*<span class="number">6</span>));</span><br><span class="line">      ctx.<span class="title function_">beginPath</span>();</span><br><span class="line">      ctx.<span class="title function_">arc</span>(<span class="number">0</span>,i*<span class="number">12.5</span>,<span class="number">5</span>,<span class="number">0</span>,<span class="title class_">Math</span>.<span class="property">PI</span>*<span class="number">2</span>,<span class="literal">true</span>);</span><br><span class="line">      ctx.<span class="title function_">fill</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ctx.<span class="title function_">restore</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="缩放-Scaling-1"><a href="#缩放-Scaling-1" class="headerlink" title="缩放 Scaling"></a>缩放 Scaling</h2><p>接着是缩放。我们用它来增减图形在 canvas 中的像素数目，对形状，位图进行缩小或者放大。</p><p><strong>scale(x, y)</strong></p><p>scale方法可以缩放画布的水平和垂直的单位。两个参数都是实数，可以为负数，x 为水平缩放因子，y 为垂直缩放因子，如果比 1 小，会缩小图形，如果比 1 大会放大图形。默认值为 1，为实际大小。</p><p>画布初始情况下，是以左上角坐标为原点的第一象限。如果参数为负实数，相当于以 x 或 y 轴作为对称轴镜像反转（例如，使用translate(0,canvas.height); scale(1,-1); 以 y  轴作为对称轴镜像反转，就可得到著名的笛卡尔坐标系，左下角为原点）。</p><p>默认情况下，canvas 的 1 个单位为 1  个像素。举例说，如果我们设置缩放因子是 0.5，1 个单位就变成对应 0.5 个像素，这样绘制出来的形状就会是原先的一半。同理，设置为 2.0  时，1 个单位就对应变成了 2 像素，绘制的结果就是图形放大了 2 倍。</p><h3 id="-51"><a href="#-51" class="headerlink" title=" "></a> </h3><h3 id="scale的例子"><a href="#scale的例子" class="headerlink" title="scale的例子"></a>scale的例子</h3><p>这最后的例子里，我们用不同的缩放方式来画两个图形。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">draw</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> ctx = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;canvas&#x27;</span>).<span class="title function_">getContext</span>(<span class="string">&#x27;2d&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// draw a simple rectangle, but scale it.</span></span><br><span class="line">  ctx.<span class="title function_">save</span>();</span><br><span class="line">  ctx.<span class="title function_">scale</span>(<span class="number">10</span>, <span class="number">3</span>);</span><br><span class="line">  ctx.<span class="title function_">fillRect</span>(<span class="number">1</span>, <span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>);</span><br><span class="line">  ctx.<span class="title function_">restore</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// mirror horizontally</span></span><br><span class="line">  ctx.<span class="title function_">scale</span>(-<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">  ctx.<span class="property">font</span> = <span class="string">&#x27;48px serif&#x27;</span>;</span><br><span class="line">  ctx.<span class="title function_">fillText</span>(<span class="string">&#x27;MDN&#x27;</span>, -<span class="number">135</span>, <span class="number">120</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://threejs-1251830808.cos.ap-guangzhou.myqcloud.com/1667227651471-39bb0784-882f-4fca-8b89-4702ac5fae3e.png" alt="img"></p><h2 id="-52"><a href="#-52" class="headerlink" title=" "></a> </h2><h2 id="变形-Transforms"><a href="#变形-Transforms" class="headerlink" title="变形 Transforms"></a>变形 Transforms</h2><p>最后一个方法允许对变形矩阵直接修改。</p><p>transform(a, b, c, d, e, f)</p><p>这个方法是将当前的变形矩阵乘上一个基于自身参数的矩阵，如下面的矩阵所示：</p><p><img src="https://threejs-1251830808.cos.ap-guangzhou.myqcloud.com/1667227677196-4449db4d-89f3-447a-b8fc-e6c8bb1e3597.png" alt="img"></p><p>如果任意一个参数是Infinity，变形矩阵也必须被标记为无限大，否则会抛出异常。</p><p>这个函数的参数各自代表如下：</p><p>a (m11)</p><p>水平方向的缩放</p><p>b(m12)</p><p>竖直方向的倾斜偏移</p><p>c(m21)</p><p>水平方向的倾斜偏移</p><p>d(m22)</p><p>竖直方向的缩放</p><p>e(dx)</p><p>水平方向的移动</p><p>f(dy)</p><p>竖直方向的移动</p><p>setTransform(a, b, c, d, e, f)</p><p>这个方法会将当前的变形矩阵重置为单位矩阵，然后用相同的参数调用 transform方法。如果任意一个参数是无限大，那么变形矩阵也必须被标记为无限大，否则会抛出异常。从根本上来说，该方法是取消了当前变形，然后设置为指定的变形，一步完成。</p><p>resetTransform()</p><p>重置当前变形为单位矩阵，它和调用以下语句是一样的：ctx.setTransform(1, 0, 0, 1, 0, 0);</p><h3 id="-53"><a href="#-53" class="headerlink" title=" "></a> </h3><h3 id="transform-setTransform的例子"><a href="#transform-setTransform的例子" class="headerlink" title="transform/setTransform的例子"></a>transform/setTransform的例子</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">draw</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> ctx = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;canvas&#x27;</span>).<span class="title function_">getContext</span>(<span class="string">&#x27;2d&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> sin = <span class="title class_">Math</span>.<span class="title function_">sin</span>(<span class="title class_">Math</span>.<span class="property">PI</span>/<span class="number">6</span>);</span><br><span class="line">  <span class="keyword">var</span> cos = <span class="title class_">Math</span>.<span class="title function_">cos</span>(<span class="title class_">Math</span>.<span class="property">PI</span>/<span class="number">6</span>);</span><br><span class="line">  ctx.<span class="title function_">translate</span>(<span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line">  <span class="keyword">var</span> c = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i &lt;= <span class="number">12</span>; i++) &#123;</span><br><span class="line">    c = <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="number">255</span> / <span class="number">12</span> * i);</span><br><span class="line">    ctx.<span class="property">fillStyle</span> = <span class="string">&quot;rgb(&quot;</span> + c + <span class="string">&quot;,&quot;</span> + c + <span class="string">&quot;,&quot;</span> + c + <span class="string">&quot;)&quot;</span>;</span><br><span class="line">    ctx.<span class="title function_">fillRect</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">100</span>, <span class="number">10</span>);</span><br><span class="line">    ctx.<span class="title function_">transform</span>(cos, sin, -sin, cos, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ctx.<span class="title function_">setTransform</span>(-<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line">  ctx.<span class="property">fillStyle</span> = <span class="string">&quot;rgba(255, 128, 255, 0.5)&quot;</span>;</span><br><span class="line">  ctx.<span class="title function_">fillRect</span>(<span class="number">0</span>, <span class="number">50</span>, <span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://threejs-1251830808.cos.ap-guangzhou.myqcloud.com/1667227715479-23deabde-be76-40c7-b5f0-0db094287d9f.png" alt="img"></p><h1 id="06-合成"><a href="#06-合成" class="headerlink" title="06-合成"></a>06-合成</h1><p><img src="https://threejs-1251830808.cos.ap-guangzhou.myqcloud.com/1668396610315-3bcf343e-80cc-4a7a-8aeb-2590b0f76f6d.png" alt="img"></p><p>我们总是将一个图形画在另一个之上，对于其他更多的情况，仅仅这样是远远不够的。比如，对合成的图形来说，绘制顺序会有限制。不过，我们可以利用 globalCompositeOperation  属性来改变这种状况。此外，clip属性允许我们隐藏不想看到的部分图形。这个刮刮乐的案例就需要用到globalCompositeOperation 属性</p><h2 id="-54"><a href="#-54" class="headerlink" title=" "></a> </h2><h2 id="globalCompositeOperation"><a href="#globalCompositeOperation" class="headerlink" title="globalCompositeOperation"></a>globalCompositeOperation</h2><p>我们不仅可以在已有图形后面再画新图形，还可以用来遮盖指定区域，清除画布中的某些部分（清除区域不仅限于矩形，像clearRect()方法做的那样）以及更多其他操作。</p><p>globalCompositeOperation = type</p><p>这个属性设定了在画新图形时采用的遮盖策略，其值是一个标识 12 种遮盖方式的字符串。</p><p>查看下面Compositing 示例的代码。</p><p><img src="https://threejs-1251830808.cos.ap-guangzhou.myqcloud.com/1667109996773-cc3490b4-fcc0-440b-a78a-563a22c87ec9.png" alt="img"></p><p><img src="https://threejs-1251830808.cos.ap-guangzhou.myqcloud.com/1667110038147-e02ef7a9-286f-4caf-b11a-052404004c4b.png" alt="img"></p><p><img src="https://threejs-1251830808.cos.ap-guangzhou.myqcloud.com/1667110060118-a77bca85-5791-411a-baf3-f23448125b8b.png" alt="img"></p><p><img src="https://threejs-1251830808.cos.ap-guangzhou.myqcloud.com/1667110101069-d2835e2a-8e88-41f0-9b76-35a20c887f5d.png" alt="img"></p><p><img src="https://threejs-1251830808.cos.ap-guangzhou.myqcloud.com/1667110185013-56c094f6-4a88-490b-9a90-1177963acd1c.png" alt="img"></p><p><img src="https://threejs-1251830808.cos.ap-guangzhou.myqcloud.com/1667110207449-ea21b03d-ff30-4b18-a2ea-471b385896f6.png" alt="img"></p><p><img src="https://threejs-1251830808.cos.ap-guangzhou.myqcloud.com/1667110229371-841a71a6-7c64-4c8e-b6c6-18859a227c9f.png" alt="img"></p><p><img src="https://threejs-1251830808.cos.ap-guangzhou.myqcloud.com/1667110255686-de491c8c-3e75-4ed4-aa95-b3beec319ae0.png" alt="img"></p><p><img src="https://threejs-1251830808.cos.ap-guangzhou.myqcloud.com/1667110271165-f69f9053-1d37-41c8-8d00-d47ebbfe691a.png" alt="img"></p><h1 id="07-剪裁"><a href="#07-剪裁" class="headerlink" title="07-剪裁"></a>07-剪裁</h1><h2 id="裁切路径"><a href="#裁切路径" class="headerlink" title="裁切路径"></a>裁切路径</h2><p><img src="https://threejs-1251830808.cos.ap-guangzhou.myqcloud.com/1667110508409-e7532df3-4c14-4c79-a61a-f9b7b2a51f0f.png" alt="img"></p><p>裁切路径和普通的 canvas 图形差不多，不同的是它的作用是遮罩，用来隐藏不需要的部分。如右图所示。红边五角星就是裁切路径，所有在路径以外的部分都不会在 canvas 上绘制出来。</p><p>如果和上面介绍的 globalCompositeOperation 属性作一比较，它可以实现与 source-in 和  source-atop差不多的效果。最重要的区别是裁切路径不会在 canvas  上绘制东西，而且它永远不受新图形的影响。这些特性使得它在特定区域里绘制图形时相当好用。</p><p>在 绘制图形 一章中，我只介绍了 stroke 和 fill 方法，这里介绍第三个方法clip。</p><p>clip()</p><p>将当前正在构建的路径转换为当前的裁剪路径。</p><p>我们使用 clip()方法来创建一个新的裁切路径。</p><p>默认情况下，canvas 有一个与它自身一样大的裁切路径（也就是没有裁切效果）。</p><h3 id="-55"><a href="#-55" class="headerlink" title=" "></a> </h3><h3 id="clip的例子"><a href="#clip的例子" class="headerlink" title="clip的例子"></a>clip的例子</h3><p>这个例子，我会用一个圆形的裁切路径来限制随机星星的绘制区域。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">function draw() &#123;</span><br><span class="line">  var ctx = document.getElementById(&#x27;canvas&#x27;).getContext(&#x27;2d&#x27;);</span><br><span class="line">  ctx.fillRect(0,0,150,150);</span><br><span class="line">  ctx.translate(75,75);</span><br><span class="line"></span><br><span class="line">  // Create a circular clipping path</span><br><span class="line">  ctx.beginPath();</span><br><span class="line">  ctx.arc(0,0,60,0,Math.PI*2,true);</span><br><span class="line">  ctx.clip();</span><br><span class="line"></span><br><span class="line">  // draw background</span><br><span class="line">  var lingrad = ctx.createLinearGradient(0,-75,0,75);</span><br><span class="line">  lingrad.addColorStop(0, &#x27;#232256&#x27;);</span><br><span class="line">  lingrad.addColorStop(1, &#x27;#143778&#x27;);</span><br><span class="line"></span><br><span class="line">  ctx.fillStyle = lingrad;</span><br><span class="line">  ctx.fillRect(-75,-75,150,150);</span><br><span class="line"></span><br><span class="line">  // draw stars</span><br><span class="line">  for (var j=1;j&lt;50;j++)&#123;</span><br><span class="line">    ctx.save();</span><br><span class="line">    ctx.fillStyle = &#x27;#fff&#x27;;</span><br><span class="line">    ctx.translate(75-Math.floor(Math.random()*150),</span><br><span class="line">                  75-Math.floor(Math.random()*150));</span><br><span class="line">    drawStar(ctx,Math.floor(Math.random()*4)+2);</span><br><span class="line">    ctx.restore();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">function drawStar(ctx,r)&#123;</span><br><span class="line">  ctx.save();</span><br><span class="line">  ctx.beginPath()</span><br><span class="line">  ctx.moveTo(r,0);</span><br><span class="line">  for (var i=0;i&lt;9;i++)&#123;</span><br><span class="line">    ctx.rotate(Math.PI/5);</span><br><span class="line">    if(i%2 == 0) &#123;</span><br><span class="line">      ctx.lineTo((r/0.525731)*0.200811,0);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      ctx.lineTo(r,0);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ctx.closePath();</span><br><span class="line">  ctx.fill();</span><br><span class="line">  ctx.restore();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，我画了一个与 canvas 一样大小的黑色方形作为背景，然后移动原点至中心点。然后用 clip 方法创建一个弧形的裁切路径。裁切路径也属于 canvas  状态的一部分，可以被保存起来。如果我们在创建新裁切路径时想保留原来的裁切路径，我们需要做的就是保存一下 canvas 的状态。</p><p>裁切路径创建之后所有出现在它里面的东西才会画出来。在画线性渐变时我们就会注意到这点。然后会绘制出 50 颗随机位置分布（经过缩放）的星星，当然也只有在裁切路径里面的星星才会绘制出来。</p><p><img src="https://threejs-1251830808.cos.ap-guangzhou.myqcloud.com/1667110658524-fbc7a711-50c5-439a-8b0e-029f8880169b.png" alt="img"></p><h1 id="08-基本的动画"><a href="#08-基本的动画" class="headerlink" title="08-基本的动画"></a>08-基本的动画</h1><p><img src="https://threejs-1251830808.cos.ap-guangzhou.myqcloud.com/1668396969271-76770864-e005-4080-82a2-ec02c0e972cc.png" alt="img"></p><p>由于我们是用 JavaScript 去操控 canvas 对象，这样要实现一些交互动画也是相当容易的。在本章中，我们将看看如何做一些基本的动画。</p><p>可能最大的限制就是图像一旦绘制出来，它就是一直保持那样了。如果需要移动它，我们不得不对所有东西（包括之前的）进行重绘。重绘是相当费时的，而且性能很依赖于电脑的速度。</p><h2 id="-56"><a href="#-56" class="headerlink" title=" "></a> </h2><h2 id="动画的基本步骤"><a href="#动画的基本步骤" class="headerlink" title="动画的基本步骤"></a>动画的基本步骤</h2><p>你可以通过以下的步骤来画出一帧：</p><ol><li><strong>清空 canvas</strong> 除非接下来要画的内容会完全充满 canvas（例如背景图），否则你需要清空所有。最简单的做法就是用 clearRect 方法。</li><li><strong>保存 canvas 状态</strong> 如果你要改变一些会改变 canvas 状态的设置（样式，变形之类的），又要在每画一帧之时都是原始状态的话，你需要先保存一下。</li><li><strong>绘制动画图形（animated shapes）</strong> 这一步才是重绘动画帧。</li><li><strong>恢复 canvas 状态</strong> 如果已经保存了 canvas 的状态，可以先恢复它，然后重绘下一帧。</li></ol><h2 id="-57"><a href="#-57" class="headerlink" title=" "></a> </h2><h2 id="操控动画-Controlling-an-animation"><a href="#操控动画-Controlling-an-animation" class="headerlink" title="操控动画 Controlling an animation"></a>操控动画 Controlling an animation</h2><p>在 canvas 上绘制内容是用 canvas 提供的或者自定义的方法，而通常，我们仅仅在脚本执行结束后才能看见结果，比如说，在 for 循环里面做完成动画是不太可能的。</p><p>因此，为了实现动画，我们需要一些可以定时执行重绘的方法。有两种方法可以实现这样的动画操控。首先可以通过 setInterval 和 setTimeout 方法来控制在设定的时间点上执行重绘。</p><h3 id="-58"><a href="#-58" class="headerlink" title=" "></a> </h3><h3 id="有安排的更新画布Scheduled-updates"><a href="#有安排的更新画布Scheduled-updates" class="headerlink" title="有安排的更新画布Scheduled updates"></a>有安排的更新画布Scheduled updates</h3><p>首先，可以用window.setInterval(), window.setTimeout(),和window.requestAnimationFrame()来设定定期执行一个指定函数。</p><p>setInterval(function, delay)(en-US)</p><p>当设定好间隔时间后，function 会定期执行。</p><p>setTimeout(function, delay)(en-US)</p><p>在设定好的时间之后执行函数</p><p>requestAnimationFrame(callback)</p><p>告诉浏览器你希望执行一个动画，并在重绘之前，请求浏览器执行一个特定的函数来更新动画。</p><p>如果你并不需要与用户互动，你可以使用 setInterval() 方法，它就可以定期执行指定代码。如果我们需要做一个游戏，我们可以使用键盘或者鼠标事件配合上 setTimeout() 方法来实现。通过设置事件监听，我们可以捕捉用户的交互，并执行相应的动作。</p><p>下面的例子，采用 window.requestAnimationFrame()实现动画效果。这个方法提供了更加平缓并更加有效率的方式来执行动画，当系统准备好了重绘条件的时候，才调用绘制动画帧。一般每秒钟回调函数执行 60 次，也有可能会被降低。</p><h2 id="-59"><a href="#-59" class="headerlink" title=" "></a> </h2><h2 id="太阳系的动画"><a href="#太阳系的动画" class="headerlink" title="太阳系的动画"></a>太阳系的动画</h2><p>这个例子里面，我会做一个小型的太阳系模拟动画。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sun = <span class="keyword">new</span> <span class="title class_">Image</span>();</span><br><span class="line"><span class="keyword">var</span> moon = <span class="keyword">new</span> <span class="title class_">Image</span>();</span><br><span class="line"><span class="keyword">var</span> earth = <span class="keyword">new</span> <span class="title class_">Image</span>();</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">init</span>(<span class="params"></span>)&#123;</span><br><span class="line">  sun.<span class="property">src</span> = <span class="string">&#x27;https://mdn.mozillademos.org/files/1456/Canvas_sun.png&#x27;</span>;</span><br><span class="line">  moon.<span class="property">src</span> = <span class="string">&#x27;https://mdn.mozillademos.org/files/1443/Canvas_moon.png&#x27;</span>;</span><br><span class="line">  earth.<span class="property">src</span> = <span class="string">&#x27;https://mdn.mozillademos.org/files/1429/Canvas_earth.png&#x27;</span>;</span><br><span class="line">  <span class="variable language_">window</span>.<span class="title function_">requestAnimationFrame</span>(draw);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">draw</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> ctx = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;canvas&#x27;</span>).<span class="title function_">getContext</span>(<span class="string">&#x27;2d&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  ctx.<span class="property">globalCompositeOperation</span> = <span class="string">&#x27;destination-over&#x27;</span>;</span><br><span class="line">  ctx.<span class="title function_">clearRect</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">300</span>,<span class="number">300</span>); <span class="comment">// clear canvas</span></span><br><span class="line"></span><br><span class="line">  ctx.<span class="property">fillStyle</span> = <span class="string">&#x27;rgba(0,0,0,0.4)&#x27;</span>;</span><br><span class="line">  ctx.<span class="property">strokeStyle</span> = <span class="string">&#x27;rgba(0,153,255,0.4)&#x27;</span>;</span><br><span class="line">  ctx.<span class="title function_">save</span>();</span><br><span class="line">  ctx.<span class="title function_">translate</span>(<span class="number">150</span>,<span class="number">150</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Earth</span></span><br><span class="line">  <span class="keyword">var</span> time = <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">  ctx.<span class="title function_">rotate</span>( ((<span class="number">2</span>*<span class="title class_">Math</span>.<span class="property">PI</span>)/<span class="number">60</span>)*time.<span class="title function_">getSeconds</span>() + ((<span class="number">2</span>*<span class="title class_">Math</span>.<span class="property">PI</span>)/<span class="number">60000</span>)*time.<span class="title function_">getMilliseconds</span>() );</span><br><span class="line">  ctx.<span class="title function_">translate</span>(<span class="number">105</span>,<span class="number">0</span>);</span><br><span class="line">  ctx.<span class="title function_">fillRect</span>(<span class="number">0</span>,-<span class="number">12</span>,<span class="number">50</span>,<span class="number">24</span>); <span class="comment">// Shadow</span></span><br><span class="line">  ctx.<span class="title function_">drawImage</span>(earth,-<span class="number">12</span>,-<span class="number">12</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Moon</span></span><br><span class="line">  ctx.<span class="title function_">save</span>();</span><br><span class="line">  ctx.<span class="title function_">rotate</span>( ((<span class="number">2</span>*<span class="title class_">Math</span>.<span class="property">PI</span>)/<span class="number">6</span>)*time.<span class="title function_">getSeconds</span>() + ((<span class="number">2</span>*<span class="title class_">Math</span>.<span class="property">PI</span>)/<span class="number">6000</span>)*time.<span class="title function_">getMilliseconds</span>() );</span><br><span class="line">  ctx.<span class="title function_">translate</span>(<span class="number">0</span>,<span class="number">28.5</span>);</span><br><span class="line">  ctx.<span class="title function_">drawImage</span>(moon,-<span class="number">3.5</span>,-<span class="number">3.5</span>);</span><br><span class="line">  ctx.<span class="title function_">restore</span>();</span><br><span class="line"></span><br><span class="line">  ctx.<span class="title function_">restore</span>();</span><br><span class="line"></span><br><span class="line">  ctx.<span class="title function_">beginPath</span>();</span><br><span class="line">  ctx.<span class="title function_">arc</span>(<span class="number">150</span>,<span class="number">150</span>,<span class="number">105</span>,<span class="number">0</span>,<span class="title class_">Math</span>.<span class="property">PI</span>*<span class="number">2</span>,<span class="literal">false</span>); <span class="comment">// Earth orbit</span></span><br><span class="line">  ctx.<span class="title function_">stroke</span>();</span><br><span class="line"></span><br><span class="line">  ctx.<span class="title function_">drawImage</span>(sun,<span class="number">0</span>,<span class="number">0</span>,<span class="number">300</span>,<span class="number">300</span>);</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">window</span>.<span class="title function_">requestAnimationFrame</span>(draw);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">init</span>();</span><br></pre></td></tr></table></figure><h2 id="动画时钟"><a href="#动画时钟" class="headerlink" title="动画时钟"></a>动画时钟</h2><p>这个例子实现一个动态时钟，可以显示当前时间。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">clock</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">var</span> now = <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">  <span class="keyword">var</span> ctx = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;canvas&#x27;</span>).<span class="title function_">getContext</span>(<span class="string">&#x27;2d&#x27;</span>);</span><br><span class="line">  ctx.<span class="title function_">save</span>();</span><br><span class="line">  ctx.<span class="title function_">clearRect</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">150</span>,<span class="number">150</span>);</span><br><span class="line">  ctx.<span class="title function_">translate</span>(<span class="number">75</span>,<span class="number">75</span>);</span><br><span class="line">  ctx.<span class="title function_">scale</span>(<span class="number">0.4</span>,<span class="number">0.4</span>);</span><br><span class="line">  ctx.<span class="title function_">rotate</span>(-<span class="title class_">Math</span>.<span class="property">PI</span>/<span class="number">2</span>);</span><br><span class="line">  ctx.<span class="property">strokeStyle</span> = <span class="string">&quot;black&quot;</span>;</span><br><span class="line">  ctx.<span class="property">fillStyle</span> = <span class="string">&quot;white&quot;</span>;</span><br><span class="line">  ctx.<span class="property">lineWidth</span> = <span class="number">8</span>;</span><br><span class="line">  ctx.<span class="property">lineCap</span> = <span class="string">&quot;round&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Hour marks</span></span><br><span class="line">  ctx.<span class="title function_">save</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">12</span>;i++)&#123;</span><br><span class="line">    ctx.<span class="title function_">beginPath</span>();</span><br><span class="line">    ctx.<span class="title function_">rotate</span>(<span class="title class_">Math</span>.<span class="property">PI</span>/<span class="number">6</span>);</span><br><span class="line">    ctx.<span class="title function_">moveTo</span>(<span class="number">100</span>,<span class="number">0</span>);</span><br><span class="line">    ctx.<span class="title function_">lineTo</span>(<span class="number">120</span>,<span class="number">0</span>);</span><br><span class="line">    ctx.<span class="title function_">stroke</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  ctx.<span class="title function_">restore</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Minute marks</span></span><br><span class="line">  ctx.<span class="title function_">save</span>();</span><br><span class="line">  ctx.<span class="property">lineWidth</span> = <span class="number">5</span>;</span><br><span class="line">  <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;<span class="number">60</span>;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span> (i%<span class="number">5</span>!=<span class="number">0</span>) &#123;</span><br><span class="line">      ctx.<span class="title function_">beginPath</span>();</span><br><span class="line">      ctx.<span class="title function_">moveTo</span>(<span class="number">117</span>,<span class="number">0</span>);</span><br><span class="line">      ctx.<span class="title function_">lineTo</span>(<span class="number">120</span>,<span class="number">0</span>);</span><br><span class="line">      ctx.<span class="title function_">stroke</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    ctx.<span class="title function_">rotate</span>(<span class="title class_">Math</span>.<span class="property">PI</span>/<span class="number">30</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  ctx.<span class="title function_">restore</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> sec = now.<span class="title function_">getSeconds</span>();</span><br><span class="line">  <span class="keyword">var</span> min = now.<span class="title function_">getMinutes</span>();</span><br><span class="line">  <span class="keyword">var</span> hr  = now.<span class="title function_">getHours</span>();</span><br><span class="line">  hr = hr&gt;=<span class="number">12</span> ? hr-<span class="number">12</span> : hr;</span><br><span class="line"></span><br><span class="line">  ctx.<span class="property">fillStyle</span> = <span class="string">&quot;black&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// write Hours</span></span><br><span class="line">  ctx.<span class="title function_">save</span>();</span><br><span class="line">  ctx.<span class="title function_">rotate</span>( hr*(<span class="title class_">Math</span>.<span class="property">PI</span>/<span class="number">6</span>) + (<span class="title class_">Math</span>.<span class="property">PI</span>/<span class="number">360</span>)*min + (<span class="title class_">Math</span>.<span class="property">PI</span>/<span class="number">21600</span>)*sec )</span><br><span class="line">  ctx.<span class="property">lineWidth</span> = <span class="number">14</span>;</span><br><span class="line">  ctx.<span class="title function_">beginPath</span>();</span><br><span class="line">  ctx.<span class="title function_">moveTo</span>(-<span class="number">20</span>,<span class="number">0</span>);</span><br><span class="line">  ctx.<span class="title function_">lineTo</span>(<span class="number">80</span>,<span class="number">0</span>);</span><br><span class="line">  ctx.<span class="title function_">stroke</span>();</span><br><span class="line">  ctx.<span class="title function_">restore</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// write Minutes</span></span><br><span class="line">  ctx.<span class="title function_">save</span>();</span><br><span class="line">  ctx.<span class="title function_">rotate</span>( (<span class="title class_">Math</span>.<span class="property">PI</span>/<span class="number">30</span>)*min + (<span class="title class_">Math</span>.<span class="property">PI</span>/<span class="number">1800</span>)*sec )</span><br><span class="line">  ctx.<span class="property">lineWidth</span> = <span class="number">10</span>;</span><br><span class="line">  ctx.<span class="title function_">beginPath</span>();</span><br><span class="line">  ctx.<span class="title function_">moveTo</span>(-<span class="number">28</span>,<span class="number">0</span>);</span><br><span class="line">  ctx.<span class="title function_">lineTo</span>(<span class="number">112</span>,<span class="number">0</span>);</span><br><span class="line">  ctx.<span class="title function_">stroke</span>();</span><br><span class="line">  ctx.<span class="title function_">restore</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Write seconds</span></span><br><span class="line">  ctx.<span class="title function_">save</span>();</span><br><span class="line">  ctx.<span class="title function_">rotate</span>(sec * <span class="title class_">Math</span>.<span class="property">PI</span>/<span class="number">30</span>);</span><br><span class="line">  ctx.<span class="property">strokeStyle</span> = <span class="string">&quot;#D40000&quot;</span>;</span><br><span class="line">  ctx.<span class="property">fillStyle</span> = <span class="string">&quot;#D40000&quot;</span>;</span><br><span class="line">  ctx.<span class="property">lineWidth</span> = <span class="number">6</span>;</span><br><span class="line">  ctx.<span class="title function_">beginPath</span>();</span><br><span class="line">  ctx.<span class="title function_">moveTo</span>(-<span class="number">30</span>,<span class="number">0</span>);</span><br><span class="line">  ctx.<span class="title function_">lineTo</span>(<span class="number">83</span>,<span class="number">0</span>);</span><br><span class="line">  ctx.<span class="title function_">stroke</span>();</span><br><span class="line">  ctx.<span class="title function_">beginPath</span>();</span><br><span class="line">  ctx.<span class="title function_">arc</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">10</span>,<span class="number">0</span>,<span class="title class_">Math</span>.<span class="property">PI</span>*<span class="number">2</span>,<span class="literal">true</span>);</span><br><span class="line">  ctx.<span class="title function_">fill</span>();</span><br><span class="line">  ctx.<span class="title function_">beginPath</span>();</span><br><span class="line">  ctx.<span class="title function_">arc</span>(<span class="number">95</span>,<span class="number">0</span>,<span class="number">10</span>,<span class="number">0</span>,<span class="title class_">Math</span>.<span class="property">PI</span>*<span class="number">2</span>,<span class="literal">true</span>);</span><br><span class="line">  ctx.<span class="title function_">stroke</span>();</span><br><span class="line">  ctx.<span class="property">fillStyle</span> = <span class="string">&quot;rgba(0,0,0,0)&quot;</span>;</span><br><span class="line">  ctx.<span class="title function_">arc</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="title class_">Math</span>.<span class="property">PI</span>*<span class="number">2</span>,<span class="literal">true</span>);</span><br><span class="line">  ctx.<span class="title function_">fill</span>();</span><br><span class="line">  ctx.<span class="title function_">restore</span>();</span><br><span class="line"></span><br><span class="line">  ctx.<span class="title function_">beginPath</span>();</span><br><span class="line">  ctx.<span class="property">lineWidth</span> = <span class="number">14</span>;</span><br><span class="line">  ctx.<span class="property">strokeStyle</span> = <span class="string">&#x27;#325FA2&#x27;</span>;</span><br><span class="line">  ctx.<span class="title function_">arc</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">142</span>,<span class="number">0</span>,<span class="title class_">Math</span>.<span class="property">PI</span>*<span class="number">2</span>,<span class="literal">true</span>);</span><br><span class="line">  ctx.<span class="title function_">stroke</span>();</span><br><span class="line"></span><br><span class="line">  ctx.<span class="title function_">restore</span>();</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">window</span>.<span class="title function_">requestAnimationFrame</span>(clock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">requestAnimationFrame</span>(clock);</span><br></pre></td></tr></table></figure><h1 id="09-像素操作"><a href="#09-像素操作" class="headerlink" title="09-像素操作"></a>09-像素操作</h1><p><img src="https://threejs-1251830808.cos.ap-guangzhou.myqcloud.com/1668397235760-c2217634-7644-4a76-8f6c-dd97c860dd6c.gif" alt="img"></p><p>到目前为止，我们尚未深入了解 Canvas 画布真实像素的原理，事实上，你可以直接通过 ImageData 对象操纵像素数据，直接读取或将数据数组写入该对象中。稍后我们也将深入了解如何控制图像使其平滑（反锯齿）以及如何从 Canvas 画布中保存图像。</p><h2 id="-60"><a href="#-60" class="headerlink" title=" "></a> </h2><h2 id="ImageData-对象"><a href="#ImageData-对象" class="headerlink" title="ImageData 对象"></a>ImageData 对象</h2><p>ImageData对象中存储着 canvas 对象真实的像素数据，它包含以下几个只读属性：</p><p>width</p><p>图片宽度，单位是像素</p><p>height</p><p>图片高度，单位是像素</p><p>data</p><p>Uint8ClampedArray 类型的一维数组，包含着 RGBA 格式的整型数据，范围在 0 至 255 之间（包括 255）。</p><p>data 属性返回一个 Uint8ClampedArray，它可以被使用作为查看初始像素数据。每个像素用 4 个 1bytes 值  (按照红，绿，蓝和透明值的顺序; 这就是”RGBA”格式) 来代表。每个颜色值部份用 0 至 255  来代表。每个部份被分配到一个在数组内连续的索引，左上角像素的红色部份在数组的索引 0 位置。像素从左到右被处理，然后往下，遍历整个数组。</p><p>Uint8ClampedArray 包含高度 × 宽度 × 4 bytes 数据，索引值从 0 到 (高度× 宽度 ×4)-1</p><p>例如，要读取图片中位于第 50 行，第 200 列的像素的蓝色部份，你会写以下代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">blueComponent = imageData.<span class="property">data</span>[((<span class="number">50</span> * (imageData.<span class="property">width</span> * <span class="number">4</span>)) + (<span class="number">200</span> * <span class="number">4</span>)) + <span class="number">2</span>];</span><br></pre></td></tr></table></figure><p>根据行、列读取某像素点的 R/G/B/A 值的公式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">imageData.<span class="property">data</span>[((<span class="number">50</span> * (imageData.<span class="property">width</span> * <span class="number">4</span>)) + (<span class="number">200</span> * <span class="number">4</span>)) + <span class="number">0</span>/<span class="number">1</span>/<span class="number">2</span>/<span class="number">3</span>];</span><br></pre></td></tr></table></figure><p>你可能用会使用 Uint8ClampedArray.length 属性来读取像素数组的大小（以 bytes 为单位）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> numBytes = imageData.<span class="property">data</span>.<span class="property">length</span>;</span><br></pre></td></tr></table></figure><h2 id="创建一个-ImageData-对象"><a href="#创建一个-ImageData-对象" class="headerlink" title="创建一个 ImageData 对象"></a>创建一个 ImageData 对象</h2><p>去创建一个新的，空白的 ImageData对象，你应该会使用createImageData() 方法。有 2 个版本的 createImageData() 方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myImageData = ctx.<span class="title function_">createImageData</span>(width, height);</span><br></pre></td></tr></table></figure><p>上面代码创建了一个新的具体特定尺寸的 ImageData对象。所有像素被预设为透明黑。</p><p>你也可以创建一个被 anotherImageData对象指定的相同像素的 ImageData对象。这个新的对象像素全部被预设为透明黑。这个并非复制了图片数据。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myImageData = ctx.<span class="title function_">createImageData</span>(anotherImageData);</span><br></pre></td></tr></table></figure><h2 id="得到场景像素数据"><a href="#得到场景像素数据" class="headerlink" title="得到场景像素数据"></a>得到场景像素数据</h2><p>为了获得一个包含画布场景像素数据的 ImageData 对像，你可以用 getImageData() 方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myImageData = ctx.<span class="title function_">getImageData</span>(left, top, width, height);</span><br></pre></td></tr></table></figure><p>这个方法会返回一个 ImageData对象，它代表了画布区域的对象数据，此画布的四个角落分别表示为 (left, top), (left + width,  top), (left, top + height), 以及 (left + width, top + height)  四个点。这些坐标点被设定为画布坐标空间元素。</p><p>任何在画布以外的元素都会被返回成一个透明黑的 ImageData 对像。</p><h3 id="-61"><a href="#-61" class="headerlink" title=" "></a> </h3><h3 id="颜色选择器"><a href="#颜色选择器" class="headerlink" title="颜色选择器"></a>颜色选择器</h3><p>在这个例子里面，我们会使用getImageData()去展示鼠标光标下的颜色。为此，我们要当前鼠标的位置，记为 layerX 和  layerY，然后我们去查询getImageData()给我们提供的在那个位置的像数数组里面的像素数据。最后我们使用数组数据去设置背景颜色和div的文字去展示颜色值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> img = <span class="keyword">new</span> <span class="title class_">Image</span>();</span><br><span class="line">img.<span class="property">crossOrigin</span> = <span class="string">&#x27;anonymous&#x27;</span>;</span><br><span class="line">img.<span class="property">src</span> = <span class="string">&#x27;./assets/rhino.jpg&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> canvas = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;canvas&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> ctx = canvas.<span class="title function_">getContext</span>(<span class="string">&#x27;2d&#x27;</span>);</span><br><span class="line">img.<span class="property">onload</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  ctx.<span class="title function_">drawImage</span>(img, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">  img.<span class="property">style</span>.<span class="property">display</span> = <span class="string">&#x27;none&#x27;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> hoveredColor = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;hovered-color&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> selectedColor = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;selected-color&#x27;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">pick</span>(<span class="params">event, destination</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> x = event.<span class="property">layerX</span>;</span><br><span class="line">  <span class="keyword">var</span> y = event.<span class="property">layerY</span>;</span><br><span class="line">  <span class="keyword">var</span> pixel = ctx.<span class="title function_">getImageData</span>(x, y, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">var</span> data = pixel.<span class="property">data</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> rgba = <span class="string">`rgba(<span class="subst">$&#123;data[<span class="number">0</span>]&#125;</span>, <span class="subst">$&#123;data[<span class="number">1</span>]&#125;</span>, <span class="subst">$&#123;data[<span class="number">2</span>]&#125;</span>, <span class="subst">$&#123;data[<span class="number">3</span>] / <span class="number">255</span>&#125;</span>)`</span>;</span><br><span class="line">    destination.<span class="property">style</span>.<span class="property">background</span> = rgba;</span><br><span class="line">    destination.<span class="property">textContent</span> = rgba;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> rgba;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">canvas.<span class="title function_">addEventListener</span>(<span class="string">&#x27;mousemove&#x27;</span>, <span class="keyword">function</span>(<span class="params">event</span>) &#123;</span><br><span class="line">    <span class="title function_">pick</span>(event, hoveredColor);</span><br><span class="line">&#125;);</span><br><span class="line">canvas.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span>(<span class="params">event</span>) &#123;</span><br><span class="line">    <span class="title function_">pick</span>(event, selectedColor);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><img src="https://threejs-1251830808.cos.ap-guangzhou.myqcloud.com/1667111496158-a89a03f4-7def-438d-ac5f-bff66c5630d2.png" alt="img"></p><h2 id="-62"><a href="#-62" class="headerlink" title=" "></a> </h2><h2 id="在场景中写入像素数据"><a href="#在场景中写入像素数据" class="headerlink" title="在场景中写入像素数据"></a>在场景中写入像素数据</h2><p>你可以用 putImageData() 方法去对场景进行像素数据的写入。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctx.<span class="title function_">putImageData</span>(myImageData, dx, dy);</span><br></pre></td></tr></table></figure><p>dx 和 dy 参数表示你希望在场景内左上角绘制的像素数据所得到的设备坐标。</p><p>例如，为了在场景内左上角绘制 myImageData 代表的图片，你可以写如下的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctx.<span class="title function_">putImageData</span>(myImageData, <span class="number">0</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><h3 id="图片灰度和反相颜色"><a href="#图片灰度和反相颜色" class="headerlink" title="图片灰度和反相颜色"></a>图片灰度和反相颜色</h3><p>在这个例子里，我们遍历所有像素以改变他们的数值。然后我们将被修改的像素数组通过 putImageData() 放回到画布中去。invert 函数仅仅是去减掉颜色的最大色值 255.grayscale  函数仅仅是用红绿和蓝的平均值。你也可以用加权平均，例如 x = 0.299r + 0.587g + 0.114b  这个公式。更多资料请参考维基百科的Grayscale。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> img = <span class="keyword">new</span> <span class="title class_">Image</span>();</span><br><span class="line">img.<span class="property">crossOrigin</span> = <span class="string">&#x27;anonymous&#x27;</span>;</span><br><span class="line">img.<span class="property">src</span> = <span class="string">&#x27;./assets/rhino.jpg&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> canvas = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;canvas&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> ctx = canvas.<span class="title function_">getContext</span>(<span class="string">&#x27;2d&#x27;</span>);</span><br><span class="line"></span><br><span class="line">img.<span class="property">onload</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    ctx.<span class="title function_">drawImage</span>(img, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> original = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    ctx.<span class="title function_">drawImage</span>(img, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> invert = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    ctx.<span class="title function_">drawImage</span>(img, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">const</span> imageData = ctx.<span class="title function_">getImageData</span>(<span class="number">0</span>, <span class="number">0</span>, canvas.<span class="property">width</span>, canvas.<span class="property">height</span>);</span><br><span class="line">    <span class="keyword">const</span> data = imageData.<span class="property">data</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; data.<span class="property">length</span>; i += <span class="number">4</span>) &#123;</span><br><span class="line">        data[i]     = <span class="number">255</span> - data[i];     <span class="comment">// red</span></span><br><span class="line">        data[i + <span class="number">1</span>] = <span class="number">255</span> - data[i + <span class="number">1</span>]; <span class="comment">// green</span></span><br><span class="line">        data[i + <span class="number">2</span>] = <span class="number">255</span> - data[i + <span class="number">2</span>]; <span class="comment">// blue</span></span><br><span class="line">    &#125;</span><br><span class="line">    ctx.<span class="title function_">putImageData</span>(imageData, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> grayscale = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    ctx.<span class="title function_">drawImage</span>(img, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">const</span> imageData = ctx.<span class="title function_">getImageData</span>(<span class="number">0</span>, <span class="number">0</span>, canvas.<span class="property">width</span>, canvas.<span class="property">height</span>);</span><br><span class="line">    <span class="keyword">const</span> data = imageData.<span class="property">data</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; data.<span class="property">length</span>; i += <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> avg = (data[i] + data[i + <span class="number">1</span>] + data[i + <span class="number">2</span>]) / <span class="number">3</span>;</span><br><span class="line">        data[i]     = avg; <span class="comment">// red</span></span><br><span class="line">        data[i + <span class="number">1</span>] = avg; <span class="comment">// green</span></span><br><span class="line">        data[i + <span class="number">2</span>] = avg; <span class="comment">// blue</span></span><br><span class="line">    &#125;</span><br><span class="line">    ctx.<span class="title function_">putImageData</span>(imageData, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> inputs = <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;[name=color]&#x27;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> input <span class="keyword">of</span> inputs) &#123;</span><br><span class="line">    input.<span class="title function_">addEventListener</span>(<span class="string">&quot;change&quot;</span>, <span class="keyword">function</span>(<span class="params">evt</span>) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (evt.<span class="property">target</span>.<span class="property">value</span>) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;inverted&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="title function_">invert</span>();</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;grayscale&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="title function_">grayscale</span>();</span><br><span class="line">            <span class="attr">default</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="title function_">original</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://threejs-1251830808.cos.ap-guangzhou.myqcloud.com/1667111755370-7e0e3202-3d0c-4a39-9e96-57912ec84ff2.png" alt="img"></p><h2 id="-63"><a href="#-63" class="headerlink" title=" "></a> </h2><h2 id="缩放和反锯齿"><a href="#缩放和反锯齿" class="headerlink" title="缩放和反锯齿"></a>缩放和反锯齿</h2><p>在drawImage() 方法，第二个画布和imageSmoothingEnabled 属性的帮助下，我们可以放大显示我们的图片及看到详情内容。</p><p>我们得到鼠标的位置并裁剪出距左和上 5 像素，距右和下 5 像素的图片。然后我们将这幅图复制到另一个画布然后将图片调整到我们想要的大小。在缩放画布里，我们将 10×10 像素的对原画布的裁剪调整为 200×200。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">zoomctx.<span class="title function_">drawImage</span>(canvas,</span><br><span class="line">                  <span class="title class_">Math</span>.<span class="title function_">abs</span>(x - <span class="number">5</span>), <span class="title class_">Math</span>.<span class="title function_">abs</span>(y - <span class="number">5</span>),</span><br><span class="line">                  <span class="number">10</span>, <span class="number">10</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">200</span>, <span class="number">200</span>);</span><br></pre></td></tr></table></figure><p>imageSmoothingEnabled 属性的效果（不同浏览器需要不同前缀）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;canvas id=<span class="string">&quot;canvas&quot;</span> width=<span class="string">&quot;300&quot;</span> height=<span class="string">&quot;227&quot;</span>&gt;&lt;/canvas&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">canvas</span> <span class="attr">id</span>=<span class="string">&quot;zoom&quot;</span> <span class="attr">width</span>=<span class="string">&quot;300&quot;</span> <span class="attr">height</span>=<span class="string">&quot;227&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;smoothbtn&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;smoothbtn&quot;</span> <span class="attr">checked</span>=<span class="string">&quot;checked&quot;</span> <span class="attr">id</span>=<span class="string">&quot;smoothbtn&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  Enable image smoothing</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">label</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>ZOOM EXAMPLE</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">canvas</span> <span class="attr">id</span>=<span class="string">&quot;canvas&quot;</span> <span class="attr">width</span>=<span class="string">&quot;300&quot;</span> <span class="attr">height</span>=<span class="string">&quot;227&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">canvas</span> <span class="attr">id</span>=<span class="string">&quot;zoom&quot;</span> <span class="attr">width</span>=<span class="string">&quot;300&quot;</span> <span class="attr">height</span>=<span class="string">&quot;227&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;smoothbtn&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;smoothbtn&quot;</span> <span class="attr">checked</span>=<span class="string">&quot;checked&quot;</span> <span class="attr">id</span>=<span class="string">&quot;smoothbtn&quot;</span>&gt;</span></span><br><span class="line">    Enable image smoothing</span><br><span class="line">  <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>JavaScript</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> img = <span class="keyword">new</span> <span class="title class_">Image</span>();</span><br><span class="line">img.<span class="property">src</span> = <span class="string">&#x27;https://mdn.mozillademos.org/files/5397/rhino.jpg&#x27;</span>;</span><br><span class="line">img.<span class="property">onload</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title function_">draw</span>(<span class="variable language_">this</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">draw</span>(<span class="params">img</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> canvas = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;canvas&#x27;</span>);</span><br><span class="line">  <span class="keyword">var</span> ctx = canvas.<span class="title function_">getContext</span>(<span class="string">&#x27;2d&#x27;</span>);</span><br><span class="line">  ctx.<span class="title function_">drawImage</span>(img, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">  img.<span class="property">style</span>.<span class="property">display</span> = <span class="string">&#x27;none&#x27;</span>;</span><br><span class="line">  <span class="keyword">var</span> zoomctx = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;zoom&#x27;</span>).<span class="title function_">getContext</span>(<span class="string">&#x27;2d&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> smoothbtn = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;smoothbtn&#x27;</span>);</span><br><span class="line">  <span class="keyword">var</span> toggleSmoothing = <span class="keyword">function</span>(<span class="params">event</span>) &#123;</span><br><span class="line">    zoomctx.<span class="property">imageSmoothingEnabled</span> = <span class="variable language_">this</span>.<span class="property">checked</span>;</span><br><span class="line">    zoomctx.<span class="property">mozImageSmoothingEnabled</span> = <span class="variable language_">this</span>.<span class="property">checked</span>;</span><br><span class="line">    zoomctx.<span class="property">webkitImageSmoothingEnabled</span> = <span class="variable language_">this</span>.<span class="property">checked</span>;</span><br><span class="line">    zoomctx.<span class="property">msImageSmoothingEnabled</span> = <span class="variable language_">this</span>.<span class="property">checked</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">  smoothbtn.<span class="title function_">addEventListener</span>(<span class="string">&#x27;change&#x27;</span>, toggleSmoothing);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> zoom = <span class="keyword">function</span>(<span class="params">event</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> x = event.<span class="property">layerX</span>;</span><br><span class="line">    <span class="keyword">var</span> y = event.<span class="property">layerY</span>;</span><br><span class="line">    zoomctx.<span class="title function_">drawImage</span>(canvas,</span><br><span class="line">                      <span class="title class_">Math</span>.<span class="title function_">abs</span>(x - <span class="number">5</span>),</span><br><span class="line">                      <span class="title class_">Math</span>.<span class="title function_">abs</span>(y - <span class="number">5</span>),</span><br><span class="line">                      <span class="number">10</span>, <span class="number">10</span>,</span><br><span class="line">                      <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">                      <span class="number">200</span>, <span class="number">200</span>);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  canvas.<span class="title function_">addEventListener</span>(<span class="string">&#x27;mousemove&#x27;</span>, zoom);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="保存图片"><a href="#保存图片" class="headerlink" title="保存图片"></a>保存图片</h2><p>HTMLCanvasElement 提供一个 toDataURL() 方法，此方法在保存图片的时候非常有用。它返回一个包含被类型参数规定的图像表现格式的数据链接。返回的图片分辨率是 96dpi。</p><p>canvas.toDataURL(‘image/png’)</p><p>默认设定。创建一个 PNG 图片。</p><p>canvas.toDataURL(‘image/jpeg’, quality)</p><p>创建一个 JPG 图片。你可以有选择地提供从 0 到 1 的品质量，1 表示最好品质，0 基本不被辨析但有比较小的文件大小。</p><p>当你从画布中生成了一个数据链接，例如，你可以将它用于任何image元素，或者将它放在一个有 download 属性的超链接里用于保存到本地。</p><p>你也可以从画布中创建一个Blob对像。</p><p>canvas.toBlob(callback, type, encoderOptions)</p><p>这个创建了一个在画布中的代表图片的 Blob 对像。</p><h1 id="10-图形元素交回"><a href="#10-图形元素交回" class="headerlink" title="10-图形元素交回"></a>10-图形元素交回</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>isPointInPath()判断路径中是否包含监测点（作为参数传入）。</p><h2 id="-64"><a href="#-64" class="headerlink" title=" "></a> </h2><h2 id="isPointInPath-介绍"><a href="#isPointInPath-介绍" class="headerlink" title="isPointInPath()介绍"></a>isPointInPath()介绍</h2><p>方法 描述 boolean ctx.isPointInPath(x, y) 判断监测点(x，y)是否在路径内 boolean  ctx.isPointInPath(x, y, fillRule)  判断监测点(x，y)和路径的位置关系，通过fillRule来决定是路径内还是路径外。fillRule的可选参数是nonzero(非零环绕算法)和evenadd(奇偶环绕算法)</p><h3 id="-65"><a href="#-65" class="headerlink" title=" "></a> </h3><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>如果context.rect(10,10,100,100)，那么所有在这个路径内的点都能被isPointInPath(x,y)判断为true，如(50,50);</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canvas = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;canvas&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> ctx = canvas.<span class="title function_">getContext</span>(<span class="string">&quot;2d&quot;</span>);</span><br><span class="line"></span><br><span class="line">ctx.<span class="title function_">rect</span>(<span class="number">10</span>, <span class="number">10</span>, <span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line">ctx.<span class="title function_">stroke</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(ctx.<span class="title function_">isPointInPath</span>(<span class="number">10</span>, <span class="number">10</span>)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h2 id="sPointInStroke"><a href="#sPointInStroke" class="headerlink" title="sPointInStroke()"></a>sPointInStroke()</h2><p><strong>CanvasRenderingContext2D.isPointInStroke()</strong> 是 Canvas 2D API 用于检测某点是否在路径的描边线上的方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">boolean ctx.<span class="title function_">isPointInStroke</span>(x, y);</span><br><span class="line">boolean ctx.<span class="title function_">isPointInStroke</span>(path, x, y);</span><br></pre></td></tr></table></figure><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/isPointInStroke#参数">参数</a></h3><p>x 检测点的 X 坐标。 y 检测点的 Y 坐标。 path <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Path2D">Path2D</a></p><p> 路径。</p><h3 id="-66"><a href="#-66" class="headerlink" title=" "></a> </h3><h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/isPointInStroke#返回值">返回值</a></h3><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Boolean">Boolean</a></p><p> 一个布尔值，当这个点在路径的描边线上，则返回 true，否则返回 false。 这只是一个使用 <strong>isPointInStroke</strong> 方法的简单的代码片段，用于检测一个点是否在路径的描边线上。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canvas = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;canvas&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> ctx = canvas.<span class="title function_">getContext</span>(<span class="string">&quot;2d&quot;</span>);</span><br><span class="line"></span><br><span class="line">ctx.<span class="title function_">rect</span>(<span class="number">10</span>, <span class="number">10</span>, <span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line">ctx.<span class="title function_">stroke</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(ctx.<span class="title function_">isPointInStroke</span>(<span class="number">10</span>, <span class="number">10</span>)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h3 id="拖拽小方块"><a href="#拖拽小方块" class="headerlink" title="拖拽小方块"></a>拖拽小方块</h3><p>想要拖拽小方块，我们利用isPointInPath()来判断某一时刻鼠标是否在矩形路径内，如果在路径内，则切换方块为拖拽状态，设定拖拽的样式变化（如光标变小手等等），然后随着鼠标的按下移动通过不断地清除、设定路径、绘制此时刻图像来达成视觉上的拖拽的目的。 <img src="https://cdn.nlark.com/yuque/0/2022/png/22620727/1667053514433-a920e8d2-79c1-4c1c-9396-bab3567982fa.png#clientId=u1356ed4b-ca29-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=565&amp;id=u5029035f&amp;margin=[object Object]&amp;name=image.png&amp;originHeight=565&amp;originWidth=1086&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=90697&amp;status=done&amp;style=none&amp;taskId=u73aa02ed-4ab7-45a8-9be4-0fad61784c9&amp;title=&amp;width=1086" alt="image.png"> 另外有一些必要的细节，我们一定要注意：当鼠标按下拖拽的时候光标位置在矩形内的某个位置，那么在矩形移动后，光标也应该不断保持在矩形的那个位置。 <img src="https://cdn.nlark.com/yuque/0/2022/gif/22620727/1667053588638-9a7a04b0-8db4-4606-9660-39c8f5aaab81.gif#clientId=u1356ed4b-ca29-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=248&amp;id=u11194a8a&amp;margin=[object Object]&amp;name=gta8.gif&amp;originHeight=248&amp;originWidth=259&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=31920&amp;status=done&amp;style=none&amp;taskId=u23842d13-e08c-4869-97ff-e7d63963894&amp;title=&amp;width=259" alt="gta8.gif"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;拖拽小方块&lt;/title&gt;</span><br><span class="line"></span><br><span class="line">    &lt;style&gt;</span><br><span class="line">        #canvas &#123;</span><br><span class="line">            cursor: default;</span><br><span class="line">            border: 1px solid black;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;canvas id=&quot;canvas&quot; width=&quot;400&quot; height=&quot;400&quot;&gt;Canvas not supported&lt;/canvas&gt;</span><br><span class="line">&lt;p&gt;拖拽方块并实时重绘&lt;/p&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    &#x27;use strict&#x27;;</span><br><span class="line"></span><br><span class="line">    let canvas = document.getElementById(&#x27;canvas&#x27;),</span><br><span class="line">        context = canvas.getContext(&#x27;2d&#x27;),</span><br><span class="line"></span><br><span class="line">        //初始时的矩形属性</span><br><span class="line">        initX = 10,</span><br><span class="line">        initY = 10,</span><br><span class="line">        initWidth = 100,</span><br><span class="line">        initHeight = 100,</span><br><span class="line"></span><br><span class="line">        isDrag = false,</span><br><span class="line"></span><br><span class="line">        //多边形存储在这个地方</span><br><span class="line">        polygons = &#123;</span><br><span class="line">            fillStyle: &#x27;lightgray&#x27;,</span><br><span class="line">            strokeStyle: &#x27;blue&#x27;,</span><br><span class="line">            loc: &#123;x: 0, y: 0&#125;,</span><br><span class="line">            height: initHeight,</span><br><span class="line">            width: initWidth,</span><br><span class="line">            offsetX: 0,</span><br><span class="line">            offsetY: 0</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //Function……</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 绘制初试状态的矩形</span><br><span class="line">     */</span><br><span class="line">    let drawInitRect = () =&gt; &#123;</span><br><span class="line">        context.fillStyle = polygons.fillStyle;</span><br><span class="line">        context.strokeStyle = polygons.strokeStyle;</span><br><span class="line">        context.rect(initX, initY, initWidth, initHeight);</span><br><span class="line">        polygons.loc.x = initX;</span><br><span class="line">        polygons.loc.y = initY;</span><br><span class="line">        polygons.width = initWidth;</span><br><span class="line">        polygons.height = initHeight;</span><br><span class="line">        context.fill();</span><br><span class="line">        context.stroke();</span><br><span class="line">    &#125;;</span><br><span class="line">    //Event……</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 当鼠标按下式</span><br><span class="line">     * @param ev</span><br><span class="line">     */</span><br><span class="line">    canvas.onmousedown = ev =&gt; &#123;</span><br><span class="line">        isDrag = context.isPointInPath(ev.clientX, ev.clientY);</span><br><span class="line">        polygons.offsetX = ev.clientX - polygons.loc.x;</span><br><span class="line">        polygons.offsetY = ev.clientY - polygons.loc.y;</span><br><span class="line">        polygons.loc.x = ev.clientX;</span><br><span class="line">        polygons.loc.y = ev.clientY;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 鼠标移动时</span><br><span class="line">     * @param ev</span><br><span class="line">     */</span><br><span class="line">    canvas.onmousemove = ev =&gt; &#123;</span><br><span class="line">        if (isDrag) &#123;</span><br><span class="line">            context.beginPath();</span><br><span class="line">            context.clearRect(0, 0, canvas.width, canvas.height);</span><br><span class="line">            context.rect(ev.clientX - polygons.offsetX, ev.clientY - polygons.offsetY, initWidth, initHeight);</span><br><span class="line">            context.fill();</span><br><span class="line">            context.stroke();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            //鼠标经过的时候是否需要变小手</span><br><span class="line">            if (context.isPointInPath(ev.clientX, ev.clientY)) &#123;</span><br><span class="line">                //设置光标状态</span><br><span class="line">                canvas.style.cursor = &#x27;pointer&#x27;;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                canvas.style.cursor = &#x27;default&#x27;;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    canvas.onmouseup = ev =&gt; &#123;</span><br><span class="line">        isDrag = false;</span><br><span class="line">        polygons.loc.x = ev.clientX - polygons.offsetX;</span><br><span class="line">        polygons.loc.y = ev.clientY - polygons.offsetY;</span><br><span class="line"></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    //Init……</span><br><span class="line"></span><br><span class="line">    drawInitRect();</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;01-认识canvas&quot;&gt;&lt;a href=&quot;#01-认识canvas&quot; class=&quot;headerlink&quot; title=&quot;01-认识canvas&quot;&gt;&lt;/a&gt;01-认识canvas&lt;/h1&gt;&lt;p&gt;身为一个WEB开发人员，肯定都是想着能够开发出酷炫和激动人心的应用程</summary>
      
    
    
    
    
    <category term="笔记" scheme="https://admin741-cl.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>源码笔记（更新中）</title>
    <link href="https://admin741-cl.github.io/posts/d238.html"/>
    <id>https://admin741-cl.github.io/posts/d238.html</id>
    <published>2023-01-08T10:59:41.000Z</published>
    <updated>2023-06-17T02:44:09.058Z</updated>
    
    <content type="html"><![CDATA[<h4 id="一-HTML5面试题"><a href="#一-HTML5面试题" class="headerlink" title="一. HTML5面试题"></a>一. HTML5面试题</h4><h5 id="1-如何理解HTML5结构语义化？"><a href="#1-如何理解HTML5结构语义化？" class="headerlink" title="1. 如何理解HTML5结构语义化？"></a>1. 如何理解HTML5结构语义化？</h5><p>简单来说，我们可以理解为：<strong>用正确的标签做正确的事情。</strong></p><p>段落用 p 标签，标题用 h 系列标签，边栏用 aside 标签，主要内容用 main 标签。</p><p>对开发者：</p><ul><li><p>便于团队的开发和维护。</p></li><li><p>在没有加载 CSS 的情况下也能呈现较好的内容结构与代码结构，易于阅读。</p></li></ul><p>对浏览器：</p><ul><li><p>有利于 SEO ，搜索引擎的爬⾍依赖于标签来确定上下⽂和各个关键字的权重。</p></li><li><p>方便其他设备的解析（如屏幕阅读器、盲人阅读器等），利于无障碍阅读，提⾼可访问性。</p></li></ul><h5 id="2-html5的新特性？"><a href="#2-html5的新特性？" class="headerlink" title="2. html5的新特性？"></a>2. html5的新特性？</h5><ul><li><p>HTML5 现在已经不是 SGML 的子集，主要是关于图像，位置，存储，多任务等功能的增加</p><ul><li>用于媒介回放的 video 和 audio 元素</li><li>本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失</li><li>sessionStorage 的数据在浏览器关闭后自动删除</li><li>语意化更好的内容元素，比如 article、footer、header、nav、section</li><li>表单控件，calendar、date、time、email、url、search</li><li>新的技术webworker, websocket, Geolocation</li></ul></li><li><p>移除的元素：</p><ul><li>纯表现的元素：basefont，big，center，font, s，strike，tt，u</li><li>对可用性产生负面影响的元素：frame，frameset，noframes</li></ul></li><li><p>支持HTML5新标签：</p><ul><li>IE8/IE7/IE6支持通过document.createElement方法产生的标签</li><li>可以利用这一特性让这些浏览器支持HTML5新标签</li><li>浏览器支持新标签后，还需要添加标签默认的样式</li></ul></li><li><p>当然也可以直接使用成熟的框架、比如html5shim</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--[if lt IE 9]&gt;</span><br><span class="line">&lt;script&gt; src=&quot;http://html5shim.googlecode.com</span><br><span class="line">/svn/trunk/html5.js&quot;&lt;/script&gt;&lt;![endif]--&gt;</span><br></pre></td></tr></table></figure><ul><li>如何区分HTML5： DOCTYPE声明\新增的结构元素\功能元素</li></ul><h5 id="3-请描述一下-cookies，sessionStorage-和-localStorage-的区别？"><a href="#3-请描述一下-cookies，sessionStorage-和-localStorage-的区别？" class="headerlink" title="3. 请描述一下 cookies，sessionStorage 和 localStorage 的区别？"></a>3. 请描述一下 cookies，sessionStorage 和 localStorage 的区别？</h5><ul><li>cookie是网站为了标示用户身份而储存在用户本地终端（Client Side）上的数据（通常经过加密）</li><li>cookie数据始终在同源的http请求中携带（即使不需要），记会在浏览器和服务器间来回传递</li><li><code>sessionStorage</code>和<code>localStorage</code>不会自动把数据发给服务器，仅在本地保存</li><li><p>存储大小：</p><ul><li><code>cookie</code>数据大小不能超过4k</li><li><code>sessionStorage</code>和<code>localStorage</code>虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大</li></ul></li><li><p>有期时间：</p><ul><li><code>localStorage</code> 存储持久数据，浏览器关闭后数据不丢失除非主动删除数据</li><li><code>sessionStorage</code>  数据在当前浏览器窗口关闭后自动删除</li><li><code>cookie</code>  设置的<code>cookie</code>过期时间之前一直有效，即使窗口或浏览器关闭</li></ul></li></ul><h5 id="4-浏览器的渲染机制一般分为几个步骤"><a href="#4-浏览器的渲染机制一般分为几个步骤" class="headerlink" title="4. 浏览器的渲染机制一般分为几个步骤?"></a>4. 浏览器的渲染机制一般分为几个步骤?</h5><ul><li><p>处理 <code>HTML</code> 并构建 <code>DOM</code> 树。</p></li><li><p>处理 <code>CSS</code> 构建 <code>CSSOM</code> 树。</p></li><li><p>将 <code>DOM</code> 与 <code>CSSOM</code> 合并成一个渲染树。</p></li><li><p>根据渲染树来布局，计算每个节点的位置。</p></li><li><p>调用 <code>GPU</code> 绘制，合成图层，显示在屏幕上。</p><p><strong>注意：</strong></p></li><li><p>在构建 CSSOM 树时，会阻塞渲染，直至 CSSOM 树构建完成。并且构建 CSSOM 树是一个十分消耗性能的过程，所以应该尽量保证层级扁平，减少过度层叠，越是具体的 CSS 选择器，执行速度越慢</p></li><li><p>当 HTML 解析到 script 标签时，会暂停构建 DOM，完成后才会从暂停的地方重新开始。也就是说，如果你想首屏渲染的越快，就越不应该在首屏就加载 JS 文件。</p></li></ul><h5 id="5-重绘（Repaint）和回流（Reflow）"><a href="#5-重绘（Repaint）和回流（Reflow）" class="headerlink" title="5. 重绘（Repaint）和回流（Reflow）"></a>5. 重绘（Repaint）和回流（Reflow）</h5><ul><li>重绘是当节点需要更改外观而不会影响布局的，比如改变 color 就叫称为重绘</li><li>回流是布局或者几何属性需要改变就称为回流（需要计算它们在设备视口(viewport)内的确切位置和大小）</li></ul><blockquote><p>回流必定会发生重绘，重绘不一定会引发回流。回流所需的成本比重绘高的多，改变深层次的节点很可能导致父节点的一系列回流</p></blockquote><p><em>所以以下几个动作可能会导致性能问题：</em></p><ul><li>添加或删除可见的DOM元素</li><li>元素的位置发生变化</li><li>元素的尺寸发生变化（包括外边距、内边框、边框大小、高度和宽度等）</li><li>内容发生变化，比如文本变化或图片被另一个不同尺寸的图片所替代。</li><li>定位或者浮动</li><li>浏览器的窗口尺寸变化（因为回流是根据视口的大小来计算元素的位置和大小的）</li></ul><p><em>减少重绘和回流</em></p><ul><li><p>批量修改DOM</p></li><li><p>对于复杂动画效果,使用绝对定位让其脱离文档流</p></li><li><p>css3硬件加速（GPU加速）transform、opacity、filters这些动画不会引起回流重绘</p></li></ul><h5 id="6-简述data-属性的用法（如何设置，如何获取），有何优势？"><a href="#6-简述data-属性的用法（如何设置，如何获取），有何优势？" class="headerlink" title="6.  简述data:属性的用法（如何设置，如何获取），有何优势？"></a>6.  简述data:属性的用法（如何设置，如何获取），有何优势？</h5><p>data-* 的值的获取和设置，2种方法：</p><p>1）传统方法 getAttribute() 获取data-属性值； setAttribute() 设置data-属性值</p><p>getAttribute() 获取data-属性值；</p><p>setAttribute() 设置data-属性值</p><p>2)HTML5新⽅法 </p><p>例如 data-kerwin</p><p>dataset.kerwin 获取data-kerwin属性值</p><p>dataset.kerwin = “赵钱孙李” 设置data-kerwin属性值</p><p>注意：</p><ul><li><p>传统⽅法⽆兼容性问题，但是不够优雅、⽅便</p></li><li><p>HTML5新⽅法很优雅、⽅便，但是有兼容性问题。</p></li></ul><p>优势：⾃定义的数据可以让⻚⾯拥有更好的交互体验（不需要使⽤ Ajax 或去服务端查询数据）</p><h4 id="二-CSS面试题"><a href="#二-CSS面试题" class="headerlink" title="二. CSS面试题"></a>二. CSS面试题</h4><h5 id="1-display-none-与-visibility-hidden-的区别"><a href="#1-display-none-与-visibility-hidden-的区别" class="headerlink" title="1. display: none; 与 visibility: hidden; 的区别"></a>1. display: none; 与 visibility: hidden; 的区别</h5><ul><li>联系：它们都能让元素不可见</li><li>区别：<ul><li><code>display:none</code>;会让元素完全从渲染树中消失，渲染的时候不占据任何空间；<code>visibility: hidden</code>;不会让元素从渲染树消失，渲染师元素继续占据空间，只是内容不可见</li><li>修改常规流中元素的<code>display</code>通常会造成文档重排。修改<code>visibility</code>属性只会造成本元素的重绘</li></ul></li></ul><h5 id="2-外边距折叠-collapsing-margins"><a href="#2-外边距折叠-collapsing-margins" class="headerlink" title="2. 外边距折叠(collapsing margins)"></a>2. 外边距折叠(collapsing margins)</h5><ul><li>毗邻的两个或多个 <code>margin</code> 会合并成一个<code>margin</code>，叫做外边距折叠。规则如下：<ul><li>两个或多个毗邻的普通流中的块元素垂直方向上的<code>margin</code>会折叠</li><li>浮动元素或<code>inline-block</code>元素或绝对定位元素的<code>margin</code>不会和垂直方向上的其他元素的margin折叠</li><li>创建了块级格式化上下文（BFC）的元素，不会和它的子元素发生margin折叠</li></ul></li></ul><h5 id="3-z-index是什么？在position的值什么时候可以触发"><a href="#3-z-index是什么？在position的值什么时候可以触发" class="headerlink" title="3. z-index是什么？在position的值什么时候可以触发?"></a>3. z-index是什么？在position的值什么时候可以触发?</h5><p>z-index 属性设置元素的堆叠顺序。拥有更⾼堆叠顺序的元素总是会处于堆叠顺序较低的元素的前⾯，当 脱离⽂档流内容较多，并且相互重叠的时候，就有可能发⽣本想完全显示的内容被其他内容遮挡的结 果，这时我们就需要⼈为指定哪个层在上⾯，哪个在下⾯，z-index属性就是⼲这个⽤的。</p><p>注意：Z-index 仅能在定位元素上奏效.</p><p>在position的值是relative、absolute、fixed、sticky时候可以触发</p><h5 id="4-简述box-sizing的有效值以及所对应的盒模型规则"><a href="#4-简述box-sizing的有效值以及所对应的盒模型规则" class="headerlink" title="4. 简述box-sizing的有效值以及所对应的盒模型规则"></a>4. 简述box-sizing的有效值以及所对应的盒模型规则</h5><p>box-sizing 属性允许您以特定的⽅式定义匹配某个区域的特定元素。</p><p>语法：box-sizing: content-box|border-box|inherit;</p><p>1）box-sizing:content-box；这是由 CSS2.1 规定的宽度⾼度⾏为。宽度和⾼度分别应⽤到元素的内容框。 在宽度和⾼度之外绘制元素的内边距和边框。是默认值。如果你设置⼀个元素的宽为100px，那么这个元 素的内容区会有100px 宽，并且任何边框和内边距的宽度都会被增加到最后绘制出来的元素宽度中</p><p>2）box-sizing:border-box；为元素指定的任何内边距和边框都将在已设定的宽度和⾼度内进⾏绘制。告诉 浏览器去理解你设置的边框和内边距的值是包含在width内的。也就是说，如果你将⼀个元素的width设 为100px,那么这100px会包含其它的border和padding，内容区的实际宽度会是width减去border + padding 的计算值。⼤多数情况下这使得我们更容易的去设定⼀个元素的宽⾼</p><p>3）box-sizing:inherit;；规定应从⽗元素继承 box-sizing 属性的值</p><h5 id="5-移动端适配怎么做？"><a href="#5-移动端适配怎么做？" class="headerlink" title="5. 移动端适配怎么做？"></a>5. 移动端适配怎么做？</h5><p>1） meta viewport（视⼝）</p><p>移动端初始视⼝的⼤⼩为什么默认是980px？</p><p>因为世界上绝⼤多数PC⽹⻚的版⼼宽度为 980px ，如果⽹⻚没有专⻔做移动端适配，此时⽤⼿机访问⽹ ⻚旁边刚好没有留⽩，不过⻚⾯缩放后⽂字会变得⾮常⼩。</p><p>为了解决⻚⾯缩放的体验问题，在⽹⻚代码的头部，加⼊⼀⾏viewport元标签。</p><p>这⾥的device-width告诉浏览器，将视⼝的宽度设置为设备宽度（这个宽度是⼈为预设的，不设的话就是 980px）。 属性含义</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">initial-scale：第⼀次进⼊⻚⾯的初始⽐例</span><br><span class="line"> minimum-scale：允许缩⼩最⼩⽐例</span><br><span class="line"> maximum-scale：允许放⼤最⼤⽐例</span><br><span class="line"> user-scalable：允许使⽤者缩放，1 or 0 (yes or no)</span><br></pre></td></tr></table></figure><p>2） 图⽚适配</p><p>img { max-width: 100%; } 此时图⽚会⾃动缩放，同时图⽚最⼤显示为其⾃身的100%（即最⼤只 可以显示为⾃身那么⼤） 为什么不⽤ img { width: 100%; } ？ 当容器⼤于图⽚宽度时，图⽚会⽆ 情的拉伸变形</p><p>3） 媒体查询</p><p>为什么要媒体查询？</p><p>针对不⽤的设备提前为⽹⻚设定各种 CSS 样式CSS3中的Media Query模块，⾃动检测屏幕宽度，然后加载 相应的CSS⽂件 </p><p>语法举例</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">min-width</span>:<span class="number">1200px</span>)&#123;</span><br><span class="line"> <span class="selector-tag">body</span>&#123;</span><br><span class="line"> <span class="attribute">background-color</span>: red;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>当屏幕宽度⼤于1200px时，背景⾊变为红⾊</p><p>4） 动态 rem ⽅案</p><p>为什么要⽤rem？</p><p>和媒体查询配合，实现响应式布局</p><p>px、em、rem 有什么不同？</p><p>px是pixel（像素），是屏幕上显示数据的最基本的点，在HTML中，默认的单位就是px；em 是⼀个相对 ⼤⼩，相对于⽗元素font-size的百分⽐⼤⼩rem 是相对于根元素的font-size</p><p>⽤法示例</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment"> * @作者: kerwin</span></span><br><span class="line"><span class="comment"> * @公众号: 大前端私房菜</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">        *&#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">margin</span>:<span class="number">0</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">padding</span>:<span class="number">0</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-tag">html</span>&#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">font-size</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">        <span class="selector-tag">body</span>&#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">font-size</span>: <span class="number">16px</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.box</span>&#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">width</span>: <span class="number">7.5rem</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background</span>:yellow;</span></span><br><span class="line"><span class="language-css">            <span class="comment">/* font-size: 16px; */</span></span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">//fontsize 计算   </span></span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">style</span>.<span class="property">fontSize</span>=<span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">clientWidth</span>/<span class="number">750</span> * <span class="number">100</span> +<span class="string">&#x27;px&#x27;</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// fontsize = 当前设备的css布局宽度/物理分辨率(设计稿的宽度)* 基准font-size</span></span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span></span><br><span class="line">        赵钱孙李</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="6-什么是CSS3-transform-transition-animation-区别是什么？"><a href="#6-什么是CSS3-transform-transition-animation-区别是什么？" class="headerlink" title="6.  什么是CSS3 transform? transition? animation? 区别是什么？"></a>6.  什么是CSS3 transform? transition? animation? 区别是什么？</h5><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">CSS3属性中关于制作动画的三个属性：<span class="attribute">Transform</span>,<span class="attribute">Transition</span>,<span class="attribute">Animation</span>。</span><br><span class="line"><span class="number">1</span>、<span class="attribute">transform</span>：描述了元素的静态样式，本身不会呈现动画效果，可以对元素进⾏ 旋转rotate、扭曲skew、缩放</span><br><span class="line">scale和移动translate以及矩阵变形matrix。</span><br><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">　　<span class="attribute">transform</span>:<span class="built_in">scale</span>(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="attribute">transition</span>和<span class="attribute">animation</span>两者都能实现动画效果</span><br><span class="line"><span class="attribute">transform</span>常常配合<span class="attribute">transition</span>和<span class="attribute">animation</span>使⽤</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、<span class="attribute">transition</span>样式过渡，从⼀种效果逐渐改变为另⼀种效果</span><br><span class="line"><span class="attribute">transition</span>是⼀个合写属性</span><br><span class="line"><span class="attribute">transition</span>:transition-property transition-duration transition-timing-function</span><br><span class="line">transition-delay</span><br><span class="line">从左到右分别是：css属性、过渡效果花费时间、速度曲线、过渡开始的延迟时间</span><br><span class="line">div&#123;</span><br><span class="line"> <span class="attribute">width</span>：<span class="number">100px</span>;</span><br><span class="line"> <span class="attribute">height</span>:<span class="number">100px</span>;</span><br><span class="line"> <span class="attribute">transition</span>:transform <span class="number">2s</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">div</span>：hover&#123;</span><br><span class="line"> <span class="attribute">transform</span>:<span class="built_in">rotate</span>(<span class="number">180deg</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="attribute">transition</span>通常和hover等事件配合使⽤，需要由事件来触发过渡</span><br><span class="line">我们知道 <span class="attribute">transition</span> 虽然简单好⽤，但是我们会发现它受到各种限制。</span><br><span class="line">(<span class="number">1</span>)<span class="attribute">transition</span>需要⼀个事件来触发，⽐如hover，所以没法在⽹⻚加载时⾃动发⽣</span><br><span class="line">(<span class="number">2</span>) <span class="attribute">transition</span>是⼀次性的，不能重复发⽣，除⾮⼀再触发。</span><br><span class="line">(<span class="number">3</span>) <span class="attribute">transition</span>只能定义开始状态和结束状态，不能定义中间状态，也就是说只有两个状态。</span><br><span class="line">(<span class="number">4</span>)⼀条<span class="attribute">transition</span>规则，只能定义⼀个属性的变化，不能涉及多个属性。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">3</span>、<span class="attribute">animation</span>动画 由<span class="keyword">@keyframes</span>来描述每⼀帧的样式</span><br><span class="line">div&#123;</span><br><span class="line">　　<span class="attribute">animation</span>:myAnimation <span class="number">5s</span> infinite</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@keyframes</span> myAnimation &#123;</span><br><span class="line">　　<span class="number">0%</span>&#123;<span class="attribute">left</span>:<span class="number">0</span>;<span class="attribute">transform</span>:<span class="built_in">rotate</span>(<span class="number">0</span>);&#125;</span><br><span class="line">　　<span class="number">100%</span>&#123;<span class="attribute">left</span>:<span class="number">200px</span>;<span class="attribute">transform</span>:<span class="built_in">rotate</span>(<span class="number">180deg</span>);&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">区别：</span><br><span class="line">（<span class="number">1</span>）<span class="attribute">transform</span>仅描述元素的静态样式，常常配合<span class="attribute">transition</span>和<span class="attribute">animation</span>使⽤</span><br><span class="line">（<span class="number">2</span>）<span class="attribute">transition</span>通常和hover等事件配合使⽤，<span class="attribute">animation</span>是⾃发的，⽴即播放</span><br><span class="line">（<span class="number">3</span>）<span class="attribute">animation</span>可设置循环次数</span><br><span class="line">（<span class="number">4</span>）<span class="attribute">animation</span>可设置每⼀帧的样式和时间，<span class="attribute">transition</span>只能设置头尾</span><br><span class="line">（<span class="number">5</span>）<span class="attribute">transition</span>可与js配合使⽤，js设定要变化的样式，<span class="attribute">transition</span>负责动画效果，如：</span><br><span class="line"></span><br><span class="line"><span class="attribute">animation</span>属性类似于<span class="attribute">transition</span>，他们都是随着时间改变元素的属性值，</span><br><span class="line">其主要区别在于：<span class="attribute">transition</span>需要触发⼀个事件才会随着时间改变其CSS属性；</span><br><span class="line"><span class="attribute">animation</span>在不需要触发任何事件的情况下，也可以显式的随时间变化来改变元素CSS属性，达到⼀种动画的效果</span><br><span class="line"><span class="number">1</span>）动画不需要事件触发，过渡需要。</span><br><span class="line"><span class="number">2</span>）过渡只有⼀组（两个：开始-结束） 关键帧，动画可以设置多个。</span><br></pre></td></tr></table></figure><h5 id="7-⽗元素和⼦元素宽⾼不固定，如何实现⽔平垂直居中"><a href="#7-⽗元素和⼦元素宽⾼不固定，如何实现⽔平垂直居中" class="headerlink" title="7. ⽗元素和⼦元素宽⾼不固定，如何实现⽔平垂直居中"></a>7. ⽗元素和⼦元素宽⾼不固定，如何实现⽔平垂直居中</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment"> * @作者: kerwin</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">        * &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">padding</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">margin</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-tag">html</span>,</span></span><br><span class="line"><span class="language-css">        <span class="selector-tag">body</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">width</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">height</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-tag">body</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-color</span>: azure;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.parent</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">width</span>: <span class="number">500px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">height</span>: <span class="number">500px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-color</span>: yellowgreen;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">position</span>: relative;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.child</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">position</span>: absolute;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">top</span>: <span class="number">50%</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">left</span>: <span class="number">50%</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">transform</span>: <span class="built_in">translate</span>(-<span class="number">50%</span>, -<span class="number">50%</span>);</span></span><br><span class="line"><span class="language-css">            <span class="comment">/* 使⽤css3的transform来实现 */</span></span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.child</span> <span class="selector-tag">p</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">width</span>: <span class="number">300px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">height</span>: <span class="number">300px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-color</span>: blue;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;parent&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;child&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment"> * @作者: kerwin</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">        * &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">padding</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">margin</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-tag">body</span>,</span></span><br><span class="line"><span class="language-css">        <span class="selector-tag">html</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">width</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">height</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.parent</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">display</span>: flex;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">justify-content</span>: center;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">align-items</span>: center;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">width</span>: <span class="number">600px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">height</span>: <span class="number">600px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background</span>: yellow;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.parent</span> <span class="selector-class">.child</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">color</span>: <span class="number">#fff</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">width</span>: <span class="number">300px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">height</span>: <span class="number">300px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">text-align</span>: center;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-color</span>: blue;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;parent&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;child&quot;</span>&gt;</span>hello world<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="8-假设高度默认100px-，请写出三栏布局，其中左栏、右栏各为300px，中间自适应。"><a href="#8-假设高度默认100px-，请写出三栏布局，其中左栏、右栏各为300px，中间自适应。" class="headerlink" title="8. 假设高度默认100px ，请写出三栏布局，其中左栏、右栏各为300px，中间自适应。"></a>8. 假设高度默认<code>100px</code> ，请写出三栏布局，其中左栏、右栏各为<code>300px</code>，中间自适应。</h5><p><img src="http://img.smyhvae.com/20180305_1520.png" alt=""></p><ul><li>方法1：浮动</li><li>方法2：绝对定位</li><li>方法3：<code>flexbox</code>。移动开发里经常用到。</li></ul><p><em>方法1、浮动：</em></p><blockquote><p>左侧设置左浮动，右侧设置右浮动即可，中间会自动地自适应。</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment"> * @作者: kerwin</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">        *&#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">margin</span>:<span class="number">0</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">padding</span>:<span class="number">0</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.box</span> <span class="selector-tag">div</span>&#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.left</span>&#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">width</span>: <span class="number">300px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">float</span><span class="selector-pseudo">:left</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background</span>:gray;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.right</span>&#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">width</span>: <span class="number">300px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">float</span>: right;;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background</span>:gray;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.center</span>&#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-color</span>: yellowgreen;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;left&quot;</span>&gt;</span>left<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;right&quot;</span>&gt;</span>right<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;center&quot;</span>&gt;</span>center<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><em>方法2、绝对定位：</em></p><blockquote><p>左侧设置为绝对定位， <code>left：0px</code>。右侧设置为绝对定位， <code>right：0px</code>。中间设置为绝对定位，<code>left</code>和<code>right</code> 都为<code>300px</code>，即可。中间的宽度会自适应。</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment"> * @作者: kerwin</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">        *&#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">margin</span>:<span class="number">0</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">padding</span>:<span class="number">0</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.box</span> <span class="selector-tag">div</span>&#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.left</span>&#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">width</span>: <span class="number">300px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">position</span>: absolute;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">left</span>:<span class="number">0</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background</span>:gray;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.right</span>&#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">width</span>: <span class="number">300px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">position</span>: absolute;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">right</span>:<span class="number">0</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background</span>:gray;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.center</span>&#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">position</span>: absolute;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">left</span>:<span class="number">300px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">right</span>:<span class="number">300px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-color</span>: yellowgreen;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;left&quot;</span>&gt;</span>left<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;center&quot;</span>&gt;</span>center<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;right&quot;</span>&gt;</span>right<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><em>方法3、flexbox布局</em></p><blockquote><p>将左中右所在的容器设置为<code>display: flex</code>，设置两侧的宽度后，然后让中间的<code>flex = 1</code>，即可。</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment"> * @作者: kerwin</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">        *&#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">margin</span>:<span class="number">0</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">padding</span>:<span class="number">0</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.box</span> <span class="selector-tag">div</span>&#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.box</span>&#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">display</span>: flex;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.left</span>&#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">width</span>: <span class="number">300px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background</span>:gray;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.right</span>&#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">width</span>: <span class="number">300px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background</span>:gray;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.center</span>&#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">flex</span>:<span class="number">1</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-color</span>: yellowgreen;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;left&quot;</span>&gt;</span>left<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;center&quot;</span>&gt;</span>center<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;right&quot;</span>&gt;</span>right<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="三-JS高频面试题"><a href="#三-JS高频面试题" class="headerlink" title="三. JS高频面试题"></a>三. JS高频面试题</h4><h5 id="1-介绍JS有哪些内置对象？"><a href="#1-介绍JS有哪些内置对象？" class="headerlink" title="1. 介绍JS有哪些内置对象？"></a>1. 介绍JS有哪些内置对象？</h5><ul><li>数据封装类对象：Object、Array、Boolean、Number、String</li><li>其他对象：Function、Arguments、Math、Date、RegExp、Error</li><li>ES6新增对象：Symbol（标识唯一性的ID）、Map、Set、Promises、Proxy、Reflect</li></ul><h5 id="2-如何最小化重绘-repaint-和回流-reflow-？"><a href="#2-如何最小化重绘-repaint-和回流-reflow-？" class="headerlink" title="2. 如何最小化重绘(repaint)和回流(reflow)？"></a>2. 如何最小化重绘(repaint)和回流(reflow)？</h5><ul><li><p>需要要对元素进行复杂的操作时，可以先隐藏(display:”none”)，操作完成后再显示</p></li><li><p>需要创建多个DOM节点时，使用DocumentFragment创建完后一次性的加入document</p></li><li><p>缓存Layout属性值，如：var left = elem.offsetLeft; 这样，多次使用 left 只产生一次回流</p></li><li><p>尽量避免用table布局（table元素一旦触发回流就会导致table里所有的其它元素回流）</p></li></ul><h5 id="3-Javascript作用域链"><a href="#3-Javascript作用域链" class="headerlink" title="3. Javascript作用域链?"></a>3. Javascript作用域链?</h5><ul><li>全局函数无法查看局部函数的内部细节，但局部函数可以查看其上层的函数细节，直至全局细节</li><li>如果当前作用域没有找到属性或方法，会向上层作用域[[Scoped]]查找，直至全局函数，这种形式就是作用域链</li></ul><h5 id="4-数据请求"><a href="#4-数据请求" class="headerlink" title="4. 数据请求"></a>4. 数据请求</h5><p> <em>(1) XHR</em> </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">xhr.<span class="title function_">open</span>(<span class="string">&#x27;get&#x27;</span>,<span class="string">&quot;www.aaaa.com&quot;</span>,<span class="literal">true</span>);<span class="comment">//异步</span></span><br><span class="line">xhr.<span class="title function_">send</span>();</span><br><span class="line">xhr.<span class="property">onreadystatechange</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="comment">// readstate  4</span></span><br><span class="line"><span class="comment">// status  200-300</span></span><br><span class="line"><span class="comment">// 200 成功 （有可能强缓存策略，cache-control,expired）</span></span><br><span class="line"><span class="comment">// 301 302 redirect</span></span><br><span class="line"><span class="comment">// 304 从缓存读取数据。(协商缓存策略,etag)</span></span><br><span class="line"><span class="comment">// 404 not found</span></span><br><span class="line"><span class="comment">// 500 服务器错误。</span></span><br><span class="line">&#125;</span><br><span class="line">  xhr 可以取消？</span><br><span class="line">  xhr.<span class="title function_">abort</span>();<span class="comment">//终止请求。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p> <em>(2) fetch （w3c）</em></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">fetch</span>(<span class="string">&quot;url&quot;</span>,  </span><br><span class="line">   &#123;<span class="attr">method</span>:<span class="string">&quot;post&quot;</span>,<span class="attr">body</span>:<span class="string">&quot;&quot;</span>,<span class="attr">credencial</span>:<span class="string">&#x27;include&#x27;</span>&#125;)</span><br><span class="line">   .<span class="title function_">then</span>(<span class="function"><span class="params">res</span>=&gt;</span>res.<span class="title function_">json</span>())</span><br><span class="line">   .<span class="title function_">then</span>(<span class="function"><span class="params">res</span>=&gt;</span>&#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(res)&#125;)</span><br><span class="line">   <span class="comment">// 兼容性问题</span></span><br><span class="line">   <span class="comment">// 发出的请求，默认是不带cookie.  credencial:&#x27;include&#x27;</span></span><br></pre></td></tr></table></figure><p> <em>(3) jsonp (解决跨域)</em>  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">动态创建script src指向没有跨域限制，  onload</span><br><span class="line"></span><br><span class="line">后端返回的数据格式 一定是， <span class="title function_">test</span>(<span class="string">&#x27;[&quot;111&quot;,&quot;222&quot;,&quot;3333&quot;]&#x27;</span>);</span><br><span class="line"></span><br><span class="line">前端提前定义好 test这个方法，通过形参就拿到数据了。</span><br><span class="line"></span><br><span class="line">jsonp 可以做get请求， 无法做post请求（缺点）;</span><br><span class="line"></span><br><span class="line">jsonp可以取消吗？不能</span><br></pre></td></tr></table></figure><h5 id="5-跨域和同源策略"><a href="#5-跨域和同源策略" class="headerlink" title="5. 跨域和同源策略"></a>5. 跨域和同源策略</h5><p>所谓的同源策略其实是浏览器的一种机制，只允许在同源，也就是同协议、同域名、同端口的的情况下才能进行数据交互。 但是我们在开发项目的过程中， 往往一个项目的接口不止一个域，所以往往就需要做跨域的处理，通常的跨域方式有这么几种：</p><p>1）</p><p>JSONP，主要依赖的是script标签不受同源策略影响，src指向某一个接口的地址， 同步需要传递callback回调函数名字， 这样当接口调用成功后， 本地创建的全局回调函数就会执行， 并且接收到数据。不使用img标签的原因是因为img标签无法执行js语句</p><p>2)</p><p>CORS，依赖服务端对前端的请求头信息进行放行，不做限制。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Access</span>-<span class="title class_">Control</span>-<span class="title class_">Allow</span>-<span class="title class_">Origin</span>配置成*</span><br></pre></td></tr></table></figure><p>3)</p><p>代理访问，前端访问不存在跨域问题的代理服务器，代理服务器再去访问目标服务器（服务器之间没有跨域限制）</p><h5 id="6-面向对象"><a href="#6-面向对象" class="headerlink" title="6. 面向对象"></a>6. 面向对象</h5><p>   <em>(1)构造函数</em></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Test</span>(<span class="params">name,age</span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> =age;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">getName</span>= <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Test();</span></span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="title class_">Test</span>(<span class="string">&quot;kerwin&quot;</span>,<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj2 =<span class="keyword">new</span> <span class="title class_">Test</span>(<span class="string">&quot;xiaoming&quot;</span>,<span class="number">18</span>)</span><br></pre></td></tr></table></figure><p>   <em>(2)原型</em></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//内存只有一份</span></span><br><span class="line"><span class="title class_">Test</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getName</span>= <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//缺点是？</span></span><br><span class="line"></span><br><span class="line">原型容易被覆盖</span><br><span class="line"></span><br><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">concat</span> = ....</span><br></pre></td></tr></table></figure><p>   <em>(3)继承</em></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造函数继承</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Test2</span>(<span class="params">name,age,location</span>)&#123;</span><br><span class="line">    <span class="comment">// this.name =name;</span></span><br><span class="line">    <span class="comment">// this.age =age;</span></span><br><span class="line">    <span class="comment">// Test.call(this,name,age);</span></span><br><span class="line">    <span class="title class_">Test</span>.<span class="title function_">apply</span>(<span class="variable language_">this</span>,[name,age])</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">location</span> = location;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="title class_">Test2</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//原型继承</span></span><br><span class="line"><span class="title class_">Test2</span>.<span class="property"><span class="keyword">prototype</span></span> =<span class="title class_">Test</span>.<span class="property"><span class="keyword">prototype</span></span></span><br><span class="line"><span class="comment">//Test2.prototype =new Test()</span></span><br><span class="line"><span class="title class_">Test2</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> =<span class="title class_">Test2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//混合继承</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><em>(4)原型链</em></p><blockquote><p><strong>原型链的基本原理</strong>：任何一个<strong>实例</strong>，通过原型链，找到它上面的<strong>原型</strong>，该原型对象中的方法和属性，可以被所有的原型实例共享。</p></blockquote><p><img src="%E7%AC%94%E8%AE%B0.assets/image-20200411192514703-1675990853293.png" alt="image-20200411192514703"></p><h5 id="7-闭包"><a href="#7-闭包" class="headerlink" title="7. 闭包"></a>7. 闭包</h5><p>闭包是JS中的一种特性，往往用于解决一些特定的问题，当A函数中返回了B函数， 并且返回的B函数中有使用到A函数中的局部变量（包含参数）就会形成一个特性的形态，就叫闭包。</p><p>此时，理论上来说A函数执行完成后，生成了B函数后，应该被垃圾回收机制回收，但是因为生成的B函数还在使用A函数中的局部变量， 就会导致A函数没有及时回收，导致内存泄露。</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 函数防抖(搜索查询)</span></span><br><span class="line"></span><br><span class="line">inputelement.<span class="property">oninput</span> = (<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="keyword">var</span> timer =<span class="literal">null</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">           <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;scroll&quot;</span>)</span><br><span class="line"><span class="keyword">if</span>(timer)&#123;</span><br><span class="line"><span class="built_in">clearTimeout</span>(timer);</span><br><span class="line">&#125;</span><br><span class="line">timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;代码执行,ajax&quot;</span>); </span><br><span class="line">               </span><br><span class="line">&#125;, <span class="number">500</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;)()</span><br><span class="line"><span class="comment">// 2. 函数节流（onrize，onscroll）</span></span><br><span class="line">       <span class="variable language_">window</span>.<span class="property">onscroll</span> = (<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">           <span class="keyword">var</span> date = <span class="title class_">Date</span>.<span class="title function_">now</span>();</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line"></span><br><span class="line">               <span class="keyword">if</span>(<span class="title class_">Date</span>.<span class="title function_">now</span>()-date&gt;<span class="number">500</span>)&#123;</span><br><span class="line">                   date = <span class="title class_">Date</span>.<span class="title function_">now</span>();</span><br><span class="line">                   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;代码执行echarts resize&quot;</span>)</span><br><span class="line"></span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;)()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. ul li</span></span><br><span class="line"><span class="keyword">var</span> oli = <span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&quot;li&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;oli.<span class="property">length</span>;i++)&#123;</span><br><span class="line">oli[i].<span class="property">onclick</span> =(<span class="keyword">function</span>(<span class="params">index</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">               <span class="variable language_">console</span>.<span class="title function_">log</span>(index)</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;)(i)   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="8-数组去重"><a href="#8-数组去重" class="headerlink" title="8. 数组去重"></a>8. 数组去重</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> myset = <span class="keyword">new</span> <span class="title class_">Set</span>(arr);</span><br><span class="line"><span class="keyword">var</span> mya = <span class="title class_">Array</span>.<span class="title function_">from</span>(myset);</span><br></pre></td></tr></table></figure><h5 id="9-数组常用的合并方法"><a href="#9-数组常用的合并方法" class="headerlink" title="9. 数组常用的合并方法"></a>9. 数组常用的合并方法</h5><ul><li><p>concat</p></li><li><p>[…a, …b]展开运算符</p></li><li><p>[a, b].flat()</p></li><li><p>……</p></li></ul><h5 id="10-cookie和session"><a href="#10-cookie和session" class="headerlink" title="10. cookie和session"></a>10. cookie和session</h5><p>cookie和session是为HTTP请求挂载状态的，也就说在前后端交互的过程中，往往需要利用cookie或者session来对客户端进行标记。</p><p>传统的cookie验证方式是这样的：</p><ol><li><p>客户端在向服务端登录的时候，服务端直接通过响应头上set-cookie字段，为浏览器客户端注入cookie，或者将对应的信息放置在响应内容中，客户端自行将其存储在cookie中。</p></li><li><p>客户端在每次发送请求的时候就可以将cookie携带在请求头上进行数据的传递，服务端拿到此次请求头中的cookie进行验证。</p></li><li><p>客户端自行设置cookie或者由服务端设置cookie的时候也去设置此cookie的过期时间，当cookie过期后相当于登录过期了。</p></li></ol><p>session的验证方式：</p><ol><li><p>客户端在向服务端登录的时候，服务端自行建立客户信息表，并且建立生命周期机制，服务端再将此信息通过cookie或者数据直接返回的形式，返回给客户端。</p></li><li><p>客户端拿到验证信息后，可以选择存储在cookie中获取localStorage中都可以。</p></li><li><p>每次请求的时候携带验证信息（cookie就自动写到，localStorage需要取出携带）</p></li><li><p>服务端接收到请求后，判断该验证信息是否过期</p></li></ol><p>cookie和session本质是都是利用cookie或者localStorage来进行数据交互，而cookie和localStorage又都有跨域的限制：</p><p>cookie通过设置domain可以实现一级域名下的二级域名之间可以互相访问，localStorage则不能跨域。</p><h5 id="11-线程和进程的区别"><a href="#11-线程和进程的区别" class="headerlink" title="11. 线程和进程的区别"></a>11. 线程和进程的区别</h5><p>进程是资源分配的最小单元，线程是代码执行的最小单元。</p><p>一个应用程序可能会开启多个进程，进程之间数据不共享，一个进程内部可以开启多个线程，线程之间的数据可以共享的，所以多线程的情况下，往往要考虑的是线程间的执行顺序问题。</p><p>浏览器其实也可以通过webWorkers开启多线程。</p><h5 id="12-协商缓存和强缓存区别"><a href="#12-协商缓存和强缓存区别" class="headerlink" title="12.协商缓存和强缓存区别"></a>12.协商缓存和强缓存区别</h5><p>协商缓存和强缓存指的都是浏览器对静态资源文件的缓存机制。描述的就是什么时候去服务器请求，什么时候直接读取缓存中的文件。</p><p>强缓存是客户端直接查看本地的缓存文件是否过期，如果没有过期就直接取用。</p><ol><li>查看过期的方法主要是依赖响应头上的expires(绝对时间)和cache-control（相对时间）上的时间来对比的</li></ol><p>协商缓存指的是客户端去询问服务器对应的文件是否有更新，如果有更新才会重新请求。</p><ol><li>依靠的是响应头上的last-modified（最后更新时间）及etag(内容变更的标识)来确认文件是否有更新。</li></ol><p>一个文件是否重新请求要经过强缓存和协商缓存的完整过程后才能决定。 </p><p><img src="%E7%AC%94%E8%AE%B0.assets/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAc3R1YmJvcm7kuLZsaWxp,size_16,color_FFFFFF,t_70,g_se,x_16.png" alt="img"></p><ol><li><p>强制缓存和协商缓存都针对静态资源</p></li><li><p>强制缓存在前，协商缓存在后。</p></li><li><p>资源未过期触发强制缓存，资源过期后再触发协商缓存。</p></li><li><p>判断过期的方法expires（绝对时间）、cache-control（相对时间）</p></li><li><p>判断资源是否有更新（Last-Modified 和 ETag）</p></li></ol><blockquote><p>需要注意的是，即使是静态资源，也是依靠url来进行缓存的，也就是说只要是url地址不一样，就一定会去获取最新的数据。</p><p>所以我们往往会有这样的需求，在静态文件的src后面添加一个时间戳，获取在打包的时候动态的生成带有hash值的文件名，这样可以阻止浏览器缓存，使用户获取到最新的文件，使用到最新的功能。</p></blockquote><h5 id="13-http和https区别以及哪个更安全"><a href="#13-http和https区别以及哪个更安全" class="headerlink" title="13. http和https区别以及哪个更安全"></a>13. http和https区别以及哪个更安全</h5><p>HTTP明文传输，数据没有加密，安全性较差，HTTPS（HTTP + SSL），数据传输过程是加密的，安全性要好一些。</p><p>使用HTTPS协议要经过SSL认证来申请SSL证书，认证拿到证书的过程一般都是收费的，所以成本略高。</p><p>HTTP的速度要比HTTPS要更快一些，就是因为HTTP和服务器建立连接要通过TCP的三次握手，客户端和服务端只需要交换3个包，HTTPS在进行连接的时候除了要TCP的3个包，还要加上SSL握手的9个包，一共12个包。</p><p>默认端口不同，http默认80端口，https默认443接口。</p><p>HTTPS认证是怎么认证的？</p><p>客户端和服务端进行数据传输之前，先通过证书对双方进行身份验证：</p><ol><li><p>客户端在发送SSL握手信息给服务端要求连接</p></li><li><p>服务端会将证书发送给客户端</p></li><li><p>客户端检查服务端证书，确认这个这个证书的签发机构是否值得信任，如果检查有问题，客户端会将是否继续通讯的决定权交给客户端，如果检查无误，或者用户选择继续，就表现客户端认可服务端身份。</p></li><li><p>服务端要求客户端发送证书，并且检查是否通过验证， 失败就关闭连接，成功的话就得到客户端的公钥</p></li></ol><p>至此，服务端及客户端双方身份认证接受，双方都确保彼此身份可靠。</p><p>HTTPS一定安全吗？</p><p>不一定，HTTPS往往无法阻止中间人攻击。</p><p>A和B进行数据交互的时候，可以采用加密的方式，加密分为对称和不对称两种。</p><p>对称加密只要被破解出加密方式，就很容易泄露信息。</p><p>A生成一个秘钥ka，B生成一个秘钥kb；ka用于解密A加密的数据，kb用于解密B加密的数据。</p><p>A将ka传递给B，B将kb传递A，这样的话，A再给B传递信息的时候，B接受到之后用ka来进行解密。</p><p>HTTPS进行密文传输的时候采用的不对称加密的方式。但是如果有中间人拦截请求后模仿A和B来与B和A进行通信的时候也会泄露数据。</p><h5 id="14-对于工作中的跨域问题你是怎么解决的"><a href="#14-对于工作中的跨域问题你是怎么解决的" class="headerlink" title="14.对于工作中的跨域问题你是怎么解决的"></a>14.对于工作中的跨域问题你是怎么解决的</h5><p>在线上的各种环境中（开发、测试、生产）环境一般是不会有跨域问题的，因为服务器和前端资源一般是会部署在同一个域的服务器下的，但是也有端口或者不同域的情况，这些时候往往都是后端去利用CORS来处理的跨域问题。</p><p>在本地开发的过程中，本地服务器访问测试服务器接口的，也基本都是后端去处理CORS跨域，但是有些时候也可能需要前端在脚手架对应的devServer中配置Proxy来进行开发时候的跨域处理。</p><p>在一些极少的情况下加，项目中可能会访问一些第三方的Api，比如定位、天气等等接口的时候，可能会根据接口需求进行jsonp的跨域处理。</p><h5 id="15-事件循环"><a href="#15-事件循环" class="headerlink" title="15. 事件循环"></a>15. 事件循环</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">（<span class="number">1</span>）所有同步任务在主线程上执行，形成一个执行栈 </span><br><span class="line"></span><br><span class="line">（<span class="number">2</span>）主线程之外，还存在一个<span class="string">&quot;任务队列&quot;</span>（task queue）。只要异步任务(<span class="built_in">setInterval</span>,<span class="built_in">setTimeout</span>，i/o...)有了结果，就在<span class="string">&quot;任务队列&quot;</span>之中放置一个事件。</span><br><span class="line"></span><br><span class="line">（<span class="number">3</span>）一旦<span class="string">&quot;执行栈&quot;</span>中的所有同步任务执行完毕，系统就会读取<span class="string">&quot;任务队列&quot;</span>，拿到队列的第一个任务，进入执行栈，开始执行。</span><br><span class="line"></span><br><span class="line">（<span class="number">4</span>）主线程不断重复上面的(<span class="number">3</span>)。</span><br><span class="line"></span><br><span class="line">主线程从<span class="string">&quot;任务队列&quot;</span>中读取事件，这个过程是循环不断的，所以整个的这种运行机制又称为<span class="title class_">Event</span> <span class="title class_">Loop</span>（事件循环）</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="%E7%AC%94%E8%AE%B0.assets/image-20230210103331701.png" alt="image-20230210103331701"></p><h5 id="16-微任务和宏任务"><a href="#16-微任务和宏任务" class="headerlink" title="16. 微任务和宏任务"></a>16. 微任务和宏任务</h5><blockquote><p>Promise的出现让问题变复杂了, 它跟setTimeout 优先级？ 上面的事件循环解释不够用了。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;script start&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;timer over&#x27;</span>)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise1&#x27;</span>)</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise2&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;script end&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// script start</span></span><br><span class="line"><span class="comment">// script end</span></span><br><span class="line"><span class="comment">// promise1</span></span><br><span class="line"><span class="comment">// promise2</span></span><br><span class="line"><span class="comment">// timer over</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">所有任务分为宏任务（macrotask ）和微任务（microtask ） 两种。</span><br><span class="line"><span class="title class_">MacroTask</span>（宏任务）：* script全部代码、<span class="built_in">setTimeout</span>、<span class="built_in">setInterval</span>、I/O、<span class="variable constant_">UI</span> <span class="title class_">Rendering</span>。</span><br><span class="line"><span class="title class_">MicroTask</span>（微任务）：* <span class="title class_">Process</span>.<span class="property">nextTick</span>（<span class="title class_">Node</span>独有）、<span class="title class_">Promise</span>...</span><br><span class="line"></span><br><span class="line">在挂起任务时，<span class="variable constant_">JS</span> 引擎会将所有任务按照类别分到这两个队列中，首先在 宏任务 的队列中取出第一个任务，执行完毕后取出 微任务 队列中的所有任务顺序执行；之后新的事件循环开始，取宏任务的第一个，周而复始，直至两个队列的任务都取完。</span><br></pre></td></tr></table></figure><p><img src="%E7%AC%94%E8%AE%B0.assets/15586502-4f2d3f71a94a4a00.webp" alt="img"></p><p><img src="%E7%AC%94%E8%AE%B0.assets/15586502-30ee422b0922669e.webp" alt="img"></p><h5 id="17-http相关"><a href="#17-http相关" class="headerlink" title="17. http相关"></a>17. http相关</h5><p><strong>http状态码有那些？分别代表是什么意思？</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">  [</span><br><span class="line">      100  Continue   继续，一般在发送post请求时，已发送了http header之后服务端将返回此信息，表示确认，之后发送具体参数信息</span><br><span class="line">      200  OK         正常返回信息</span><br><span class="line">      201  Created    请求成功并且服务器创建了新的资源</span><br><span class="line">      202  Accepted   服务器已接受请求，但尚未处理</span><br><span class="line">      </span><br><span class="line">      301  Moved Permanently  请求的网页已永久移动到新位置。</span><br><span class="line">      302 Found       临时性重定向。</span><br><span class="line">      307 Internal Redirect  内部重定向</span><br><span class="line">      </span><br><span class="line">      304  Not Modified 自从上次请求后，请求的网页未修改过。 协商缓存 </span><br><span class="line">200  memory cache  强缓存</span><br><span class="line"></span><br><span class="line">      400 Bad Request  服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起请求。</span><br><span class="line">      401 Unauthorized 请求未授权。</span><br><span class="line">      403 Forbidden   禁止访问。</span><br><span class="line">      404 Not Found   找不到如何与 URI 相匹配的资源。</span><br><span class="line"></span><br><span class="line">      500 Internal Server Error  最常见的服务器端错误。</span><br><span class="line">      503 Service Unavailable 服务器端暂时无法处理请求（可能是过载或维护）。</span><br><span class="line">  ]</span><br></pre></td></tr></table></figure><h5 id="18-一个页面从输入-URL-到页面加载显示完成，这个过程中都发生了什么？"><a href="#18-一个页面从输入-URL-到页面加载显示完成，这个过程中都发生了什么？" class="headerlink" title="18. 一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？"></a>18. 一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？</h5><ul><li>01.浏览器查找域名对应的IP地址(DNS 查询：浏览器缓存-&gt;系统缓存-&gt;路由器缓存-&gt;ISP DNS 缓存-&gt;根域名服务器)</li><li>02.浏览器向 Web 服务器发送一个 HTTP 请求（TCP三次握手）</li><li>03.服务器 301 重定向（从 <a href="http://example.com">http://example.com</a> 重定向到 <a href="http://www.example.com）">http://www.example.com）</a></li><li>04.浏览器跟踪重定向地址，请求另一个带 www 的网址</li><li>05.服务器处理请求（通过路由读取资源）</li><li>06.服务器返回一个 HTTP 响应（报头中把 Content-type 设置为 ‘text/html’）</li><li>07.浏览器进 DOM 树构建</li><li>08.浏览器发送请求获取嵌在 HTML 中的资源（如图片、音频、视频、CSS、JS等）</li><li>09.浏览器显示完成页面</li><li>10.浏览器发送异步请求</li></ul><h5 id="19-前端攻击"><a href="#19-前端攻击" class="headerlink" title="19. 前端攻击"></a>19. 前端攻击</h5><h6 id="1-CSRF的基本概念、缩写、全称"><a href="#1-CSRF的基本概念、缩写、全称" class="headerlink" title="1) CSRF的基本概念、缩写、全称"></a>1) CSRF的基本概念、缩写、全称</h6><blockquote><p><code>CSRF</code>（<code>Cross-site request forgery</code>）：<strong>跨站请求伪造</strong>。</p></blockquote><p><img src="http://img.smyhvae.com/20180307_1735.png" alt=""></p><blockquote><p>用户是网站A的注册用户，且登录进去，于是网站A就给用户下发<code>cookie</code>。</p><p>从上图可以看出，要完成一次<code>CSRF</code>攻击，受害者必须满足两个必要的条件：</p></blockquote><ol><li>登录受信任网站<code>A</code>，并在本地生成<code>Cookie</code>。（如果用户没有登录网站<code>A</code>，那么网站<code>B</code>在诱导的时候，请求网站<code>A</code>的<code>api</code>接口时，会提示你登录）</li><li>在不登出<code>A</code>的情况下，访问危险网站<code>B</code>（其实是利用了网站<code>A</code>的漏洞）。</li></ol><blockquote><p>我们在讲<code>CSRF</code>时，一定要把上面的两点说清楚。</p><p>温馨提示一下，<code>cookie</code>保证了用户可以处于登录状态，但网站<code>B</code>其实拿不到 <code>cookie</code>。</p><p>举个例子，前段时间里，微博网站有个<code>api</code>接口有漏洞，导致很多用户的粉丝暴增。</p></blockquote><p><strong>CSRF的防范措施</strong></p><p><strong>方法一、Token 验证：</strong>（用的最多）</p><ol><li>服务器发送给客户端一个<code>token</code>；</li><li>客户端提交的表单中带着这个<code>token</code>。</li><li>如果这个 <code>token</code> 不合法，那么服务器拒绝这个请求。</li></ol><p><strong>方法二：隐藏令牌：</strong></p><ul><li>把 <code>token</code> 隐藏在 <code>http</code> 的 <code>head</code>头中。</li></ul><blockquote><p>方法二和方法一有点像，本质上没有太大区别，只是使用方式上有区别。</p></blockquote><p><strong>方法三、Referer 验证：</strong></p><blockquote><p><code>Referer</code> 指的是页面请求来源。意思是，<strong>只接受本站的请求，服务器才做响应</strong>；如果不是，就拦截。</p></blockquote><h6 id="2-XSS的攻击原理"><a href="#2-XSS的攻击原理" class="headerlink" title="2) XSS的攻击原理"></a>2) XSS的攻击原理</h6><blockquote><p><code>XSS</code>攻击的核心原理是：不需要你做任何的登录认证，它会通过合法的操作（比如在<code>url</code>中输入、在评论框中输入），向你的页面注入脚本（可能是<code>js</code>、<code>hmtl</code>代码块等）。</p><p>最后导致的结果可能是：</p></blockquote><ul><li>盗用<code>Cookie</code></li><li>破坏页面的正常结构，插入广告等恶意内容</li><li><code>D-doss</code>攻击</li></ul><p><strong>XSS的防范措施主要有三个：</strong></p><p><strong>1. 编码</strong>：</p><blockquote><p>对用户输入的数据进行<code>HTML Entity</code>编码。</p></blockquote><p><strong>2、过滤：</strong></p><ul><li>移除用户输入的和事件相关的属性。如<code>onerror</code>可以自动触发攻击，还有<code>onclick</code>等。（总而言是，过滤掉一些不安全的内容）</li><li>移除用户输入的<code>Style</code>节点、<code>Script</code>节点、<code>Iframe</code>节点。（尤其是<code>Script</code>节点，它可是支持跨域的呀，一定要移除）。</li></ul><h6 id="3-CSRF-和-XSS-的区别"><a href="#3-CSRF-和-XSS-的区别" class="headerlink" title="3)  CSRF 和 XSS 的区别"></a>3)  CSRF 和 XSS 的区别</h6><blockquote><p>面试官还可能喜欢问二者的区别。</p></blockquote><ul><li><code>CSRF</code>：是利用网站<code>A</code>本身的漏洞，去请求网站<code>A</code>的<code>api</code>。</li><li><code>XSS</code>：是向网站 <code>A</code> 注入 <code>JS</code>代码，然后执行 <code>JS</code> 里的代码，篡改网站<code>A</code>的内容。</li></ul><h4 id="四-ES6-ES13高频面试题"><a href="#四-ES6-ES13高频面试题" class="headerlink" title="四. ES6-ES13高频面试题"></a>四. ES6-ES13高频面试题</h4><h5 id="1-ES6新增的方法"><a href="#1-ES6新增的方法" class="headerlink" title="1. ES6新增的方法"></a>1. ES6新增的方法</h5><ul><li><p>let和const，解构赋值、模板字符串、箭头函数。</p></li><li><p>Symbol、Map、Set三种常用的数据类型。</p></li><li><p>Proxy重新定义了数据劫持的能力</p></li><li><p>Reflect定义了一套标准化的数据操作的方式</p></li><li><p>Promise确实的解决了异步逻辑嵌套及回调地狱问题。定义了异步逻辑的三种状态pending、rejected、fullfilled, 搭配then、catch、all、race等方法以及async await语法糖，大量简化了异步操作。</p></li></ul><ul><li><p>Generator函数，可以将异步逻辑划片执行。</p><ul><li>Generator 函数是 ES6 提供的一种异步编程解决方案</li><li>Generator 函数是一个状态机，封装了多个内部状态。</li><li>执行 Generator 函数会返回一个遍历器对象，也就是说，Generator 函数除了状态机，还是一个遍历器对象生成函数。返回的遍历器对象，可以依次遍历 Generator 函数内部的每一个状态。</li></ul></li><li><p>新增了class类的概念</p></li><li><p>ES6 Modules</p></li></ul><h5 id="2-var-let-const的区别"><a href="#2-var-let-const的区别" class="headerlink" title="2. var, let, const的区别"></a>2. var, let, const的区别</h5><p>ES6新增了定义变量的关键字 let和const， 分别用于定义块级变量和常量</p><p>let， const不会声明提前， 存在暂时性死区</p><p>外部无法使用到内部的let和const定义的变量， 存在块级作用域限制]</p><p>const 定义的常量， 无法更改。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">     <span class="keyword">let</span> name =<span class="string">&quot;kerwin&quot;</span></span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">const</span> obj = &#123;<span class="attr">name</span>:<span class="string">&quot;kerwin&quot;</span>&#125;</span><br><span class="line"> obj.<span class="property">name</span>=<span class="string">&quot;xiaoming&quot;</span></span><br><span class="line"> <span class="comment">// obj = &#123;name:&quot;xioamng&quot;&#125;</span></span><br><span class="line"> <span class="comment">// obj= &#x27;dwadwa&#x27;</span></span><br></pre></td></tr></table></figure><h5 id="3-箭头函数"><a href="#3-箭头函数" class="headerlink" title="3. 箭头函数"></a>3. 箭头函数</h5><p>箭头函数是ES6推出的，所以在低版本浏览器是有兼容问题的，语法简介明了，逻辑更清晰。</p><p>箭头函数没有自己的this，this指向外部的this，并且this会在创建的时候就绑定好.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fn1 = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">fn1</span>() <span class="comment">// window</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;  </span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;tom&#x27;</span>,  </span><br><span class="line">  fn2 () &#123;    </span><br><span class="line">    <span class="title function_">fn1</span>() <span class="comment">// window    </span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>) <span class="comment">// obj  </span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.<span class="title function_">fn2</span>()</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// 在箭头函数定义的位置往上数，这一行是可以打印出 this 的</span><br><span class="line">// 因为这里的 this 是 window</span><br><span class="line">// 所以箭头函数内部的 this 就是 window</span><br><span class="line">const obj = &#123;</span><br><span class="line">  fn: function () &#123;</span><br><span class="line">    console.log(this)</span><br><span class="line">  &#125;,</span><br><span class="line">  // 这个位置是箭头函数的上一行，但是不能打印出 this</span><br><span class="line">  fun: () =&gt; &#123;</span><br><span class="line">    // 箭头函数内部的 this 是书写箭头函数的上一行一个可以打印出 this 的位置</span><br><span class="line">    console.log(this)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.fn()</span><br><span class="line">obj.fun()</span><br></pre></td></tr></table></figure><h5 id="4-解构"><a href="#4-解构" class="headerlink" title="4. 解构"></a>4. 解构</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;type,payload&#125; = data;  <span class="comment">// &#123;type:&quot;&quot;,payload:&quot;&quot;&#125;</span></span><br></pre></td></tr></table></figure><h5 id="5-…-展开合并"><a href="#5-…-展开合并" class="headerlink" title="5 … 展开合并"></a>5 … 展开合并</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[...arr1,...arr2] </span><br><span class="line">&#123;...obj1,...obj2&#125; </span><br></pre></td></tr></table></figure><h5 id="6-promise"><a href="#6-promise" class="headerlink" title="6. promise"></a>6. promise</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//异步处理方案</span></span><br><span class="line"><span class="number">1.</span> 回调函数</span><br><span class="line">   <span class="number">2.</span> <span class="title class_">Promise</span></span><br><span class="line">   <span class="number">3.</span> generator 生成器 <span class="keyword">yield</span> </span><br><span class="line">   <span class="number">4.</span> <span class="keyword">async</span> <span class="keyword">await</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//解决回调地狱 ，嵌套金字塔</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">test1</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve,rejet</span>)=&gt;</span>&#123;</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">resolve</span>(<span class="string">&quot;123&quot;</span>)</span><br><span class="line">&#125;, <span class="number">2000</span>)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">test1</span>().<span class="title function_">then</span>(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="function"><span class="params">error</span>=&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// pending reject fullfilled</span></span><br><span class="line"></span><br><span class="line">axios.<span class="title function_">get</span>(<span class="string">&quot;1.php&quot;</span>).<span class="title function_">then</span>(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line"><span class="keyword">return</span> axios.<span class="title function_">get</span>(<span class="number">2.</span>php,&#123;res&#125;)</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line"><span class="keyword">return</span> axios.<span class="title function_">get</span>(<span class="number">3.</span>php)</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(res.<span class="property">data</span>)</span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="function"><span class="params">error</span>=&gt;</span>&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(error)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">await</span> 写起来</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">test</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">await</span> axios.<span class="title function_">get</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">var</span> b= <span class="keyword">await</span> axios.<span class="title function_">get</span>(<span class="number">2</span>,&#123;a&#125;);</span><br><span class="line"><span class="keyword">var</span> c= <span class="keyword">await</span> axios.<span class="title function_">get</span>(<span class="number">3</span>,&#123;b&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">test</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">//所有的异步都结束</span></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">all</span>([axios.<span class="title function_">get</span>(<span class="number">1</span>),axios.<span class="title function_">get</span>(<span class="number">2</span>)]).<span class="title function_">then</span>(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line"><span class="comment">//loading隐藏</span></span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="function"><span class="params">error</span>=&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">race</span>([axios.<span class="title function_">get</span>(<span class="number">1</span>),axios.<span class="title function_">get</span>(<span class="number">2</span>)])</span><br><span class="line"></span><br><span class="line"><span class="string">`Promise.any()`</span>跟<span class="string">`Promise.race()`</span>方法很像，只有一点不同，就是<span class="string">`Promise.any()`</span>不会因为某个 <span class="title class_">Promise</span> 变成<span class="string">`rejected`</span>状态而结束，必须等到所有参数 <span class="title class_">Promise</span> 变成<span class="string">`rejected`</span>状态才会结束。</span><br></pre></td></tr></table></figure><h5 id="7-class-语法糖-gt-构造函数-babel-loader"><a href="#7-class-语法糖-gt-构造函数-babel-loader" class="headerlink" title="7 .class (语法糖 =&gt;  构造函数,babel-loader)"></a>7 .class (语法糖 =&gt;  构造函数,babel-loader)</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"><span class="title function_">constructor</span>(<span class="params">name,age</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> =age;</span><br><span class="line">&#125;</span><br><span class="line">say=<span class="function">()=&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> <span class="keyword">extends</span> <span class="title class_ inherited__">person</span>&#123;</span><br><span class="line"><span class="title function_">constructor</span>(<span class="params">name,age,location</span>) &#123;</span><br><span class="line">  <span class="variable language_">super</span>(name,age);</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">location</span> = location;</span><br><span class="line">&#125;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="8-模块化"><a href="#8-模块化" class="headerlink" title="8 .模块化"></a>8 .模块化</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> obj <span class="keyword">from</span> <span class="string">&quot;./a&quot;</span> ;  </span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> aaa;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123;test&#125; <span class="keyword">from</span> <span class="string">&quot;./b&quot;</span> ; </span><br><span class="line"><span class="keyword">export</span> &#123;test&#125; ; </span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> test =<span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable constant_">AMD</span> - 前端 异步加载 - 提前下载， 提前加载 <span class="built_in">require</span>.<span class="property">js</span></span><br><span class="line"><span class="variable constant_">CMD</span> -  异步加载 - 提前下载 ， 按需加载 -- 玉伯 -sea.<span class="property">js</span></span><br><span class="line"><span class="title class_">CommonJs</span> -同步加载（webpack）</span><br><span class="line"><span class="built_in">require</span>(<span class="string">&quot;./b&quot;</span>)    </span><br><span class="line">=&gt;<span class="variable language_">module</span>.<span class="property">exports</span> </span><br><span class="line">=&gt;<span class="built_in">exports</span></span><br><span class="line"><span class="title class_">ES6</span> - 模块化</span><br><span class="line"></span><br><span class="line"><span class="comment">//ES6 和 commonJS区别？</span></span><br><span class="line"><span class="comment">//ES6可以导入某几个接口 import &#123;a&#125; from &#x27;./module.js&#x27; + webpack- tree shaking 摇树优化</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//commonJS 导入整个文件</span></span><br></pre></td></tr></table></figure><h5 id="9-异步遍历器生成函数-大厂面试"><a href="#9-异步遍历器生成函数-大厂面试" class="headerlink" title="9. 异步遍历器生成函数(大厂面试)"></a>9. 异步遍历器生成函数(大厂面试)</h5><blockquote><p>Generator 函数返回一个同步遍历器，异步 Generator 函数的作用，是返回一个异步遍历器对象。在语法上，异步 Generator 函数就是async函数与 Generator 函数的结合。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">timer</span>(<span class="params">t</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">              <span class="title function_">resolve</span>(t)</span><br><span class="line">          &#125;, t)</span><br><span class="line">      &#125;)</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span>* <span class="title function_">fn</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="title function_">timer</span>(<span class="number">1000</span>)<span class="comment">//任务1</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="title function_">timer</span>(<span class="number">2000</span>)<span class="comment">//任务2</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="title function_">timer</span>(<span class="number">3000</span>)<span class="comment">//任务3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用一下 for await ...of</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">fn1</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> <span class="title function_">await</span>(<span class="params"><span class="keyword">const</span> val <span class="keyword">of</span> fn()</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;start&quot;</span>,<span class="title class_">Date</span>.<span class="title function_">now</span>())</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(val);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;end&quot;</span>,<span class="title class_">Date</span>.<span class="title function_">now</span>())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">fn1</span>();</span><br></pre></td></tr></table></figure><h4 id="五-工程化-amp-代码管理高频面试题"><a href="#五-工程化-amp-代码管理高频面试题" class="headerlink" title="五. 工程化&amp;代码管理高频面试题"></a>五. 工程化&amp;代码管理高频面试题</h4><h5 id="1-git常用命令以及工作中都怎么工作"><a href="#1-git常用命令以及工作中都怎么工作" class="headerlink" title="1. git常用命令以及工作中都怎么工作"></a>1. git常用命令以及工作中都怎么工作</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">git init 初始化仓库</span><br><span class="line"></span><br><span class="line">git status 查看当前各个区域的代码状态。</span><br><span class="line"></span><br><span class="line">git log查看commit记录</span><br><span class="line"></span><br><span class="line">git reflog查看完整记录</span><br><span class="line"></span><br><span class="line">git add 添加工作区代码到暂存区</span><br><span class="line"></span><br><span class="line"><span class="title class_">Git</span> commit 暂存区代码的提交</span><br><span class="line"></span><br><span class="line">git reset 代码的版本回退</span><br><span class="line"></span><br><span class="line">git stash 将暂存处代码收起来</span><br><span class="line"></span><br><span class="line">git stash pop 将收起来的暂存区的代码释放出来</span><br><span class="line"></span><br><span class="line"><span class="title class_">Git</span> tag 可以打标签</span><br><span class="line"></span><br><span class="line"><span class="title class_">Git</span> branch 基于当前分支创建一个分支</span><br><span class="line"></span><br><span class="line">git checkout 切换分支</span><br><span class="line"></span><br><span class="line">git merge 合并分支</span><br><span class="line"></span><br><span class="line">git remote add origin 添加远端仓库地址</span><br><span class="line"></span><br><span class="line">git clone 克隆仓库</span><br><span class="line"></span><br><span class="line">git pull下拉对应分支代码</span><br><span class="line"></span><br><span class="line">git push 上传对应分支代码</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>公司中每一个项目都会有一个对应的远端仓库（gitLab），我们需要创建账号并配置权限。</p><p>一般公司会有几个主要分支，分别对应4个环境，当代码更新的时候会通过流水线自动部署到对应的环境：</p><ol><li><p>发布分支（prod、master）这个分支代码对应的就是线上的代码</p></li><li><p>UAT分支（uat），这个分支上的代码对应的是公司内部演示用的分支</p></li><li><p>TEST分支（test），这个分支的代码是用于测试</p></li><li><p>DEV分支（dev），研发自测分支</p></li></ol><p>正常功能开发或者bug修复， 从dev分支拉取代码，进行开发就可以。</p><p>如果是解决线上bug，应该从master拉取一个分支（hotfix__）, 然后开发完成后将其合并到test或者uat，测试没有问题后，将其合并到master。还要将hotfix上对应的commit合并到dev分支， 专业dev分支也就修复了这个bug。</p><p>如果当前版本代码需要回退（功能不做了，要么要去先着急干别的）， 执行git reset —hard， 再回到当前的commit也是git reset 只不过需要注意，此时要通过git reflog来查看时间最后的一次commit。</p><h5 id="2-sass和-scss的区别"><a href="#2-sass和-scss的区别" class="headerlink" title="2. sass和 scss的区别"></a>2. sass和 scss的区别</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Sass 是一款强化 CSS 的辅助工具，它在 CSS 语法的基础上增加了变量 (variables)、嵌套 (nested rules)、混合 (mixins)、导入 (inline imports) 等高级功能，这些拓展令 CSS 更加强大与优雅。使用 Sass 以及 Sass 的样式库（如 Compass）有助于更好地组织管理样式文件，以及更高效地开发项目。</span><br></pre></td></tr></table></figure><p>scss只是sass的一个语言版本，.scss文件的特点是层级靠{}来区分，.sass文件的特点的层级靠缩进来区分</p><h5 id="3-前端工程化工具"><a href="#3-前端工程化工具" class="headerlink" title="3. 前端工程化工具"></a>3. 前端工程化工具</h5><blockquote><p>gulp&amp;webpack </p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">gulp -<span class="function"><span class="params">src</span>=&gt;</span><span class="title function_">pipe</span>(scss翻译).<span class="title function_">pipe</span>(css 合并).<span class="title function_">pipe</span>(css压缩)=&gt;dist</span><br><span class="line">gulp -<span class="function"><span class="params">src</span>=&gt;</span><span class="title function_">pipe</span>(模块化编译).<span class="title function_">pipe</span>(js压缩)=&gt;dist</span><br><span class="line">流程化</span><br><span class="line">webpack</span><br><span class="line">    模块化 默认支持的commonjs规范</span><br><span class="line"></span><br><span class="line">所有js模块打包生成一个js文件</span><br><span class="line">编译解析浏览器不能识别的语言 （scss ,.<span class="property">vue</span>, jsx, ts, <span class="title class_">ES6</span>） </span><br><span class="line"></span><br><span class="line">配置？</span><br><span class="line"> 入口</span><br><span class="line"> 出口</span><br><span class="line"> devserver 启动 自动刷新，热更新， 反向代理</span><br><span class="line"> sourcemap-调试代码 .<span class="property">map</span> （地图）</span><br><span class="line"></span><br><span class="line"> <span class="attr">loaders</span>: sass-loader css-loader file-loader  babel-loader vue-loader postcss-loader</span><br><span class="line"></span><br><span class="line"> <span class="attr">plugin</span>:  压缩, 提取公共库</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="4-webpack配置并且是否熟知代码分割流程及操作"><a href="#4-webpack配置并且是否熟知代码分割流程及操作" class="headerlink" title="4. webpack配置并且是否熟知代码分割流程及操作"></a>4. webpack配置并且是否熟知代码分割流程及操作</h5><p>webpack包含mode模式、entry入口、output出口、plugins插件、loader、resolve、devServer开发服务器相关的基本配置。</p><p>在webpack中可以通过多入口的配置，每个入口都会去查询对应的依赖关系图，进行单独的代码。</p><p>在模块化开发过程中往往会将各种不同类型的文件都看做是模块来进行互相导入导出，比如将图片、css、sass之类的文件都可以导入到js文件中，但是在打包的过程中需要将这些文件都寻找到然后单独的分离出去，这样就需要用到对应的loader来进行文件处理，不同的文件、不同的loader，处理方式也不一样。</p><p>比如css文件可以利用style-loader将其代码生成style标签放入到head中，也可以利用minicssextra插件中 loader将其抽离成css文件。</p><p>img文件可以利用url-loader和file-loader对其进行base64的转化或者单独抽出。</p><p>组件模块化导入的时候可以采用懒加载的形式，就会单独打包对应的代码。</p><p><img src="%E7%AC%94%E8%AE%B0.assets/image-20230214103342487.png" alt="image-20230214103342487"></p><h5 id="5-webpack-4大核心理念，-编译原理"><a href="#5-webpack-4大核心理念，-编译原理" class="headerlink" title="5.  webpack 4大核心理念， 编译原理?"></a>5.  webpack 4大核心理念， 编译原理?</h5><p>​      entry,output , loaders , pluguins<br>​       一切皆为模块，由于webpack只支持js文件，所以需要用loader 转换为webpack支持的模块，其中plugin 用于扩张webpack 的功能，在webpack构建生命周期的过程中，在合适的时机做了合适的事情。</p><h5 id="6-webapck构建优化实战-打包时间过长，-可以优化时间短点-20s"><a href="#6-webapck构建优化实战-打包时间过长，-可以优化时间短点-20s" class="headerlink" title="6. webapck构建优化实战 (打包时间过长， 可以优化时间短点  20s)"></a>6. webapck构建优化实战 (打包时间过长， 可以优化时间短点  20s)</h5><pre><code>（1）提取公共库， 避免重复引用。  使用 DllPlugin，把第三方库文件分离出来单独编译，并且缓存; 极大的减少业务页面的编译时间   dll方式也就是通过配置，告诉webpack指定库在项目中的位置，从而直接引入，不将其打包在内。（2）happypack, 多线程解析文件，如babel-loader等耗时较长的。 还可以配合cache-loader使用。 （3）缓存  cache-loader （4）  loaders应尽可能配置解析路径include参数，排除路径exclude参数， 减少解析时查询范围。 （5）dev 阶段 devtool 设置成cheap-module-eval-source-map， 已经能满足调试需求， 编译能更快。 （6）product 阶段 去掉source-map </code></pre><h4 id="六-NodeJS高频面试题"><a href="#六-NodeJS高频面试题" class="headerlink" title="六. NodeJS高频面试题"></a>六. NodeJS高频面试题</h4><h5 id="1-nodejs-创建静态服务器？"><a href="#1-nodejs-创建静态服务器？" class="headerlink" title="1. nodejs 创建静态服务器？"></a>1. nodejs 创建静态服务器？</h5><blockquote><p>要使用 HTTP 服务器和客户端，则必须 <code>require(&#39;http&#39;)</code>。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建本地服务器来从其接收数据</span></span><br><span class="line"><span class="keyword">const</span> server = http.<span class="title function_">createServer</span>(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  res.<span class="title function_">writeHead</span>(<span class="number">200</span>, &#123; <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/json&#x27;</span> &#125;);</span><br><span class="line">  res.<span class="title function_">end</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(&#123;</span><br><span class="line">    <span class="attr">data</span>: <span class="string">&#x27;Hello World!&#x27;</span></span><br><span class="line">  &#125;));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">server.<span class="title function_">listen</span>(<span class="number">8000</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建本地服务器来从其接收数据</span></span><br><span class="line"><span class="keyword">const</span> server = http.<span class="title function_">createServer</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听请求事件</span></span><br><span class="line">server.<span class="title function_">on</span>(<span class="string">&#x27;request&#x27;</span>, <span class="function">(<span class="params">request, res</span>) =&gt;</span> &#123;</span><br><span class="line">  res.<span class="title function_">writeHead</span>(<span class="number">200</span>, &#123; <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/json&#x27;</span> &#125;);</span><br><span class="line">  res.<span class="title function_">end</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(&#123;</span><br><span class="line">    <span class="attr">data</span>: <span class="string">&#x27;Hello World!&#x27;</span></span><br><span class="line">  &#125;));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">server.<span class="title function_">listen</span>(<span class="number">8000</span>);</span><br></pre></td></tr></table></figure><h5 id="2-commonJS规范-vs-ES6-模块化规范"><a href="#2-commonJS规范-vs-ES6-模块化规范" class="headerlink" title="2. commonJS规范 vs ES6 模块化规范"></a>2. commonJS规范 vs ES6 模块化规范</h5><pre><code>&gt; require导入， module.exports 导出import 导入， export default 导出</code></pre><blockquote><p>区别：import {某个几个接口} from ‘antd’  //webpack  (tree shaking 摇树优化)<br>           var myview = require(“antd”) //导入整个接口</p></blockquote><h5 id="3-socket通信-聊天"><a href="#3-socket通信-聊天" class="headerlink" title="3. socket通信 聊天"></a>3. socket通信 聊天</h5><p>WebSocket并不是全新的协议，而是利用了HTTP协议来建立连接。我们来看看WebSocket连接是如何创建的。</p><p>首先，WebSocket连接必须由浏览器发起，因为请求协议是一个标准的HTTP请求，格式如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">GET</span> <span class="attr">ws</span>:<span class="comment">//localhost:3000/ws/chat HTTP/1.1</span></span><br><span class="line"><span class="title class_">Host</span>: localhost</span><br><span class="line"><span class="title class_">Upgrade</span>: websocket</span><br><span class="line"><span class="title class_">Connection</span>: <span class="title class_">Upgrade</span></span><br><span class="line"><span class="title class_">Origin</span>: <span class="attr">http</span>:<span class="comment">//localhost:3000</span></span><br><span class="line"><span class="title class_">Sec</span>-<span class="title class_">WebSocket</span>-<span class="title class_">Key</span>: client-random-string</span><br><span class="line"><span class="title class_">Sec</span>-<span class="title class_">WebSocket</span>-<span class="title class_">Version</span>: <span class="number">13</span></span><br></pre></td></tr></table></figure><p>该请求和普通的HTTP请求有几点不同：</p><ol><li>GET请求的地址不是类似<code>/path/</code>，而是以<code>ws://</code>开头的地址；</li><li>请求头<code>Upgrade: websocket</code>和<code>Connection: Upgrade</code>表示这个连接将要被转换为WebSocket连接；</li><li><code>Sec-WebSocket-Key</code>是用于标识这个连接，并非用于加密数据；</li><li><code>Sec-WebSocket-Version</code>指定了WebSocket的协议版本。</li></ol><p>随后，服务器如果接受该请求，就会返回如下响应：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 101 Switching Protocols</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Sec-WebSocket-Accept: server-random-string</span><br></pre></td></tr></table></figure><p>该响应代码<code>101</code>表示本次连接的HTTP协议即将被更改，更改后的协议就是<code>Upgrade: websocket</code>指定的WebSocket协议。</p><p>版本号和子协议规定了双方能理解的数据格式，以及是否支持压缩等等。如果仅使用WebSocket的API，就不需要关心这些。</p><p>现在，一个WebSocket连接就建立成功，浏览器和服务器就可以随时主动发送消息给对方。消息有两种，一种是文本，一种是二进制数据。通常，我们可以发送JSON格式的文本，这样，在浏览器处理起来就十分容易。</p><p><strong>为什么WebSocket连接可以实现全双工通信而HTTP连接不行呢？实际上HTTP协议是建立在TCP协议之上的，TCP协议本身就实现了全双工通信，但是HTTP协议的请求－应答机制限制了全双工通信。WebSocket连接建立以后，其实只是简单规定了一下：接下来，咱们通信就不使用HTTP协议了，直接互相发数据吧。</strong></p><p>安全的WebSocket连接机制和HTTPS类似。首先，浏览器用<code>wss://xxx</code>创建WebSocket连接时，会先通过HTTPS创建安全的连接，然后，该HTTPS连接升级为WebSocket连接，底层通信走的仍然是安全的SSL/TLS协议。</p><p>  <code>websocket全双工, 双向通信 onopen  onmessage  onclose onerror</code></p><p>服务器：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span>  <span class="title class_">WebSocket</span> = <span class="built_in">require</span>(<span class="string">&quot;ws&quot;</span>)</span><br><span class="line"><span class="title class_">WebSocketServer</span> = <span class="title class_">WebSocket</span>.<span class="property">WebSocketServer</span></span><br><span class="line"><span class="keyword">const</span> wss = <span class="keyword">new</span> <span class="title class_">WebSocketServer</span>(&#123; <span class="attr">port</span>: <span class="number">8080</span> &#125;);</span><br><span class="line">wss.<span class="title function_">on</span>(<span class="string">&#x27;connection&#x27;</span>, <span class="keyword">function</span> <span class="title function_">connection</span>(<span class="params">ws</span>) &#123;</span><br><span class="line">    ws.<span class="title function_">on</span>(<span class="string">&#x27;message&#x27;</span>, <span class="keyword">function</span> <span class="title function_">message</span>(<span class="params">data, isBinary</span>) &#123;</span><br><span class="line">        wss.<span class="property">clients</span>.<span class="title function_">forEach</span>(<span class="keyword">function</span> <span class="title function_">each</span>(<span class="params">client</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (client !== ws &amp;&amp; client.<span class="property">readyState</span> === <span class="title class_">WebSocket</span>.<span class="property">OPEN</span>) &#123;</span><br><span class="line">                client.<span class="title function_">send</span>(data, &#123; <span class="attr">binary</span>: isBinary &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    ws.<span class="title function_">send</span>(<span class="string">&#x27;欢迎加入聊天室&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>客户端：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ws = <span class="keyword">new</span> <span class="title class_">WebSocket</span>(<span class="string">&quot;ws://localhost:8080&quot;</span>)</span><br><span class="line">ws.<span class="property">onopen</span> = <span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;open&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">ws.<span class="property">onmessage</span> = <span class="function">(<span class="params">evt</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(evt.<span class="property">data</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="4-mongoDB-基本操作-增删改查"><a href="#4-mongoDB-基本操作-增删改查" class="headerlink" title="4. mongoDB 基本操作(增删改查)"></a>4. mongoDB 基本操作(增删改查)</h5><p><img src="%E7%AC%94%E8%AE%B0.assets/image-20220413085332378.png" alt="image-20220413085332378" style="zoom:67%;float:left" /></p><p><img src="%E7%AC%94%E8%AE%B0.assets/image-20220413090707891.png" alt="image-20220413090707891" style="zoom: 67%;float:left;" /></p><p>连接数据库</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mongoose = <span class="built_in">require</span>(<span class="string">&quot;mongoose&quot;</span>)</span><br><span class="line"></span><br><span class="line">mongoose.<span class="title function_">connect</span>(<span class="string">&quot;mongodb://127.0.0.1:27017/company-system&quot;</span>)</span><br></pre></td></tr></table></figure><p>创建模型</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mongoose = <span class="built_in">require</span>(<span class="string">&quot;mongoose&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Schema</span> = mongoose.<span class="property">Schema</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">UserType</span> = &#123;</span><br><span class="line">    <span class="attr">username</span>:<span class="title class_">String</span>,</span><br><span class="line">    <span class="attr">password</span>:<span class="title class_">String</span>,</span><br><span class="line">    <span class="attr">gender</span>:<span class="title class_">Number</span>,</span><br><span class="line">    <span class="attr">introduction</span>:<span class="title class_">String</span>,</span><br><span class="line">    <span class="attr">avatar</span>:<span class="title class_">String</span>,</span><br><span class="line">    <span class="attr">role</span>:<span class="title class_">Number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">UserModel</span> = mongoose.<span class="title function_">model</span>(<span class="string">&quot;user&quot;</span>,<span class="keyword">new</span> <span class="title class_">Schema</span>(<span class="title class_">UserType</span>))</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span>  = <span class="title class_">UserModel</span> </span><br></pre></td></tr></table></figure><p>增加数据</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">UserModel</span>.<span class="title function_">create</span>(&#123;</span><br><span class="line">    introduction,username,gender,avatar,password,role</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>查询数据</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">UserModel</span>.<span class="title function_">find</span>(&#123;<span class="attr">username</span>:<span class="string">&quot;kerwin&quot;</span>&#125;,[<span class="string">&quot;username&quot;</span>,<span class="string">&quot;role&quot;</span>,<span class="string">&quot;introduction&quot;</span>,<span class="string">&quot;password&quot;</span>]).<span class="title function_">sort</span>(&#123;<span class="attr">createTime</span>:-<span class="number">1</span>&#125;).<span class="title function_">skip</span>(<span class="number">10</span>).<span class="title function_">limit</span>(<span class="number">10</span>)</span><br></pre></td></tr></table></figure><p>更新数据</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">UserModel</span>.<span class="title function_">updateOne</span>(&#123;</span><br><span class="line">    _id</span><br><span class="line">&#125;,&#123;</span><br><span class="line">    introduction,username,gender,avatar</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>删除数据</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">UserModel</span>.<span class="title function_">deleteOne</span>(&#123;_id&#125;)</span><br></pre></td></tr></table></figure><h5 id="5-token（jwt-json-web-token）-与-session配合cookie-（登录，鉴权）"><a href="#5-token（jwt-json-web-token）-与-session配合cookie-（登录，鉴权）" class="headerlink" title="5. token（jwt-json web token） 与 session配合cookie  （登录，鉴权）"></a>5. token（jwt-json web token） 与 session配合cookie  （登录，鉴权）</h5><h6 id="1-Cookie-amp-Session"><a href="#1-Cookie-amp-Session" class="headerlink" title="1. Cookie&amp;Session"></a>1. Cookie&amp;Session</h6><p>「HTTP 无状态」<strong>我们知道，HTTP 是无状态的。也就是说，HTTP 请求方和响应方间无法维护状态，都是一次性的，它不知道前后的请求都发生了什么。但有的场景下，我们需要维护状态。最典型的，一个用户登陆微博，发布、关注、评论，都应是在登录后的用户状态下的。</strong>「标记」那解决办法是什么呢？<img src="%E7%AC%94%E8%AE%B0.assets/image-20220414095345868.png" alt="image-20220414095345868"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&quot;express&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> session = <span class="built_in">require</span>(<span class="string">&quot;express-session&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">MongoStore</span> = <span class="built_in">require</span>(<span class="string">&quot;connect-mongo&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">express</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app.<span class="title function_">use</span>(</span><br><span class="line">  <span class="title function_">session</span>(&#123;</span><br><span class="line">    <span class="attr">secret</span>: <span class="string">&quot;this is session&quot;</span>, <span class="comment">// 服务器生成 session 的签名</span></span><br><span class="line">    <span class="attr">resave</span>: <span class="literal">true</span>, </span><br><span class="line">    <span class="attr">saveUninitialized</span>: <span class="literal">true</span>, <span class="comment">//强制将为初始化的 session 存储</span></span><br><span class="line">    <span class="attr">cookie</span>: &#123;</span><br><span class="line">      <span class="attr">maxAge</span>: <span class="number">1000</span> * <span class="number">60</span> * <span class="number">10</span>,<span class="comment">// 过期时间</span></span><br><span class="line">      <span class="attr">secure</span>: <span class="literal">false</span>, <span class="comment">// 为 true 时候表示只有 https 协议才能访问cookie</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">rolling</span>: <span class="literal">true</span>, <span class="comment">//为 true 表示 超时前刷新，cookie 会重新计时； 为 false 表示在超时前刷新多少次，都是按照第一次刷新开始计时。</span></span><br><span class="line">    <span class="attr">store</span>: <span class="title class_">MongoStore</span>.<span class="title function_">create</span>(&#123;</span><br><span class="line">      <span class="attr">mongoUrl</span>: <span class="string">&#x27;mongodb://127.0.0.1:27017/kerwin_session&#x27;</span>,</span><br><span class="line">      <span class="attr">ttl</span>: <span class="number">1000</span> * <span class="number">60</span> * <span class="number">10</span> <span class="comment">// 过期时间</span></span><br><span class="line">  &#125;),</span><br><span class="line"></span><br><span class="line">  &#125;)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">use</span>(<span class="function">(<span class="params">req,res,next</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(req.<span class="property">url</span>===<span class="string">&quot;/login&quot;</span>)&#123;</span><br><span class="line">    <span class="title function_">next</span>()</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(req.<span class="property">session</span>.<span class="property">user</span>)&#123;</span><br><span class="line">      req.<span class="property">session</span>.<span class="property">garbage</span> = <span class="title class_">Date</span>();</span><br><span class="line">      <span class="title function_">next</span>();</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">     res.<span class="title function_">redirect</span>(<span class="string">&quot;/login&quot;</span>)   </span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h6 id="2-JSON-Web-Token-JWT"><a href="#2-JSON-Web-Token-JWT" class="headerlink" title="2. JSON Web Token (JWT)"></a>2. JSON Web Token (JWT)</h6><h6 id="（1）介绍"><a href="#（1）介绍" class="headerlink" title="（1）介绍"></a>（1）介绍</h6><p><img src="%E7%AC%94%E8%AE%B0.assets/image-20220415082822828.png" alt="image-20220415082822828"></p><p>我为什么要保存这可恶的session呢， 只让每个客户端去保存该多好？</p><p><img src="%E7%AC%94%E8%AE%B0.assets/image-20220415083015066.png" alt="image-20220415083015066"></p><p>当然， 如果一个人的token 被别人偷走了， 那我也没办法， 我也会认为小偷就是合法用户， 这其实和一个人的session id 被别人偷走是一样的。</p><p>这样一来， 我就不保存session id 了， 我只是生成token , 然后验证token ， 我用我的CPU计算时间获取了我的session 存储空间 ！</p><p>解除了session id这个负担， 可以说是无事一身轻， 我的机器集群现在可以轻松地做水平扩展， 用户访问量增大， 直接加机器就行。 这种无状态的感觉实在是太好了！</p><p>缺点：</p><blockquote><ol><li>占带宽，正常情况下要比 session_id 更大，需要消耗更多流量，挤占更多带宽，假如你的网站每月有 10 万次的浏览器，就意味着要多开销几十兆的流量。听起来并不多，但日积月累也是不小一笔开销。实际上，许多人会在 JWT 中存储的信息会更多；</li><li>无法在服务端注销，那么久很难解决劫持问题；</li><li>性能问题，JWT 的卖点之一就是加密签名，由于这个特性，接收方得以验证 JWT 是否有效且被信任。对于有着严格性能要求的 Web 应用，这并不理想，尤其对于单线程环境。</li></ol></blockquote><p>注意：</p><blockquote><p>CSRF攻击的原因是浏览器会自动带上cookie，而不会带上token；</p><p>以CSRF攻击为例：</p><p>cookie：用户点击了链接，cookie未失效，导致发起请求后后端以为是用户正常操作，于是进行扣款操作；<br>token：用户点击链接，由于浏览器不会自动带上token，所以即使发了请求，后端的token验证不会通过，所以不会进行扣款操作；</p></blockquote><h6 id="（2）实现"><a href="#（2）实现" class="headerlink" title="（2）实现"></a>（2）实现</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//jsonwebtoken 封装</span></span><br><span class="line"><span class="keyword">const</span> jsonwebtoken = <span class="built_in">require</span>(<span class="string">&quot;jsonwebtoken&quot;</span>)</span><br><span class="line"><span class="keyword">const</span> secret = <span class="string">&quot;kerwin&quot;</span></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">JWT</span> = &#123;</span><br><span class="line">    <span class="title function_">generate</span>(<span class="params">value,exprires</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> jsonwebtoken.<span class="title function_">sign</span>(value,secret,&#123;<span class="attr">expiresIn</span>:exprires&#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">verify</span>(<span class="params">token</span>)&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> jsonwebtoken.<span class="title function_">verify</span>(token,secret)</span><br><span class="line">        &#125;<span class="keyword">catch</span>(e)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="variable constant_">JWT</span></span><br></pre></td></tr></table></figure><h5 id="6-token-存储在-localStorage-里，当过期时过期的-token-怎么处理？"><a href="#6-token-存储在-localStorage-里，当过期时过期的-token-怎么处理？" class="headerlink" title="6. token 存储在 localStorage 里，当过期时过期的 token 怎么处理？"></a>6. token 存储在 localStorage 里，当过期时过期的 token 怎么处理？</h5><ul><li>当前端进行页面跳转或者需要鉴权的操作时，会发送请求到后台，而 token 会跟随请求头一起发送，后台通过请求头接收到 token 时会进行判断，若是过期了，应该返回一个 401 的状态码给前端，前端接收到以后，应该重定向到登录页要求用户重新登陆。axios 拦截器。</li></ul><h5 id="7-如何使用原生-Node-js-操做-cookie？"><a href="#7-如何使用原生-Node-js-操做-cookie？" class="headerlink" title="7. 如何使用原生 Node.js 操做 cookie？"></a>7. 如何使用原生 Node.js 操做 cookie？</h5><ul><li>获取 cookie： req.headers.cookie</li><li>设置 cookie： res.writeHead(200, { ‘Set-Cookie’: ‘myCookie=test’, ‘Content-Type’: ‘text/plain’ }) </li></ul><h5 id="8-nextTick-和-setImmediate-的区别是什么？"><a href="#8-nextTick-和-setImmediate-的区别是什么？" class="headerlink" title="8. nextTick 和 setImmediate 的区别是什么？"></a>8. nextTick 和 setImmediate 的区别是什么？</h5><ul><li>nextTick 和 setImmediate 都是延迟加载。但是 nextTick 是放在当前队列的最后一个执行，setImmediate 是在下一个队列的队首执行</li></ul><h5 id="9-koa-和-express-的区别"><a href="#9-koa-和-express-的区别" class="headerlink" title="9. koa 和 express 的区别"></a>9. koa 和 express 的区别</h5><ul><li>最大的区别在于语法，experss 的异步采用的是回调函数的形式，而 koa1 支持 generator + yeild，koa2 支持 await/async，无疑更加优雅。</li><li>中间件的区别，koa 采用洋葱模型，进去顺序执行，出去反向执行，支持 context 传递数据 express 本身无洋葱模型，需要引入插件，不支持 context express 的中间件中执行异步函数，执行顺序不会按照洋葱模型，异步的执行结果有可能被放到最后，response 之前。 这是由于，其中间件执行机制，递归回调中没有等待中间件中的异步函数执行完毕，就是没有 await 中间件异步函数</li><li>集成度区别 express 内置了很多中间件，集成度高，使用省心， koa 轻量简洁，容易定制</li></ul><h5 id="10-koa-中间件的实现原理"><a href="#10-koa-中间件的实现原理" class="headerlink" title="10. koa 中间件的实现原理"></a>10. koa 中间件的实现原理</h5><ol><li>每个中间件默认接受两个参数，第一个参数是 Context 对象，第二个参数是 next 函数。只要调用 next 函数，就可以把执行权转交给下一个中间件。</li><li>如果中间件内部没有调用 next 函数，那么执行权就不会传递下去。</li><li>多个中间件会形成一个栈结构，以“先进后出”的顺序执行。整个过程就像，先是入栈，然后出栈的操作。</li></ol><h5 id="11-图片上传到服务器的过程"><a href="#11-图片上传到服务器的过程" class="headerlink" title="11. 图片上传到服务器的过程"></a>11. 图片上传到服务器的过程</h5><p>Multer 是一个 node.js 中间件，用于处理 <code>multipart/form-data</code> 类型的表单数据，它主要用于上传文件。</p><p><strong>注意</strong>: Multer 不会处理任何非 <code>multipart/form-data</code> 类型的表单数据。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save multer</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//前后端分离-前端</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> params = <span class="keyword">new</span> <span class="title class_">FormData</span>()</span><br><span class="line">params.<span class="title function_">append</span>(<span class="string">&#x27;kerwinfile&#x27;</span>, file.<span class="property">file</span>)</span><br><span class="line">params.<span class="title function_">append</span>(<span class="string">&#x27;username&#x27;</span>, <span class="variable language_">this</span>.<span class="property">username</span>)</span><br><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line"><span class="attr">headers</span>: &#123;</span><br><span class="line"><span class="string">&quot;Content-Type&quot;</span>:<span class="string">&quot;multipart/form-data&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">http.<span class="title function_">post</span>(<span class="string">&#x27;/api/upload&#x27;</span>, params, config).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">imgpath</span> = <span class="string">&#x27;http://localhost:3000&#x27;</span> + res.<span class="property">data</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>Multer 会添加一个 <code>body</code> 对象 以及 <code>file</code> 或 <code>files</code> 对象 到 express 的 <code>request</code> 对象中。 <code>body</code> 对象包含表单的文本域信息，<code>file</code> 或 <code>files</code> 对象包含对象表单上传的文件信息。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//前后端分离-后端</span></span><br><span class="line">router.<span class="title function_">post</span>(<span class="string">&#x27;/upload&#x27;</span>, upload.<span class="title function_">single</span>(<span class="string">&#x27;kerwinfile&#x27;</span>),<span class="keyword">function</span>(<span class="params">req, res, next</span>) &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(req.<span class="property">file</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h5 id="12-什么是服务端渲染，服务端渲染的优点？"><a href="#12-什么是服务端渲染，服务端渲染的优点？" class="headerlink" title="12. 什么是服务端渲染，服务端渲染的优点？"></a>12. 什么是服务端渲染，服务端渲染的优点？</h5><ul><li>服务端渲染：页面渲染过程是在服务端完成，最终的 HTML 字符串，直接通过请求发送给客户端。</li><li>服务器端渲染的优势就是利于 SEO 优化，首屏加载快，因为客户端接收到的是完整的 HTML 页面。</li></ul><h5 id="13-Node-js-优缺点以及适用场景"><a href="#13-Node-js-优缺点以及适用场景" class="headerlink" title="13. Node.js 优缺点以及适用场景"></a>13. Node.js 优缺点以及适用场景</h5><ul><li>优点<ul><li>Node.js 采用事件驱动、异步编程，为网络服务而设计。简单易学，可以很快上手做后端设计。</li><li>Node.js 非阻塞模式的 IO 处理给 Node.js 带来在相对低系统资源耗用下的高性能与出众的负载能力，非常适合用作依赖其它 IO 资源的中间层服务。</li><li>Node.js 轻量高效，可以认为是数据密集型分布式部署环境下的实时应用系统的完美解决方案。</li></ul></li><li>缺点<ul><li>单线程，可靠性低，一旦这个进程崩掉，那么整个 web 服务就崩掉了。</li><li>开源组件库质量参差不齐，更新快，向下不兼容</li><li>不适合做企业级应用开发，特别是复杂业务逻辑的，代码不好维护，事务支持不是很好。</li></ul></li><li>适用场景<ul><li>大量 Ajax 请求的应用，例如个性化应用，每个用户看到的页面都不一样，需要在页面加载的时候发起 Ajax 请求，NodeJS 能响应大量的并发请求。</li><li>实时 ：如在线聊天，实时通知推送等等</li><li>工具类应用：海量的工具，小到前端压缩部署，大到桌面图形界面应用程序</li><li>总而言之，NodeJS 适合运用在高并发、I/O 密集、少量业务逻辑的场景。</li></ul></li></ul><h4 id="七-Vue高频面试题"><a href="#七-Vue高频面试题" class="headerlink" title="七. Vue高频面试题"></a>七. Vue高频面试题</h4><h5 id="1-解释单向数据流和双向数据绑定"><a href="#1-解释单向数据流和双向数据绑定" class="headerlink" title="1.  解释单向数据流和双向数据绑定"></a>1.  解释单向数据流和双向数据绑定</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">对于 <span class="title class_">Vue</span> 来说，组件之间的数据传递具有单向数据流这样的特性称为单向数据流，单向数据流（<span class="title class_">Unidirectional</span> data flow）方式使用一个上传数据流和一个下传数据流进行双向数据通信，两个数据流之间相互独立，单向数据流指只能从一个方向来修改状态。</span><br><span class="line"></span><br><span class="line">而双向数据绑定即为当数据发生变化的时候，视图也就发生变化，当视图发生变化的时候，数据也会跟着同步变化，两个数据流之间互为影响。</span><br></pre></td></tr></table></figure><h5 id="2-Object-defineProperty有什么缺点"><a href="#2-Object-defineProperty有什么缺点" class="headerlink" title="2. Object.defineProperty有什么缺点"></a>2. Object.defineProperty有什么缺点</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、无法监听es6的<span class="title class_">Set</span>、<span class="title class_">Map</span> 变化；</span><br><span class="line"><span class="number">2</span>、无法监听<span class="title class_">Class</span>类型的数据；</span><br><span class="line"><span class="number">3</span>、属性的新加或者删除也无法监听；</span><br><span class="line"><span class="number">4</span>、数组元素的增加和删除也无法监听。</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="3-对MVC，MVP，MVVM的理解"><a href="#3-对MVC，MVP，MVVM的理解" class="headerlink" title="3. 对MVC，MVP，MVVM的理解"></a>3. 对MVC，MVP，MVVM的理解</h5><p><img src="%E7%AC%94%E8%AE%B0.assets/image-20230215110550866.png" alt="image-20230215110550866" style="zoom:50%;" /><img src="%E7%AC%94%E8%AE%B0.assets/image-20230215110625108.png" alt="image-20230215110625108"></p><p><img src="%E7%AC%94%E8%AE%B0.assets/image-20230215110625108.png" alt="image-20230215110625108" style="zoom:50%;" /></p><p><img src="%E7%AC%94%E8%AE%B0.assets/image-20230215110650930.png" alt="image-20230215110650930" style="zoom:50%;" /></p><p><img src="%E7%AC%94%E8%AE%B0.assets/image-20230215110703001.png" alt="image-20230215110703001" style="zoom:50%;" /></p><h5 id="4-生命周期"><a href="#4-生命周期" class="headerlink" title="4. 生命周期"></a>4. 生命周期</h5><p><img src="%E7%AC%94%E8%AE%B0.assets/image-20230215104416987.png" alt="image-20230215104416987" style="zoom: 80%;" /></p><h5 id="5-你知道Vue响应式数据原理吗？Proxy-与-Object-defineProperty-优劣对比？"><a href="#5-你知道Vue响应式数据原理吗？Proxy-与-Object-defineProperty-优劣对比？" class="headerlink" title="5. 你知道Vue响应式数据原理吗？Proxy 与 Object.defineProperty 优劣对比？"></a>5. 你知道Vue响应式数据原理吗？Proxy 与 Object.defineProperty 优劣对比？</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 响应式原理</span></span><br><span class="line"></span><br><span class="line">vue的响应式实现主要是利用了<span class="title class_">Object</span>.<span class="property">defineProperty</span>的方法里面的setter 与getter方法的观察者模式来实现。在组件初始化时会给每一个data属性注册getter和setter，然后再<span class="keyword">new</span> 一个自己的<span class="title class_">Watcher</span>对象，此时watcher会立即调用组件的render函数去生成虚拟<span class="variable constant_">DOM</span>。在调用render的时候，就会需要用到data的属性值，此时会触发getter函数，将当前的<span class="title class_">Watcher</span>函数注册进sub里。当data属性发生改变之后，就会遍历sub里所有的watcher对象，通知它们去重新渲染组件。</span><br><span class="line"></span><br><span class="line"><span class="comment">// proxy的优势如下：</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Proxy</span> 可以直接监听对象而非属性，可以直接监听数组的变化；</span><br><span class="line"><span class="title class_">Proxy</span> 有多达 <span class="number">13</span> 种拦截方法,不限于 apply、ownKeys、deleteProperty、has 等等是 <span class="title class_">Object</span>.<span class="property">defineProperty</span> 不具备的；</span><br><span class="line"><span class="title class_">Proxy</span> 返回的是一个新对象,我们可以只操作新的对象达到目的,而 <span class="title class_">Object</span>.<span class="property">defineProperty</span> 只能遍历对象属性直接修改；</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Object.defineProperty 的优势如下:</span></span><br><span class="line"></span><br><span class="line">兼容性好，支持 <span class="title class_">IE9</span>，而 <span class="title class_">Proxy</span> 的存在浏览器兼容性问题,而且无法用 <span class="title function_">polyfill</span>(垫片)来弥补</span><br></pre></td></tr></table></figure><h5 id="6-Composition-API-的出现带来哪些新的开发体验，为啥需要这个？"><a href="#6-Composition-API-的出现带来哪些新的开发体验，为啥需要这个？" class="headerlink" title="6. Composition API 的出现带来哪些新的开发体验，为啥需要这个？"></a>6. Composition API 的出现带来哪些新的开发体验，为啥需要这个？</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>：在<span class="title class_">Compostion</span> <span class="variable constant_">API</span> 中时根据逻辑相关组织代码的，提高可读性和可维护性，类似于react的hook写法。</span><br><span class="line"><span class="number">2</span>：更好的重用逻辑代码，在<span class="title class_">Options</span> <span class="variable constant_">API</span>中通过<span class="title class_">MIxins</span>重用逻辑代码，容易发生命名冲突且关系不清。</span><br><span class="line"><span class="number">3</span>：解决在生命周期函数经常包含不相关的逻辑，但又不得不把相关逻辑分离到了几个不同方法中的问题，如在mounted中设置定时器，但需要在destroyed中来清除定时器，将同一功能的代码拆分到不同的位置，造成后期代码维护的困难。</span><br></pre></td></tr></table></figure><h5 id="7-对比-jQuery，Vue-有什么不同"><a href="#7-对比-jQuery，Vue-有什么不同" class="headerlink" title="7. 对比 jQuery，Vue 有什么不同"></a>7. 对比 jQuery，Vue 有什么不同</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jQuery 专注视图层，通过直接操作 <span class="variable constant_">DOM</span> 去实现页面的一些逻辑渲染；<span class="title class_">Vue</span> 专注于数据层，通过数据的双向绑定，最终表现在 <span class="variable constant_">DOM</span> 层面，减少了 <span class="variable constant_">DOM</span> 操作。<span class="title class_">Vue</span> 使用了组件化思想，使得项目子集职责清晰，提高了开发效率，方便重复利用，便于协同开发</span><br></pre></td></tr></table></figure><h5 id="8-如何再Vue的单文件组件里的样式定义全局CSS？"><a href="#8-如何再Vue的单文件组件里的样式定义全局CSS？" class="headerlink" title="8. 如何再Vue的单文件组件里的样式定义全局CSS？"></a>8. 如何再Vue的单文件组件里的样式定义全局CSS？</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在style标签上不加上scoped的属性，默认为全局css样式</span><br></pre></td></tr></table></figure><h5 id="9-说一下-root，-parent，-refs"><a href="#9-说一下-root，-parent，-refs" class="headerlink" title="9. 说一下$root，$parent，$refs"></a>9. 说一下$root，$parent，$refs</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$root，和$parent都能访问父组件的属性和方法，区别在于如果存在多级子组件，通过parent 访问得到的是它最近一级的父组件，通过root 访问得到的是根父组件。通过在子组件标签定义 ref 属性，在父组件中可以使用$refs 访问子组件实例。</span><br></pre></td></tr></table></figure><h5 id="10-Vue-中怎么自定义指令"><a href="#10-Vue-中怎么自定义指令" class="headerlink" title="10. Vue 中怎么自定义指令"></a>10. Vue 中怎么自定义指令</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">通过directive来自定义指令，自定义指令分为全局指令和局部指令，自定义指令也有几个的钩子函数，常用的有bind和update，当 bind 和 update 时触发相同行为，而不关心其它的钩子时可以简写。</span><br><span class="line"></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">directive</span>(<span class="string">&#x27;focus&#x27;</span>, &#123;</span><br><span class="line">  <span class="comment">// 当被绑定的元素插入到 DOM 中时……</span></span><br><span class="line">  <span class="attr">inserted</span>: <span class="keyword">function</span> (<span class="params">el</span>) &#123;</span><br><span class="line">    <span class="comment">// 聚焦元素</span></span><br><span class="line">    el.<span class="title function_">focus</span>()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">directive</span>(<span class="string">&#x27;color-swatch&#x27;</span>, <span class="keyword">function</span> (<span class="params">el, binding</span>) &#123;</span><br><span class="line">  el.<span class="property">style</span>.<span class="property">backgroundColor</span> = binding.<span class="property">value</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="11-Vue-中怎么自定义过滤器-vue3不支持"><a href="#11-Vue-中怎么自定义过滤器-vue3不支持" class="headerlink" title="11. Vue 中怎么自定义过滤器 (vue3不支持)"></a>11. Vue 中怎么自定义过滤器 (vue3不支持)</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">通过filter来定义过滤器，过滤器分为全局和局部过滤器，过滤器的主体为一个普通的函数，来对数据进行处理，可以传递参数。当有局部和全局两个名称相同的过滤器时候，会以就近原则进行调用，即：局部过滤器优先于全局过滤器被调用。</span><br><span class="line"></span><br><span class="line">&lt;!-- 在双花括号中 --&gt;</span><br><span class="line">&#123;&#123; message | capitalize &#125;&#125;</span><br><span class="line"></span><br><span class="line">&lt;!-- 在 <span class="string">`v-bind`</span> 中 --&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:id</span>=<span class="string">&quot;rawId | formatId&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="attr">filters</span>: &#123;</span><br><span class="line">  <span class="attr">capitalize</span>: <span class="keyword">function</span> (<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!value) <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">    value = value.<span class="title function_">toString</span>()</span><br><span class="line">    <span class="keyword">return</span> value.<span class="title function_">charAt</span>(<span class="number">0</span>).<span class="title function_">toUpperCase</span>() + value.<span class="title function_">slice</span>(<span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">filter</span>(<span class="string">&#x27;capitalize&#x27;</span>, <span class="keyword">function</span> (<span class="params">value</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!value) <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">  value = value.<span class="title function_">toString</span>()</span><br><span class="line">  <span class="keyword">return</span> value.<span class="title function_">charAt</span>(<span class="number">0</span>).<span class="title function_">toUpperCase</span>() + value.<span class="title function_">slice</span>(<span class="number">1</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h5 id="12-Vue-等单页面应用的优缺点"><a href="#12-Vue-等单页面应用的优缺点" class="headerlink" title="12. Vue 等单页面应用的优缺点"></a>12. Vue 等单页面应用的优缺点</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 优点</span></span><br><span class="line"><span class="number">1</span>单页应用的内容的改变不需要重新加载整个页面，web应用更具响应性和更令人着迷。</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、单页应用没有页面之间的切换，就不会出现“白屏现象”,也不会出现假死并有“闪烁”现象</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>、单页应用相对服务器压力小，服务器只用出数据就可以，不用管展示逻辑和页面合成，吞吐能力会提高几倍。</span><br><span class="line"></span><br><span class="line"><span class="number">4</span>、良好的前后端分离。后端不再负责模板渲染、输出页面工作，后端<span class="variable constant_">API</span>通用化，即同一套后端程序代码，不用修改就可以用于<span class="title class_">Web</span>界面、手机、平板等多种客户端。</span><br><span class="line"></span><br><span class="line"><span class="comment">// 缺点</span></span><br><span class="line"><span class="number">1</span>、首次加载耗时比较多。</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、<span class="variable constant_">SEO</span>问题，不利于百度，<span class="number">360</span>等搜索引擎收录。</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>、容易造成<span class="title class_">Css</span>命名冲突。</span><br><span class="line"></span><br><span class="line"><span class="number">4</span>、前进、后退、地址栏、书签等，都需要程序进行管理，页面的复杂度很高，需要一定的技能水平和开发成本高。</span><br></pre></td></tr></table></figure><h5 id="13-Vue-router-使用params与query传参有什么区别"><a href="#13-Vue-router-使用params与query传参有什么区别" class="headerlink" title="13. Vue-router 使用params与query传参有什么区别"></a>13. Vue-router 使用params与query传参有什么区别</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用法上</span></span><br><span class="line"><span class="number">1</span>：query要用path来引入，params要用name来引入，接收参数都是类似的，分别是<span class="variable language_">this</span>.<span class="property">$route</span>.<span class="property">query</span>和<span class="variable language_">this</span>.<span class="property">$route</span>.<span class="property">params</span>。</span><br><span class="line"></span><br><span class="line"><span class="comment">// 展示上</span></span><br><span class="line"></span><br><span class="line"><span class="number">2</span>：params是路由的一部分,必须要有。query是拼接在url后面的参数</span><br><span class="line"></span><br><span class="line"><span class="comment">// 命名的路由，并加上参数，让路由建立 url /users/eduardo</span></span><br><span class="line">router.<span class="title function_">push</span>(&#123; <span class="attr">name</span>: <span class="string">&#x27;user&#x27;</span>, <span class="attr">params</span>: &#123; <span class="attr">username</span>: <span class="string">&#x27;eduardo&#x27;</span> &#125; &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 带查询参数，结果是 /register?plan=private</span></span><br><span class="line">router.<span class="title function_">push</span>(&#123; <span class="attr">path</span>: <span class="string">&#x27;/register&#x27;</span>, <span class="attr">query</span>: &#123; <span class="attr">plan</span>: <span class="string">&#x27;private&#x27;</span> &#125; &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 带 hash，结果是 /about#team</span></span><br><span class="line">router.<span class="title function_">push</span>(&#123; <span class="attr">path</span>: <span class="string">&#x27;/about&#x27;</span>, <span class="attr">hash</span>: <span class="string">&#x27;#team&#x27;</span> &#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="14-Vue中-keep-alive-的作用"><a href="#14-Vue中-keep-alive-的作用" class="headerlink" title="14. Vue中 keep-alive 的作用"></a>14. Vue中 keep-alive 的作用</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">keep-alive 是 <span class="title class_">Vue</span> 内置的一个组件，可以使被包含的组件保留状态，或避免重新渲染。一旦使用keepalive包裹组件，此时mouted，created等钩子函数只会在第一次进入组件时调用，当再次切换回来时将不会调用。此时如果我们还想在每次切换时做一些事情，就需要用到另外的周期函数，actived和deactived，这两个钩子函数只有被keepalive包裹后才会调用。</span><br></pre></td></tr></table></figure><h5 id="15-Vue如何实现单页面应用"><a href="#15-Vue如何实现单页面应用" class="headerlink" title="15. Vue如何实现单页面应用"></a>15. Vue如何实现单页面应用</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">通常的url 地址由以下内容构成：协议名 域名 端口号 路径 参数 哈希值，当哈希值改变，页面不会发生跳转，单页面应用就是利用了这一点，给<span class="variable language_">window</span>注册onhashchange事件，当哈希值改变时通过location.<span class="property">hash</span>就能获得相应的哈希值，然后就能跳到相应的页面。</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span>hash通过监听浏览器的<span class="title function_">onhashchange</span>()事件变化，查找对应的路由规则</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>history原理： 利用<span class="variable constant_">H5</span>的 history中新增的两个<span class="variable constant_">API</span> <span class="title function_">pushState</span>() 和 <span class="title function_">replaceState</span>() 和一个事件onpopstate监听<span class="variable constant_">URL</span>变化</span><br></pre></td></tr></table></figure><h5 id="16-说出至少4种Vue当中的指令和它的用法？"><a href="#16-说出至少4种Vue当中的指令和它的用法？" class="headerlink" title="16. 说出至少4种Vue当中的指令和它的用法？"></a>16. 说出至少4种Vue当中的指令和它的用法？</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">v-<span class="keyword">if</span>(判断是否隐藏，用来判断元素是否创建)</span><br><span class="line">v-<span class="title function_">show</span>(元素的显示隐藏，类似css中的display的block和hidden)</span><br><span class="line">v-<span class="keyword">for</span>(把数据遍历出来)</span><br><span class="line">v-<span class="title function_">bind</span>(绑定属性)</span><br><span class="line">v-<span class="title function_">model</span>(实现双向绑定)</span><br></pre></td></tr></table></figure><h5 id="17-如何实现一个路径渲染多个组件？"><a href="#17-如何实现一个路径渲染多个组件？" class="headerlink" title="17. 如何实现一个路径渲染多个组件？"></a>17. 如何实现一个路径渲染多个组件？</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">可以通过命名视图(router-view)，它容许同一界面中拥有多个单独命名的视图，而不是只有一个单独的出口。如果 router-view 没有设置名字，那么默认为 <span class="keyword">default</span>。通过设置components即可同时渲染多个组件。</span><br><span class="line"></span><br><span class="line">&lt;router-view <span class="keyword">class</span>=<span class="string">&quot;view left-sidebar&quot;</span> name=<span class="string">&quot;LeftSidebar&quot;</span>&gt;&lt;/router-view&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">router-view</span> <span class="attr">class</span>=<span class="string">&quot;view main-content&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">router-view</span> <span class="attr">class</span>=<span class="string">&quot;view right-sidebar&quot;</span> <span class="attr">name</span>=<span class="string">&quot;RightSidebar&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = <span class="title function_">createRouter</span>(&#123;</span><br><span class="line">  <span class="attr">history</span>: <span class="title function_">createWebHashHistory</span>(),</span><br><span class="line">  <span class="attr">routes</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">path</span>: <span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">      <span class="attr">components</span>: &#123;</span><br><span class="line">        <span class="attr">default</span>: <span class="title class_">Home</span>,</span><br><span class="line">        <span class="comment">// LeftSidebar: LeftSidebar 的缩写</span></span><br><span class="line">        <span class="title class_">LeftSidebar</span>,</span><br><span class="line">        <span class="comment">// 它们与 `&lt;router-view&gt;` 上的 `name` 属性匹配</span></span><br><span class="line">        <span class="title class_">RightSidebar</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  ],</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h5 id="18-如何实现多个路径共享一个组件？"><a href="#18-如何实现多个路径共享一个组件？" class="headerlink" title="18. 如何实现多个路径共享一个组件？"></a>18. 如何实现多个路径共享一个组件？</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">只需将多个路径的component字段的值设置为同一个组件即可。</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">  &#123; <span class="attr">path</span>: <span class="string">&#x27;/&#x27;</span>, <span class="attr">component</span>: <span class="title class_">Home</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">path</span>: <span class="string">&#x27;/home&#x27;</span>, <span class="attr">component</span>: <span class="title class_">Home</span> &#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h5 id="19-如何监测动态路由的变化"><a href="#19-如何监测动态路由的变化" class="headerlink" title="19. 如何监测动态路由的变化"></a>19. 如何监测动态路由的变化</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">可以通过watch方法来对$route进行监听，或者通过导航守卫的钩子函数beforeRouteUpdate来监听它的变化。</span><br></pre></td></tr></table></figure><h5 id="20-vue-router-中的-router-link上-v-slot属性怎么用？"><a href="#20-vue-router-中的-router-link上-v-slot属性怎么用？" class="headerlink" title="20. vue-router 中的 router-link上 v-slot属性怎么用？"></a>20. vue-router 中的 router-link上 v-slot属性怎么用？</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">router-link 通过一个作用域插槽暴露底层的定制能力。这是一个更高阶的 <span class="variable constant_">API</span>，主要面向库作者，但也可以为开发者提供便利，多数情况用在一个类似 <span class="title class_">NavLink</span> 这样的自定义组件里。</span><br><span class="line"></span><br><span class="line">有时我们可能想把激活的 <span class="keyword">class</span> 应用到一个外部元素而不是 &lt;a&gt; 标签本身，这时你可以在一个 router-link 中包裹该元素并使用 v-slot 属性来创建链接：</span><br><span class="line"></span><br><span class="line">&lt;router-link</span><br><span class="line">  to=<span class="string">&quot;/foo&quot;</span></span><br><span class="line">  custom</span><br><span class="line">  v-slot=<span class="string">&quot;&#123; href, route, navigate, isActive, isExactActive &#125;&quot;</span></span><br><span class="line">&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">li</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    <span class="attr">:class</span>=<span class="string">&quot;[isActive &amp;&amp; &#x27;router-link-active&#x27;, isExactActive &amp;&amp; &#x27;router-link-exact-active&#x27;]&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  &gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">:href</span>=<span class="string">&quot;href&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;navigate&quot;</span>&gt;</span>&#123;&#123; route.fullPath &#125;&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">&lt;/router-link&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="21-Vue-如何去除url中的"><a href="#21-Vue-如何去除url中的" class="headerlink" title="21. Vue 如何去除url中的 #"></a>21. Vue 如何去除url中的 <code>#</code></h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">将路由模式改为history</span><br><span class="line"></span><br><span class="line">由于我们的应用是一个单页的客户端应用，如果没有适当的服务器配置，用户在浏览器中直接访问 <span class="attr">https</span>:<span class="comment">//example.com/user/id，就会得到一个 404 错误。这就尴尬了。</span></span><br><span class="line"></span><br><span class="line">不用担心：要解决这个问题，你需要做的就是在你的服务器上添加一个简单的回退路由。如果 <span class="variable constant_">URL</span> 不匹配任何静态资源，它应提供与你的应用程序中的 index.<span class="property">html</span> 相同的页面。</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> history = <span class="built_in">require</span>(<span class="string">&#x27;connect-history-api-fallback&#x27;</span>);</span><br><span class="line">app.<span class="title function_">use</span>(<span class="title function_">history</span>(&#123;</span><br><span class="line"><span class="attr">index</span>: <span class="string">&#x27;/index.html&#x27;</span></span><br><span class="line">&#125;)); <span class="comment">//注意放在所有的接口后面</span></span><br></pre></td></tr></table></figure><h5 id="22-route-和-router-的区别"><a href="#22-route-和-router-的区别" class="headerlink" title="22.  $route 和 $router 的区别"></a>22.  $route 和 $router 的区别</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$route用来获取路由的信息的，它是路由信息的一个对象，里面包含路由的一些基本信息，包括name、meta、path、hash、query、params、fullPath、matched、redirectedFrom等。而$router主要是用来操作路由的，它是<span class="title class_">VueRouter</span>的实例，包含了一些路由的跳转方法push，go, replace，钩子函数等</span><br></pre></td></tr></table></figure><h5 id="23-Vue-路由守卫"><a href="#23-Vue-路由守卫" class="headerlink" title="23. Vue 路由守卫"></a>23. Vue 路由守卫</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">vue-router 提供的导航守卫主要用来对路由的跳转进行监控，控制它的跳转或取消，路由守卫有全局的, 单个路由独享的, 或者组件级的。导航钩子有<span class="number">3</span>个参数：</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>、<span class="attr">to</span>:即将要进入的目标路由对象；</span><br><span class="line"><span class="number">2</span>、<span class="attr">from</span>:当前导航即将要离开的路由对象；</span><br><span class="line"><span class="number">3</span>、next ：调用该方法后，才能进入下一个钩子函数（afterEach）。</span><br><span class="line"></span><br><span class="line">router.<span class="title function_">beforeEach</span>(<span class="keyword">async</span> (to, <span class="keyword">from</span>) =&gt; &#123;</span><br><span class="line">   <span class="keyword">if</span> (</span><br><span class="line">     <span class="comment">// 检查用户是否已登录</span></span><br><span class="line">     !isAuthenticated &amp;&amp;</span><br><span class="line">     <span class="comment">// ❗️ 避免无限重定向</span></span><br><span class="line">     to.<span class="property">name</span> !== <span class="string">&#x27;Login&#x27;</span></span><br><span class="line">   ) &#123;</span><br><span class="line">     <span class="comment">// 将用户重定向到登录页面</span></span><br><span class="line">     <span class="keyword">return</span> &#123; <span class="attr">name</span>: <span class="string">&#x27;Login&#x27;</span> &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;)</span><br></pre></td></tr></table></figure><h5 id="24-Vue路由实现的底层原理"><a href="#24-Vue路由实现的底层原理" class="headerlink" title="24. Vue路由实现的底层原理"></a>24. Vue路由实现的底层原理</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">在<span class="title class_">Vue</span>中利用数据劫持defineProperty在原型prototype上初始化了一些getter,分别是router代表当前<span class="title class_">Router</span>的实例 、 route 代表当前<span class="title class_">Router</span>的信息。在install中也全局注册了router-view,router-link,其中的<span class="title class_">Vue</span>.<span class="property">util</span>.<span class="property">defineReactive</span>, 这是<span class="title class_">Vue</span>里面观察者劫持数据的方法，劫持_route，当_route触发setter方法的时候，则会通知到依赖的组件。</span><br><span class="line"></span><br><span class="line">接下来在init中，会挂载判断是路由的模式，是history或者是hash,点击行为按钮，调用hashchange或者popstate的同时更_route,_route的更新会触发route-view的重新渲染。</span><br></pre></td></tr></table></figure><h5 id="25-路由懒加载"><a href="#25-路由懒加载" class="headerlink" title="25. 路由懒加载"></a>25. 路由懒加载</h5><p>Vue Router 支持开箱即用的<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import#Dynamic_Imports">动态导入</a>，这意味着你可以用动态导入代替静态导入：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将</span></span><br><span class="line"><span class="comment">// import UserDetails from &#x27;./views/UserDetails.vue&#x27;</span></span><br><span class="line"><span class="comment">// 替换成</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">UserDetails</span> = (<span class="params"></span>) =&gt; <span class="keyword">import</span>(<span class="string">&#x27;./views/UserDetails.vue&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = <span class="title function_">createRouter</span>(&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="attr">routes</span>: [&#123; <span class="attr">path</span>: <span class="string">&#x27;/users/:id&#x27;</span>, <span class="attr">component</span>: <span class="title class_">UserDetails</span> &#125;],</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h5 id="26-用过插槽吗？用的是具名插槽还是匿名插槽"><a href="#26-用过插槽吗？用的是具名插槽还是匿名插槽" class="headerlink" title="26. 用过插槽吗？用的是具名插槽还是匿名插槽"></a>26. 用过插槽吗？用的是具名插槽还是匿名插槽</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">用过，都使用过。插槽相当于预留了一个位置，可以将我们书写在组件内的内容放入，写一个插槽就会将组件内的内容替换一次，两次则替换两次。为了自定义插槽的位置我们可以给插槽取名，它会根据插槽名来插入内容，一一对应。</span><br><span class="line"></span><br><span class="line">举例来说，这里有一个 &lt;<span class="title class_">FancyButton</span>&gt; 组件，可以像这样使用：</span><br><span class="line">template</span><br><span class="line">&lt;<span class="title class_">FancyButton</span>&gt;</span><br><span class="line">  <span class="title class_">Click</span> me! &lt;!-- 插槽内容 --&gt;</span><br><span class="line">&lt;/<span class="title class_">FancyButton</span>&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">而 &lt;<span class="title class_">FancyButton</span>&gt; 的模板是这样的：</span><br><span class="line"></span><br><span class="line">template</span><br><span class="line">&lt;button <span class="keyword">class</span>=<span class="string">&quot;fancy-btn&quot;</span>&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">slot</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span> &lt;!-- 插槽出口 --&gt;</span><br><span class="line">&lt;/button&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="27-Vue-loader解释一下"><a href="#27-Vue-loader解释一下" class="headerlink" title="27. Vue-loader解释一下"></a>27. Vue-loader解释一下</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">解析和转换 .<span class="property">vue</span> 文件，提取出其中的逻辑代码 script、样式代码 style、以及 <span class="variable constant_">HTML</span> 模版 template，再分别把它们交给对应的 <span class="title class_">Loader</span> 去处理。</span><br></pre></td></tr></table></figure><h5 id="28-Vue和React中diff算法区别"><a href="#28-Vue和React中diff算法区别" class="headerlink" title="28. Vue和React中diff算法区别"></a>28. Vue和React中diff算法区别</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vue和react的diff算法，都是忽略跨级比较，只做同级比较。vue diff时调动patch函数，参数是vnode和oldVnode，分别代表新旧节点。</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span>vue对比节点。当节点元素相同，但是classname不同，认为是不同类型的元素，删除重建，而react认为是同类型节点，只是修改节点属性。</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>vue的列表对比，采用的是两端到中间比对的方式，而react采用的是从左到右依次对比的方式。当一个集合只是把最后一个节点移到了第一个，react会把前面的节点依次移动，而vue只会把最后一个节点移到第一个。总体上，vue的方式比较高效。</span><br></pre></td></tr></table></figure><h5 id="29-请你说一下-Vue-中-create-和-mount-的区别"><a href="#29-请你说一下-Vue-中-create-和-mount-的区别" class="headerlink" title="29. 请你说一下 Vue 中 create 和 mount 的区别"></a>29. 请你说一下 Vue 中 create 和 mount 的区别</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create为组件初始化阶段，在此阶段主要完成数据观测(data observer)，属性和方法的运算， watch/event 事件回调。然而，挂载阶段还没开始，此时还未生成真实的<span class="variable constant_">DOM</span>，也就无法获取和操作<span class="variable constant_">DOM</span>元素。而mount主要完成从虚拟<span class="variable constant_">DOM</span>到真实<span class="variable constant_">DOM</span>的转换挂载，此时html已经渲染出来了，所以可以直接操作dom节点。</span><br></pre></td></tr></table></figure><h5 id="30-axios是什么？怎么使用？描述使用它实现登录功能的流程"><a href="#30-axios是什么？怎么使用？描述使用它实现登录功能的流程" class="headerlink" title="30. axios是什么？怎么使用？描述使用它实现登录功能的流程?"></a>30. axios是什么？怎么使用？描述使用它实现登录功能的流程?</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">axios 是请求后台资源的模块。 通过npm install axios -S来安装，在大多数情况下我们需要封装拦截器，在实现登录的过程中我们一般在请求拦截器中来加入token，在响应请求器中通过判断后端返回的状态码来对返回的数据进行不同的处理。如果发送的是跨域请求，需在配置文件中 config/index.<span class="property">js</span> 进行代理配置。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Add a request interceptor</span></span><br><span class="line">axios.<span class="property">interceptors</span>.<span class="property">request</span>.<span class="title function_">use</span>(<span class="keyword">function</span> (<span class="params">config</span>) &#123;</span><br><span class="line">    <span class="comment">// Do something before request is sent</span></span><br><span class="line">    <span class="keyword">return</span> config;</span><br><span class="line">  &#125;, <span class="keyword">function</span> (<span class="params">error</span>) &#123;</span><br><span class="line">    <span class="comment">// Do something with request error</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(error);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Add a response interceptor</span></span><br><span class="line">axios.<span class="property">interceptors</span>.<span class="property">response</span>.<span class="title function_">use</span>(<span class="keyword">function</span> (<span class="params">response</span>) &#123;</span><br><span class="line">    <span class="comment">// Any status code that lie within the range of 2xx cause this function to trigger</span></span><br><span class="line">    <span class="comment">// Do something with response data</span></span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">  &#125;, <span class="keyword">function</span> (<span class="params">error</span>) &#123;</span><br><span class="line">    <span class="comment">// Any status codes that falls outside the range of 2xx cause this function to trigger</span></span><br><span class="line">    <span class="comment">// Do something with response error</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(error);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="31-computed和watch的区别？watch实现原理？watch有几种写法？"><a href="#31-computed和watch的区别？watch实现原理？watch有几种写法？" class="headerlink" title="31. computed和watch的区别？watch实现原理？watch有几种写法？"></a>31. computed和watch的区别？watch实现原理？watch有几种写法？</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">计算属性computed : </span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> 支持缓存，只有依赖数据发生改变，才会重新进行计算</span><br><span class="line"><span class="number">2.</span> 不支持异步，当computed内有异步操作时无效，无法监听数据的变化</span><br><span class="line"><span class="number">3.</span>computed 属性值会默认走缓存，计算属性是基于它们的响应式依赖进行缓存的，也就是基于data中声明过或者父组件传递的props中的数据通过计算得到的值</span><br><span class="line"><span class="number">4.</span> 如果一个属性是由其他属性计算而来的，这个属性依赖其他属性，是一个多对一或者一对一，一般用computed</span><br><span class="line"><span class="number">5.</span>如果computed属性属性值是函数，那么默认会走get方法；函数的返回值就是属性的属性值；在computed中的，属性都有一个get和一个set方法，当数据变化时，调用set方法。</span><br><span class="line"></span><br><span class="line"><span class="attr">computed</span>: &#123;</span><br><span class="line">    <span class="comment">// 一个计算属性的 getter</span></span><br><span class="line">    <span class="title function_">publishedBooksMessage</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="comment">// `this` 指向当前组件实例</span></span><br><span class="line">      <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">author</span>.<span class="property">books</span>.<span class="property">length</span> &gt; <span class="number">0</span> ? <span class="string">&#x27;Yes&#x27;</span> : <span class="string">&#x27;No&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">侦听属性watch：</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> 不支持缓存，数据变，直接会触发相应的操作；</span><br><span class="line"><span class="number">2.</span>watch支持异步；</span><br><span class="line"><span class="number">3.</span>监听的函数接收两个参数，第一个参数是最新的值；第二个参数是输入之前的值；</span><br><span class="line"><span class="number">4.</span> 当一个属性发生变化时，需要执行对应的操作；一对多；</span><br><span class="line"><span class="number">5.</span> 监听数据必须是data中声明过或者父组件传递过来的props中的数据，当数据变化时，触发其他操作，函数有两个参数，</span><br><span class="line">immediate：组件加载立即触发回调函数执行，</span><br><span class="line"><span class="attr">deep</span>: 深度监听，为了发现对象内部值的变化，复杂类型的数据时使用，例如数组中的对象内容的改变，注意监听数组的变动不需要这么做。</span><br><span class="line"></span><br><span class="line"><span class="attr">watch</span>: &#123;</span><br><span class="line">    <span class="comment">// 每当 question 改变时，这个函数就会执行</span></span><br><span class="line">    <span class="title function_">question</span>(<span class="params">newQuestion, oldQuestion</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (newQuestion.<span class="title function_">includes</span>(<span class="string">&#x27;?&#x27;</span>)) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">getAnswer</span>()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"><span class="attr">watch</span>: &#123;</span><br><span class="line">    <span class="attr">someObject</span>: &#123;</span><br><span class="line">      <span class="title function_">handler</span>(<span class="params">newValue, oldValue</span>) &#123;</span><br><span class="line">        <span class="comment">// 注意：在嵌套的变更中，</span></span><br><span class="line">        <span class="comment">// 只要没有替换对象本身，</span></span><br><span class="line">        <span class="comment">// 那么这里的 `newValue` 和 `oldValue` 相同</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">deep</span>: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="32-Vue-forceUpdate的原理"><a href="#32-Vue-forceUpdate的原理" class="headerlink" title="32. Vue $forceUpdate的原理"></a>32. Vue $forceUpdate的原理</h5><p><strong>1、作用：</strong></p><p>迫使 <code>Vue</code> 实例重新渲染。注意它仅仅影响实例本身和插入插槽内容的子组件，而不是所有子组件。</p><p><strong>2、内部原理：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">$forceUpdate</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="attr">vm</span>: <span class="title class_">Component</span> = <span class="variable language_">this</span></span><br><span class="line">    <span class="keyword">if</span> (vm.<span class="property">_watcher</span>) &#123;</span><br><span class="line">        vm.<span class="property">_watcher</span>.<span class="title function_">update</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实例需要重新渲染是在依赖发生变化的时候会通知watcher，然后通知watcher来调用update方法，就是这么简单。</p><h5 id="33-v-for-key"><a href="#33-v-for-key" class="headerlink" title="33. v-for key"></a>33. v-for key</h5><ul><li>key是为Vue中的vnode标记的唯一id,通过这个key,我们的diff操作可以更准确、更快速</li><li>diff算法的过程中,先会进行新旧节点的首尾交叉对比,当无法匹配的时候会用新节点的key与旧节点进行比对,然后超出差异.</li></ul><blockquote><p>diff程可以概括为：oldCh和newCh各有两个头尾的变量StartIdx和EndIdx，它们的2个变量相互比较，一共有4种比较方式。如果4种比较都没匹配，如果设置了key，就会用key进行比较，在比较的过程中，变量会往中间靠，一旦StartIdx&gt;EndIdx表明oldCh和newCh至少有一个已经遍历完了，就会结束比较,这四种比较方式就是首、尾、旧尾新头、旧头新尾.</p><p>准确: 如果不加key,那么vue会选择复用节点(Vue的就地更新策略),导致之前节点的状态被保留下来,会产生一系列的bug. 快速: key的唯一性可以被Map数据结构充分利用,相比于遍历查找的时间复杂度<code>O(n)</code>,<code>Map</code>的时间复杂度仅仅为<code>O(1)</code></p></blockquote><h5 id="34-为什么要设置key值，可以用index吗？为什么不能？"><a href="#34-为什么要设置key值，可以用index吗？为什么不能？" class="headerlink" title="34. 为什么要设置key值，可以用index吗？为什么不能？"></a>34. 为什么要设置key值，可以用index吗？为什么不能？</h5><p>vue中列表循环需加:key=”唯一标识” 唯一标识可以是item里面id index等，因为vue组件高度复用增加Key可以标识组件的唯一性，为了更好地区别各个组件 key的作用主要是为了高效的更新虚拟DOM</p><h5 id="35-diff复杂度原理及具体过程画图"><a href="#35-diff复杂度原理及具体过程画图" class="headerlink" title="35. diff复杂度原理及具体过程画图"></a>35. diff复杂度原理及具体过程画图</h5><p>diff算法是一种通过同层的树节点进行比较的高效算法，避免了对树进行逐层搜索遍历，所以时间复杂度只有 O(n)。</p><p><img src="%E7%AC%94%E8%AE%B0.assets/image-20230216133653028.png" alt="image-20230216133653028"></p><p>diff算法有两个比较显著的特点：</p><p>1、比较只会在同层级进行, 不会跨层级比较。</p><p>2、在diff比较的过程中，循环从两边向中间收拢。</p><p>diff流程： 首先定义 oldStartIdx、newStartIdx、oldEndIdx 以及 newEndIdx 分别是新老两个 VNode 的两边的索引。</p><p>接下来是一个 while 循环，在这过程中，oldStartIdx、newStartIdx、oldEndIdx 以及 newEndIdx 会逐渐向中间靠拢。while 循环的退出条件是直到老节点或者新节点的开始位置大于结束位置。</p><p>while 循环中会遇到四种情况：</p><p>情形一：当新老 VNode 节点的 start 是同一节点时，直接 patchVnode 即可，同时新老 VNode 节点的开始索引都加 1。</p><p>情形二：当新老 VNode 节点的 end 是同一节点时，直接 patchVnode 即可，同时新老 VNode 节点的结束索引都减 1。</p><p>情形三：当老 VNode 节点的 start 和新 VNode 节点的 end 是同一节点时，这说明这次数据更新后 oldStartVnode 已经跑到了 oldEndVnode 后面去了。这时候在 patchVnode 后，还需要将当前真实 dom 节点移动到 oldEndVnode 的后面，同时老 VNode 节点开始索引加 1，新 VNode 节点的结束索引减 1。</p><p>情形四：当老 VNode 节点的 end 和新 VNode 节点的 start 是同一节点时，这说明这次数据更新后 oldEndVnode 跑到了 oldStartVnode 的前面去了。这时候在 patchVnode 后，还需要将当前真实 dom 节点移动到 oldStartVnode 的前面，同时老 VNode 节点结束索引减 1，新 VNode 节点的开始索引加 1。</p><p>while 循环的退出条件是直到老节点或者新节点的开始位置大于结束位置。</p><p>情形一：如果在循环中，oldStartIdx大于oldEndIdx了，那就表示oldChildren比newChildren先循环完毕，那么newChildren里面剩余的节点都是需要新增的节点，把[newStartIdx, newEndIdx]之间的所有节点都插入到DOM中</p><p>情形二：如果在循环中，newStartIdx大于newEndIdx了，那就表示newChildren比oldChildren先循环完毕，那么oldChildren里面剩余的节点都是需要删除的节点，把[oldStartIdx, oldEndIdx]之间的所有节点都删除</p><h5 id="36-Vue组件中的Data为什么是函数，根组件却是对象呢？"><a href="#36-Vue组件中的Data为什么是函数，根组件却是对象呢？" class="headerlink" title="36. Vue组件中的Data为什么是函数，根组件却是对象呢？"></a>36. Vue组件中的Data为什么是函数，根组件却是对象呢？</h5><p>综上可知，如果data是一个函数的话，这样每复用一次组件，就会返回一份新的data，类似于给每个组件实例创建一个私有的数据空间，让各个组件实例维护各自的数据。而单纯的写成对象形式，就使得所有组件实例共用了一份data，就会造成一个变了全都会变的结果。</p><p>所以说vue组件的data必须是函数。这都是因为js的特性带来的，跟vue本身设计无关。</p><h5 id="37-Vue的组件通信"><a href="#37-Vue的组件通信" class="headerlink" title="37. Vue的组件通信"></a>37. Vue的组件通信</h5><p>1、props和$emit</p><p>父组件向子组件传递数据是通过prop传递的，子组件传递数据给父组件是通过$emit触发事件</p><p>2、$attrs和$listeners</p><p>3、中央事件总线 bus</p><p>上面两种方式处理的都是父子组件之间的数据传递，而如果两个组件不是父子关系呢？这种情况下可以使用中央事件总线的方式。新建一个Vue事件bus对象，然后通过bus.$emit触发事件，bus.$on监听触发的事件。</p><p>4、provide和inject</p><p>父组件中通过provider来提供变量，然后在子组件中通过inject来注入变量。不论子组件有多深，只要调用了inject那么就可以注入provider中的数据。而不是局限于只能从当前父组件的prop属性来获取数据，只要在父组件的生命周期内，子组件都可以调用。</p><p>5、v-model</p><p>父组件通过v-model传递值给子组件时，会自动传递一个value的prop属性，在子组件中通过this.$emit(‘input’,val)自动修改v-model绑定的值</p><p>6、$parent和$children</p><p>7、boradcast和dispatch</p><p>8、vuex处理组件之间的数据交互 如果业务逻辑复杂，很多组件之间需要同时处理一些公共的数据，这个时候才有上面这一些方法可能不利于项目的维护，vuex的做法就是将这一些公共的数据抽离出来，然后其他组件就可以对这个公共数据进行读写操作，这样达到了解耦的目的。</p><h5 id="38-什么情况下使用-Vuex"><a href="#38-什么情况下使用-Vuex" class="headerlink" title="38. 什么情况下使用 Vuex"></a>38. 什么情况下使用 Vuex</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果应用够简单，最好不要使用 <span class="title class_">Vuex</span>，一个简单的 store 模式即可，需要构建一个中大型单页应用时，使用<span class="title class_">Vuex</span>能更好地在组件外部管理状态</span><br></pre></td></tr></table></figure><p><img src="%E7%AC%94%E8%AE%B0.assets/image-20230216130149318.png" alt="image-20230216130149318" style="zoom:67%;" /></p><h5 id="39-Vuex可以直接修改state的值吗？"><a href="#39-Vuex可以直接修改state的值吗？" class="headerlink" title="39. Vuex可以直接修改state的值吗？"></a>39. Vuex可以直接修改state的值吗？</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">可以直接修改，但是极其不推荐，state的修改必须在mutation来修改，否则无法被devtool所监测，无法监测数据的来源，无法保存状态快照，也就无法实现时间漫游/回滚之类的操作。</span><br></pre></td></tr></table></figure><h5 id="40-为什么Vuex的mutation不能做异步操作"><a href="#40-为什么Vuex的mutation不能做异步操作" class="headerlink" title="40. 为什么Vuex的mutation不能做异步操作"></a>40. 为什么Vuex的mutation不能做异步操作</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Vuex</span>中所有的状态更新的唯一途径都是mutation，异步操作通过 <span class="title class_">Action</span> 来提交 mutation实现，这样使得我们可以方便地跟踪每一个状态的变化，从而让我们能够实现一些工具帮助我们更好地了解我们的应用。每个mutation执行完成后都会对应到一个新的状态变更，这样devtools就可以打个快照存下来，否则无法被devtools所监测。如果mutation支持异步操作，就没有办法知道状态是何时更新的，无法很好的进行状态的追踪，给调试带来困难。</span><br></pre></td></tr></table></figure><h5 id="41-怎么修改Vuex中的状态？Vuex中有哪些方法"><a href="#41-怎么修改Vuex中的状态？Vuex中有哪些方法" class="headerlink" title="41. 怎么修改Vuex中的状态？Vuex中有哪些方法"></a>41. 怎么修改Vuex中的状态？Vuex中有哪些方法</h5><ul><li>通过<strong>this.$store.state.属性</strong> 的方法来访问状态</li><li>通过<strong>this.$store.commit(‘mutation中的方法’)</strong> 来修改状态</li></ul><h5 id="42-Vuex的缺点"><a href="#42-Vuex的缺点" class="headerlink" title="42. Vuex的缺点"></a>42. Vuex的缺点</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果您不打算开发大型单页应用，使用 <span class="title class_">Vuex</span> 可能是繁琐冗余的，并且state中的值会伴随着浏览器的刷新而初始化，无缓存。</span><br></pre></td></tr></table></figure><h5 id="43-什么是-Vue-nextTick-？"><a href="#43-什么是-Vue-nextTick-？" class="headerlink" title="43. 什么是 Vue.nextTick()？"></a>43. 什么是 Vue.nextTick()？</h5><p>1、$nextTick 是在下次DOM更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的DOM，意思是 等你dom加载完毕以后再去调用nextTick()里面的数据内容</p><h5 id="44-nextTick知道吗、实现的原理是什么？是宏任务还是微任务？"><a href="#44-nextTick知道吗、实现的原理是什么？是宏任务还是微任务？" class="headerlink" title="44. nextTick知道吗、实现的原理是什么？是宏任务还是微任务？"></a>44. nextTick知道吗、实现的原理是什么？是宏任务还是微任务？</h5><p>微任务</p><p>原理：</p><p>nextTick方法主要是使用了宏任务和微任务，定义了一个异步方法，多次调用nextTick会将方法存入队列中，通过这个异步方法清空队列。</p><p>作用： nextTick用于下次Dom更新循环结束之后执行延迟回调，在修改数据之后使用nextTick用于下次Dom更新循环结束之后执行延迟回调，在修改数据之后使用nextTick用于下次Dom更新循环结束之后执行延迟回调，在修改数据之后使用nextTick,则可以在回调中获取更新后的DOM。</p><h5 id="45-虚拟-dom-为什么会提高性能？"><a href="#45-虚拟-dom-为什么会提高性能？" class="headerlink" title="45. 虚拟 dom 为什么会提高性能？"></a>45. 虚拟 dom 为什么会提高性能？</h5><p>虚拟DOM其实就是一个JavaScript对象。通过这个JavaScript对象来描述真实DOM，真实DOM的操作，一般都会对某块元素的整体重新渲染，采用虚拟DOM的话，当数据变化的时候，只需要局部刷新变化的位置就好了 ,</p><p>虚拟<code>dom</code>相当于在<code>js</code>和真实<code>dom</code>中间加了一个缓存，利用<code>dom diff</code>算法避免了没有必要的<code>dom</code>操作，从而提高性能</p><p><strong>具体实现步骤如下</strong></p><ul><li>用 <code>JavaScript</code> 对象结构表示 <code>DOM</code> 树的结构；然后用这个树构建一个真正的 <code>DOM</code> 树，插到文档当中</li><li>当状态变更的时候，重新构造一棵新的对象树。然后用新的树和旧的树进行比较，记录两棵树差异</li><li>把2所记录的差异应用到步骤1所构建的真正的<code>DOM</code>树上，视图就更新</li></ul><h5 id="46-你做过哪些Vue的性能优化？"><a href="#46-你做过哪些Vue的性能优化？" class="headerlink" title="46. 你做过哪些Vue的性能优化？"></a>46. 你做过哪些Vue的性能优化？</h5><p>1、首屏加载优化</p><p>2、路由懒加载</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;      </span><br><span class="line">  <span class="attr">path</span>: <span class="string">&#x27;/&#x27;</span>,      </span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;home&#x27;</span>,      </span><br><span class="line">  <span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;./views/home/index.vue&#x27;</span>),      </span><br><span class="line">  <span class="attr">meta</span>: &#123; <span class="attr">isShowHead</span>: <span class="literal">true</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、开启服务器 Gzip</p><p>开启 Gzip 就是一种压缩技术，需要前端提供压缩包，然后在服务器开启压缩，文件在服务器压缩后传给浏览器，浏览器解压后进行再进行解析。首先安装 webpack 提供的<code>compression-webpack-plugin</code>进行压缩,然后在 vue.config.js：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">CompressionWebpackPlugin</span> = <span class="built_in">require</span>(<span class="string">&#x27;compression-webpack-plugin&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> productionGzipExtensions = [<span class="string">&#x27;js&#x27;</span>, <span class="string">&#x27;css&#x27;</span>]......<span class="attr">plugins</span>: [      </span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">CompressionWebpackPlugin</span>(</span><br><span class="line">    &#123;        </span><br><span class="line">      <span class="attr">algorithm</span>: <span class="string">&#x27;gzip&#x27;</span>,        </span><br><span class="line">      <span class="attr">test</span>:     <span class="keyword">new</span> <span class="title class_">RegExp</span>(<span class="string">&#x27;\\.(&#x27;</span> + productionGzipExtensions.<span class="title function_">join</span>(<span class="string">&#x27;|&#x27;</span>) +                 <span class="string">&#x27;)$&#x27;</span>),            </span><br><span class="line">      <span class="attr">threshold</span>: <span class="number">10240</span>,        </span><br><span class="line">      <span class="attr">minRatio</span>: <span class="number">0.8</span>      </span><br><span class="line">       &#125;</span><br><span class="line">)]....</span><br></pre></td></tr></table></figure><p>4、启动 CDN 加速</p><p>我们继续采用 cdn 的方式来引入一些第三方资源，就可以缓解我们服务器的压力，原理是将我们的压力分给其他服务器点。</p><p>5、代码层面优化</p><ul><li><p>computed 和 watch 区分使用场景</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">computed： 是计算属性，依赖其它属性值，并且 computed 的值有缓存，只有它依赖的属性值发生改变，下一次获取 computed 的值时才会重新计算 computed 的值。当我们需要进行数值计算，并且依赖于其它数据时，应该使用 computed，因为可以利用 computed 的缓存特性，避免每次获取值时，都要重新计算；</span><br><span class="line">  watch：类似于某些数据的监听回调 ，每当监听的数据变化时都会执行回调进行后续操作；当我们需要在数据变化时执行异步或开销较大的操作时，应该使用 watch，使用 watch 选项允许我们执行异步操作 ( 访问一个 API )，限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态。这些都是计算属性无法做到的。</span><br></pre></td></tr></table></figure></li><li><p>v-if 和 v-show 区分使用场景 v-if 适用于在运行时很少改变条件，不需要频繁切换条件的场景；v-show 则适用于需要非常频繁切换条件的场景。这里要说的优化点在于减少页面中 dom 总数，我比较倾向于使用 v-if，因为减少了 dom 数量。</p></li><li><p>v-for 遍历必须为 item 添加 key，且避免同时使用 v-if v-for 遍历必须为 item 添加 key，循环调用子组件时添加 key，key 可以唯一标识一个循环个体，可以使用例如 item.id 作为 key 避免同时使用 v-if，v-for 比 v-if 优先级高，如果每一次都需要遍历整个数组，将会影响速度。</p></li></ul><p>6、Webpack 对图片进行压缩</p><p>7、避免内存泄漏</p><p>8、减少 ES6 转为 ES5 的冗余代码</p><h5 id="47-Vue的常用修饰符"><a href="#47-Vue的常用修饰符" class="headerlink" title="47. Vue的常用修饰符"></a>47. Vue的常用修饰符</h5><p><strong>一、v-model修饰符</strong></p><p>1、.lazy：</p><p>输入框改变，这个数据就会改变，lazy这个修饰符会在光标离开input框才会更新数据：</p><p><img src="https://img2020.cnblogs.com/blog/1472868/202004/1472868-20200422095359145-2129658851.png" alt="img"></p><p>2、.trim：</p><p>输入框过滤首尾的空格：</p><p><img src="https://img2020.cnblogs.com/blog/1472868/202004/1472868-20200422095421707-831592670.png" alt="img"></p><p>3、.number：</p><p>先输入数字就会限制输入只能是数字，先字符串就相当于没有加number，注意，不是输入框不能输入字符串，是这个数据是数字：<img src="https://img2020.cnblogs.com/blog/1472868/202004/1472868-20200422095441517-895479507.png" alt="img"></p><p><strong>二、事件修饰符</strong></p><p>4、.stop：</p><p>阻止事件冒泡，相当于调用了event.stopPropagation()方法：</p><p><img src="https://img2020.cnblogs.com/blog/1472868/202004/1472868-20200422095722262-891576888.png" alt="img"></p><p>5、.prevent：</p><p>阻止默认行为，相当于调用了event.preventDefault()方法，比如表单的提交、a标签的跳转就是默认事件：</p><p><img src="https://img2020.cnblogs.com/blog/1472868/202004/1472868-20200422095520346-1148774494.png" alt="img"></p><p>6、.self：</p><p>只有元素本身触发时才触发方法，就是只有点击元素本身才会触发。比如一个div里面有个按钮，div和按钮都有事件，我们点击按钮，div绑定的方法也会触发，如果div的click加上self，只有点击到div的时候才会触发，变相的算是阻止冒泡：</p><p><img src="https://img2020.cnblogs.com/blog/1472868/202004/1472868-20200422095746426-1272980881.png" alt="img"></p><p>7、.once：</p><p>事件只能用一次，无论点击几次，执行一次之后都不会再执行</p><p><img src="https://img2020.cnblogs.com/blog/1472868/202004/1472868-20200422095802227-1462269056.png" alt="img"></p><p>8、.capture：</p><p>事件的完整机制是捕获-目标-冒泡，事件触发是目标往外冒泡</p><p>9、.sync</p><p>对prop进行双向绑定</p><p>10、.keyCode：</p><p>监听按键的指令，具体可以查看vue的键码对应表</p><h5 id="48-Vue-中-template-的编译过程"><a href="#48-Vue-中-template-的编译过程" class="headerlink" title="48. Vue 中 template 的编译过程"></a>48. Vue 中 template 的编译过程</h5><p>vue template模板编译的过程经过parse()生成ast(抽象语法树),optimize对静态节点优化，generate()生成render字符串 之后调用new Watcher()函数，用来监听数据的变化，render 函数就是数据监听的回调所调用的，其结果便是重新生成 vnode。 当这个 render 函数字符串在第一次 mount、或者绑定的数据更新的时候，都会被调用，生成 Vnode。 如果是数据的更新，那么 Vnode 会与数据改变之前的 Vnode 做 diff，对内容做改动之后，就会更新到 我们真正的 DOM</p><h5 id="49-谈谈你对Vue3-0有什么了解？"><a href="#49-谈谈你对Vue3-0有什么了解？" class="headerlink" title="49. 谈谈你对Vue3.0有什么了解？"></a>49. 谈谈你对Vue3.0有什么了解？</h5><h6 id="六大亮点"><a href="#六大亮点" class="headerlink" title="六大亮点"></a>六大亮点</h6><ol><li>性能比vue2.x快1.2~2倍</li><li>支持tree-shaking，按需编译，体积比vue2.x更小</li><li>支持组合API</li><li>更好的支持TS</li><li>更先进的组件</li></ol><h6 id="性能比vue2-x快1-2-2倍如何实现的呢"><a href="#性能比vue2-x快1-2-2倍如何实现的呢" class="headerlink" title="性能比vue2.x快1.2~2倍如何实现的呢"></a>性能比vue2.x快1.2~2倍如何实现的呢</h6><p>1.diff算法更快</p><p>vue2.0是需要全局去比较每个节点的，若发现有节点发生变化后，就去更新该节点</p><p>vue3.0是在创建虚拟dom中，会根据DOM的的内容会不会发生内容变化，添加静态标记， 谁有flag！比较谁。</p><p>2、静态提升</p><p>vue2中无论元素是否参与更新，每次都会重新创建，然后再渲染 vue3中对于不参与更新的元素，会做静态提升，只被创建一次，在渲染时直接复用即可</p><p>3、事件侦听缓存</p><p>默认情况下，onclick为动态绑定，所以每次都会追踪它的变化，但是因为是同一函数，没有必要追踪变化，直接缓存复用即可</p><p>在之前会添加静态标记8 会把点击事件当做动态属性 会进行diff算法比较， 但是在事件监听缓存之后就没有静态标记了，就会进行缓存复用</p><h6 id="为什么vue3-0体积比vue2-x小"><a href="#为什么vue3-0体积比vue2-x小" class="headerlink" title="为什么vue3.0体积比vue2.x小"></a>为什么vue3.0体积比vue2.x小</h6><p>在vue3.0中创建vue项目 除了vue-cli，webpack外还有 一种创建方法是Vite Vite是作者开发的一款有意取代webpack的工具，其实现原理是利用ES6的import会发送请求去加载文件的特性，拦截这些请求，做一些预编译，省去webpack冗长的打包时间</p><h5 id="50-vue3-0组合API"><a href="#50-vue3-0组合API" class="headerlink" title="50. vue3.0组合API"></a>50. vue3.0组合API</h5><p>说一说vue3.0的组合API跟之前vue2.0在完成业务逻辑上的区别：</p><p>在vue2.0中： 主要是往data 和method里面添加内容，一个业务逻辑需要什么data和method就往里面添加，而组合API就是 有一个自己的方法，里面有自己专注的data 和method。</p><p><img src="%E7%AC%94%E8%AE%B0.assets/image-20230217100400438.png" alt="image-20230217100400438" style="zoom:67%;" /></p><p><img src="%E7%AC%94%E8%AE%B0.assets/image-20230217100411590.png" alt="image-20230217100411590" style="zoom:67%;" /></p><p><img src="%E7%AC%94%E8%AE%B0.assets/image-20230217100430825.png" alt="image-20230217100430825" style="zoom:67%;" /></p><p>再说一下组合API的本质是什么： 首先composition API（组合API） 和 Option API（vue2.0中的data和method）可以共用 composition API（组合API）本质就是把内容添加到Option API中进行使用</p><h5 id="51-ref和reactive的简单理解"><a href="#51-ref和reactive的简单理解" class="headerlink" title="51. ref和reactive的简单理解"></a>51. ref和reactive的简单理解</h5><p>1.ref和reactive都是vue3的监听数据的方法，本质是proxy 2.ref 基本类型复杂类型都可以监听(我们一般用ref监听基本类型)，reactive只能监听对象（arr，json） 3.ref底层还是reactive，ref是对reactive的二次包装， ref定义的数据访问的时候要多一个.value</p><h5 id="52-Vuex和redux有什么区别？他们的共同思想。"><a href="#52-Vuex和redux有什么区别？他们的共同思想。" class="headerlink" title="52. Vuex和redux有什么区别？他们的共同思想。"></a>52. Vuex和redux有什么区别？他们的共同思想。</h5><h6 id="Redux和Vuex区别"><a href="#Redux和Vuex区别" class="headerlink" title="Redux和Vuex区别"></a>Redux和Vuex区别</h6><ul><li>Vuex改进了Redux中的Action和Reducer函数，以mutations变化函数取代Reducer，无需switch，只需在对应的mutation函数里改变state值就可以</li><li>Vuex由于Vue自动重新渲染的特性，无需订阅重新渲染函数，只要生成新的state就可以</li><li>Vuex数据流的顺序是:View调用store.commit提交对应的请求到Store中对应的mutation函数 — store改变(vue检测到数据变化自动渲染)</li></ul><h6 id="共同思想"><a href="#共同思想" class="headerlink" title="共同思想"></a>共同思想</h6><ul><li>单一的数据源</li><li>变化可以预测</li><li><code>本质上:</code>Redux和Vuex都是对MVVM思想的服务，将数据从视图中抽离的一种方案</li><li><code>形式上:</code>Vuex借鉴了Redux，将store作为全局的数据中心，进行数据管理</li></ul><h5 id="53-简单说一下-微信小程序-与-Vue-的区别"><a href="#53-简单说一下-微信小程序-与-Vue-的区别" class="headerlink" title="53. 简单说一下 微信小程序 与 Vue 的区别"></a>53. 简单说一下 微信小程序 与 Vue 的区别</h5><p>1、生命周期：</p><p><code>小程序</code>的钩子函数要简单得多 。 <code>vue</code>的钩子函数在跳转新页面时，钩子函数都会触发，但是<code>小程序</code>的钩子函数，页面不同的跳转方式，触发的钩子并不一样。</p><p>在页面加载请求数据时，两者钩子的使用有些类似，<code>vue</code>一般会在<code>created</code>或者<code>mounted</code>中请求数据，而在<code>小程序</code>，会在<code>onLoad</code>或者<code>onShow</code>中请求数据。</p><p>2、数据绑定：</p><p>vue动态绑定一个变量的值为元素的某个属性的时候，会在变量前面加上冒号：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img :src=<span class="string">&quot;imgSrc&quot;</span>/&gt;</span><br></pre></td></tr></table></figure><p>小程序 绑定某个变量的值为元素属性时，会用两个大括号括起来，如果不加括号，为被认为是字符串</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;image src=<span class="string">&quot;&#123;&#123;imgSrc&#125;&#125;&quot;</span>&gt;&lt;/image&gt;</span><br></pre></td></tr></table></figure><p>3、列表循环</p><p>4、显示与隐藏元素</p><p><code>vue</code>中，使用<code>v-if</code> 和<code>v-show</code>控制元素的显示和隐藏</p><p><code>小程序</code>中，使用<code>wx-if</code>和<code>hidden</code>控制元素的显示和隐藏</p><p>5、事件处理</p><p><code>vue</code>：使用<code>v-on:event</code>绑定事件，或者使用<code>@event</code>绑定事件</p><p><code>小程序</code>中，全用<code>bindtap(bind+event)</code>，或者<code>catchtap(catch+event)</code>绑定事件</p><p>6、数据的双向绑定</p><p>在<code>vue</code>中,只需要再<code>表单</code>元素上加上<code>v-model</code>,然后再绑定<code>data</code>中对应的一个值，当表单元素内容发生变化时，<code>data</code>中对应的值也会相应改变 。</p><p>当表单内容发生变化时，会触发表单元素上绑定的方法，然后在该方法中，通过<code>this.setData(&#123;key:value&#125;)</code>来将表单上的值赋值给<code>data</code>中的对应值 。</p><p>7、绑定事件传参</p><p>在<code>vue</code>中，绑定事件传参挺简单，只需要在触发事件的方法中，把需要传递的数据作为形参传入就可以了</p><p>在<code>小程序</code>中，不能直接在绑定事件的方法中传入参数，需要将参数作为属性值，绑定到元素上的<code>data-</code>属性上，然后在方法中，通过<code>e.currentTarget.dataset.*</code>的方式获取</p><p>8、父子组件通信</p><p>父组件向子组件传递数据，只需要在子组件通过<code>v-bind</code>传入一个值，在子组件中，通过<code>props</code>接收，即可完成数据的传递</p><p>父组件向子组件通信和<code>vue</code>类似，但是<code>小程序</code>没有通过<code>v-bind</code>，而是直接将值赋值给一个变量 在子组件<code>properties</code>中，接收传递的值</p><h5 id="54-如果你是leader，做管理系统项目-Vue和React-怎么选择？"><a href="#54-如果你是leader，做管理系统项目-Vue和React-怎么选择？" class="headerlink" title="54. 如果你是leader，做管理系统项目 Vue和React 怎么选择？"></a>54. 如果你是leader，做管理系统项目 Vue和React 怎么选择？</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">评估项目成员的水平，如果成员js基础较好、编码能力较强则选择<span class="title class_">React</span>，否则<span class="title class_">Vue</span>。</span><br><span class="line">评估系统的大小，如果想构建生态系统，则选择<span class="title class_">React</span>，如果要求而快，简单和“能用就行<span class="string">&quot;,则选择Vue。</span></span><br><span class="line"><span class="string">评估系统运行环境，如果你想要一个同时适用于Web端和原生APP的框架，请选择React(RN)。</span></span><br></pre></td></tr></table></figure><h4 id="八-React高频面试题"><a href="#八-React高频面试题" class="headerlink" title="八. React高频面试题"></a>八. React高频面试题</h4><h5 id="1-类组件和函数组件的区别"><a href="#1-类组件和函数组件的区别" class="headerlink" title="1. 类组件和函数组件的区别"></a>1. 类组件和函数组件的区别</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*            </span></span><br><span class="line"><span class="comment">            （1）语法上：函数组件是一个函数，返回一个jsx元素，而类组件是用es6语法糖class定义，继承component这个类</span></span><br><span class="line"><span class="comment">            （2）类组件中可以通过state进行状态管理，而在函数组件中不能使用setState()，在react16.8以后，函数组件可以通过hooks中的useState来模拟类组件中的状态管理；</span></span><br><span class="line"><span class="comment">            （3）类组件中有一系列的生命周期钩子函数，在函数组件中也需要借助hooks来使用生命周期函数；</span></span><br><span class="line"><span class="comment">            （4）类组件能够捕获最新的值（永远保持一致），这是因为当实例的props属性发生修改时，class组件能够直接通过this捕获到组件最新的props；而函数式组件是捕获渲染所使用的值，已经因为javascript闭包的特性，之前的props参数保存在内存之中，无法从外部进行修改。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h5 id="2-React-事件绑定原理"><a href="#2-React-事件绑定原理" class="headerlink" title="2. React 事件绑定原理"></a>2. React 事件绑定原理</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">        一、react并没有使用原生的浏览器事件，而是在基于Virtual DOM的基础上实现了合成事件，采用小驼峰命名法，默认的事件传播方式是冒泡，如果想改为捕获的话，直接在事件名后面加上Capture即可；事件对象event也不是原生事件对象，而是合成对象，但通过nativeEvent属性可以访问原生事件对象；</span></span><br><span class="line"><span class="comment">        二、react合成事件主要分为以下三个过程：</span></span><br><span class="line"><span class="comment">        1、事件注册</span></span><br><span class="line"><span class="comment">        在该阶段主要做了两件事：document上注册、存储事件回调。所有事件都会注册到document上，拥有统一的回调函数dispatchEvent来执行事件分发，类似于document.addEventListener(&quot;click&quot;,dispatchEvent)。</span></span><br><span class="line"><span class="comment">      register:</span></span><br><span class="line"><span class="comment">          addEventListener-click</span></span><br><span class="line"><span class="comment">          addEventListener-change</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      listenerBank:</span></span><br><span class="line"><span class="comment">           &#123;</span></span><br><span class="line"><span class="comment">                click: &#123;key1: fn1, key2: fn2&#125;,</span></span><br><span class="line"><span class="comment">                change: &#123;key1: fn3, key3: fn4&#125;</span></span><br><span class="line"><span class="comment">           &#125;</span></span><br><span class="line"><span class="comment">    2、事件合成</span></span><br><span class="line"><span class="comment">        事件触发后，会执行一下过程：</span></span><br><span class="line"><span class="comment">        （1）进入统一的事件分发函数dispatchEvent；</span></span><br><span class="line"><span class="comment">    （2）找到触发事件的 ReactDOMComponent；</span></span><br><span class="line"><span class="comment">    （3）开始事件的合成；</span></span><br><span class="line"><span class="comment">            —— 根据当前事件类型生成指定的合成对象</span></span><br><span class="line"><span class="comment">                —— 封装原生事件和冒泡机制</span></span><br><span class="line"><span class="comment">                —— 查找当前元素以及他所有父级</span></span><br><span class="line"><span class="comment">                —— 在listenerBank根据key值查找事件回调并合成到 event(合成事件结束)</span></span><br><span class="line"><span class="comment">   3、批处理</span></span><br><span class="line"><span class="comment">           批量处理合成事件内的回调函数</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h5 id="3-React中的-setState-缺点是什么呢"><a href="#3-React中的-setState-缺点是什么呢" class="headerlink" title="3. React中的 setState 缺点是什么呢"></a>3. React中的 setState 缺点是什么呢</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">        setState执行的时候可以简单的认为，隶属于原生js执行的空间，那么就是属于同步，被react处理过的空间属于异步，这其实也是一种性能的优化，如果多次使用setState修改值，那么在异步中会先进行合并，再进行渲染，降低了操作dom的次数，具体如下：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        （1）setState 在合成事件和钩子函数中是“异步”的，在原生事件和 `setTimeout` 中都是同步的。</span></span><br><span class="line"><span class="comment">        （2）setState的“异步”并不是说内部由异步代码实现，其实本身执行的过程和代码都是同步的，只是合成事件和钩子函数的调用顺序在更新之前，导致在合成事件和钩子函数中没法立马拿到更新后的值，形式了所谓的“异步”，当然可以通过第二个参数 setState(partialState, callback) 中的callback拿到更新后的结果。</span></span><br><span class="line"><span class="comment">        （3）setState 的批量更新优化也是建立在“异步”（合成事件、钩子函数）之上的，在原生事件和setTimeout 中不会批量更新，在“异步”中如果对同一个值进行多次 setState， setState 的批量更新策略会对其进行覆盖，取最后一次的执行，如果是同时 setState 多个不同的值，在更新时会对其进行合并批量更新。</span></span><br><span class="line"><span class="comment">        （4）正是由于setState存在异步的机制，如果setState修改值的时候依赖于state本身的值，有时候并不可靠，这时候我们需要传入一个回调函数作为其入参，这个回调函数的第一个参数为更新前的state值。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h5 id="4-React-组件中-props-和-state-有什么区别？"><a href="#4-React-组件中-props-和-state-有什么区别？" class="headerlink" title="4. React 组件中 props 和 state 有什么区别？"></a>4. React 组件中 props 和 state 有什么区别？</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">        1、props是从外部传入组件的参数，一般用于父组件向子组件通信，在组件之间通信使用；state一般用于组件内部的状态维护，更新组建内部的数据，状态，更新子组件的props等</span></span><br><span class="line"><span class="comment">        2、props不可以在组件内部修改，只能通过父组件进行修改；state在组件内部通过setState修改；</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h5 id="5-虚拟DOM的优劣如何？实现原理？"><a href="#5-虚拟DOM的优劣如何？实现原理？" class="headerlink" title="5. 虚拟DOM的优劣如何？实现原理？"></a>5. 虚拟DOM的优劣如何？实现原理？</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">        虚拟dom是用js模拟一颗dom树,放在浏览器内存中，相当于在js和真实dom中加了一个缓存，利用dom diff算法避免了没有必要的dom操作，从而提高性能。</span></span><br><span class="line"><span class="comment">        优点：</span></span><br><span class="line"><span class="comment">        （1）虚拟DOM具有批处理和高效的Diff算法,最终表现在DOM上的修改只是变更的部分，可以保证非常高效的渲染,优化性能；</span></span><br><span class="line"><span class="comment">        （2）虚拟DOM不会立马进行排版与重绘操作，对虚拟DOM进行频繁修改，最后一次性比较并修改真实DOM中需要改的部分；</span></span><br><span class="line"><span class="comment">        （3）虚拟 DOM 有效降低大面积真实 DOM 的重绘与排版，因为最终与真实 DOM 比较差异，可以只渲染局部；</span></span><br><span class="line"><span class="comment">        缺点：</span></span><br><span class="line"><span class="comment">        （1）首次渲染大量DOM时，由于多了一层虚拟DOM的计算，会比innerHTML插入慢；</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        虚拟DOM的组成——ReactElementelement对象结构：</span></span><br><span class="line"><span class="comment">        （1）type：元素的类型，可以是原生html类型（字符串），或者自定义组件（函数或class）</span></span><br><span class="line"><span class="comment">        （2）key：组件的唯一标识，用于Diff算法，下面会详细介绍</span></span><br><span class="line"><span class="comment">        （3）ref：用于访问原生dom节点</span></span><br><span class="line"><span class="comment">        （4）props：传入组件的props，chidren是props中的一个属性，它存储了当前组件的孩子节点，可以是数组（多个孩子节点）或对象（只有一个孩子节点）</span></span><br><span class="line"><span class="comment">        （5）owner：当前正在构建的Component所属的Component</span></span><br><span class="line"><span class="comment">        （6）self：（非生产环境）指定当前位于哪个组件实例</span></span><br><span class="line"><span class="comment">        （7）_source：（非生产环境）指定调试代码来自的文件(fileName)和代码行数(lineNumber)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h5 id="6-diff-和-Key-之间的联系"><a href="#6-diff-和-Key-之间的联系" class="headerlink" title="6. diff 和 Key 之间的联系"></a>6. diff 和 Key 之间的联系</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">            diff算法即差异查找算法，对于DOM结构即为tree的差异查找算法，只有在React更新阶段才会有Diff算法的运用；react的diff运算为了降低时间复杂度，是按层比较新旧两个虚拟dom树的。diff运算的主要流程见下：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            1、tree diff : 新旧两棵dom树，逐层对比的过程就是 tree diff, 当整棵DOM树逐层对比完毕，则所有需要被按需更新的元素，必然能够被找到。</span></span><br><span class="line"><span class="comment">        2、component diff ： 在进行tree diff的时候，每一层中，都有自己的组件，组件级别的对比，叫做 component diff。如果对比前后，组件的类型相同，则暂时认为此组件不需要更新；如果对比前后，组件的类型不同，则需要移除旧组件，创建新组件，并渲染到页面上。</span></span><br><span class="line"><span class="comment">        React只会匹配类型相同的组件，也就是说如果&lt;A&gt;被&lt;B&gt;替换，那么React将直接删除A组件然后创建一个B组件；如果某组件A转移到同层B组件上，那么这个A组件会先被销毁，然后在B组件下重新生成，以A为根节点的树整个都被重新创建，这会比较耗费性能，但实际上我们很少跨层移动dom节点，一般都是同层横向移动；</span></span><br><span class="line"><span class="comment">        3、element diff ：在进行组件对比的时候，如果两个组件类型相同，则需要进行元素级别的对比，这叫做element diff。</span></span><br><span class="line"><span class="comment">        对于列表渲染，react会在创建时要求为每一项输入一个独一无二的key，这样就能进行高效的diff运算了。比如我们要在b和c节点中间插入一个节点f，jquery会将f这个节点后面的每一个节点都进行更新，比如c更新成f，d更新成c，e更新成d，这样操作的话就会特别多，而加了key的react咋不会频繁操作dom，而是优先采用移动的方式，找到正确的位置去插入新节点；所以我们不能省略key值，因为在对比两个新旧的子元素是，是通过key值来精确地判断两个节点是否为同一个，如果没有key的话则是见到谁就更新谁，非常耗费性能。</span></span><br><span class="line"><span class="comment">            当我们通过this.setState()改变数据的时候，React会将其标记为脏节点，在事件循环的最后才会重新渲染所有的脏节点以及脏节点的子树；另外我们可以使用shouldComponentUpdate这个生命周期来选择性的渲染子树，可以基于组件之前的状态或者下一个状态来决定它是否需要重新渲染，这样的话可以组织重新渲染大的子树。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h5 id="7-React组件通信如何实现"><a href="#7-React组件通信如何实现" class="headerlink" title="7. React组件通信如何实现"></a>7. React组件通信如何实现</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">        react本身:</span></span><br><span class="line"><span class="comment">                (1)props——父组件向子组件通过props传参</span></span><br><span class="line"><span class="comment">                (2)实例方法——在父组件中可以用 refs 引用子组件，之后就可以调用子组件的实例方法了</span></span><br><span class="line"><span class="comment">                (3)回调函数——用于子组件向父组件通信，子组件调用props传递过来的方法</span></span><br><span class="line"><span class="comment">                (4)状态提升——两个子组件可以通过父组件定义的参数进行传参</span></span><br><span class="line"><span class="comment">                (5)Context上下文——一般用作全局主题</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            状态管理:</span></span><br><span class="line"><span class="comment">                (1) mobx/redux/dva——通过在view中触发action，改变state，进而改变其他组件的view</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h5 id="8-React中refs的作用是什么？"><a href="#8-React中refs的作用是什么？" class="headerlink" title="8. React中refs的作用是什么？"></a>8. React中refs的作用是什么？</h5><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ref是React提供的用来操纵React组件实例或者DOM元素的接口。主要用来做文本框的聚焦、触发强制动画等；</span></span><br><span class="line"><span class="comment">// 类组件</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">      <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">        <span class="variable language_">super</span>(props)</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">myRef</span> = <span class="title class_">React</span>.<span class="title function_">createRef</span>()</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">                  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">input</span> <span class="attr">ref</span>=<span class="string">&#123;</span> <span class="attr">this.myRef</span> &#125; /&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span> = <span class="string">&#123;()</span>=&gt;</span>this.handle()&#125;&gt;聚焦<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">               <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="title function_">handle</span>(<span class="params"></span>) &#123;</span><br><span class="line">          <span class="comment">// 通过current属性访问到当前元素</span></span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">myRef</span>.<span class="property">current</span>.<span class="title function_">focus</span>()</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 函数组件</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> inputEl = <span class="title function_">useRef</span>(<span class="literal">null</span>)</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">handle</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">        inputEl.<span class="property">current</span>.<span class="title function_">focus</span>()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> </span><br><span class="line">          <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">ref</span>=<span class="string">&#123;</span> <span class="attr">inputEl</span> &#125;/&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span> = <span class="string">&#123;handle&#125;</span>&gt;</span>聚焦<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="9-请列举react生命周期函数。"><a href="#9-请列举react生命周期函数。" class="headerlink" title="9. 请列举react生命周期函数。"></a>9. 请列举react生命周期函数。</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">第一阶段：装载阶段3</span></span><br><span class="line"><span class="comment">    constructor()</span></span><br><span class="line"><span class="comment">    render()</span></span><br><span class="line"><span class="comment">    componentDidMount()</span></span><br><span class="line"><span class="comment">第二阶段：更新阶段2</span></span><br><span class="line"><span class="comment">    [shouldComponentUpdate()]</span></span><br><span class="line"><span class="comment">    render()</span></span><br><span class="line"><span class="comment">    componentDidUpdate()</span></span><br><span class="line"><span class="comment">第三阶段：卸载阶段1</span></span><br><span class="line"><span class="comment">    componentWillUnmount()</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">constructor生命周期：</span></span><br><span class="line"><span class="comment">    (1)当react组件实例化时，是第一个运行的生命周期；</span></span><br><span class="line"><span class="comment">    (2)在这个生命周期中，不能使用this.setState()；</span></span><br><span class="line"><span class="comment">    (3)在这个生命周期中，不能使用副作用(调接口、dom操作、定时器、长连接等)；</span></span><br><span class="line"><span class="comment">    (4)不能把props和state交叉赋值；</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">componentDidMount生命周期：</span></span><br><span class="line"><span class="comment">    (1)相当于是vue中的mounted；</span></span><br><span class="line"><span class="comment">    (2)它表示DOM结构在浏览器中渲染已完成；</span></span><br><span class="line"><span class="comment">    (3)在这里可以使用任何的副作用；</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">shouldComponentUpdate(nextProps,nextState)生命周期：</span></span><br><span class="line"><span class="comment">    (1)相当于一个开关，如果返回true则更新机制正常执行，如果为false则更新机制停止；</span></span><br><span class="line"><span class="comment">    (2)在vue中是没有的；</span></span><br><span class="line"><span class="comment">    (3)存在的意义：可以用于性能优化，但是不常用，最新的解决方案是使用PureComponent；</span></span><br><span class="line"><span class="comment">    (4)理论上，这个生命周期的作用，用于精细地控制声明式变量的更新问题，如果变化的声明式变量参与了视图渲染则返回true，如果被变化的声明式变量没有直接或间接参与视图渲染，则返回false；</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">componentDidUpdate生命周期：</span></span><br><span class="line"><span class="comment">    (1)相当于vue中的updated()；</span></span><br><span class="line"><span class="comment">    (2)它表示DOM结构渲染更新已完成，只发生在更新阶段；</span></span><br><span class="line"><span class="comment">    (3)在这里，可以执行大多数的副作用，但是不建议；</span></span><br><span class="line"><span class="comment">    (4)在这里，可以使用this.setState()，但是要有终止条件判断。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">componentWillUnmount生命周期：</span></span><br><span class="line"><span class="comment">    (1)一般在这里清除定时器、长连接等其他占用内存的构造器；</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">render生命周期：</span></span><br><span class="line"><span class="comment">    (1)render是类组件中唯一必须有的生命周期，同时必须有return（return 返回的jsx默认只能是单一根节点，但是在fragment的语法支持下，可以返回多个兄弟节点）；</span></span><br><span class="line"><span class="comment">    (2)Fragment碎片写法: &lt;React.Fragment&gt;&lt;/React.Fragment&gt; 简写成&lt;&gt;&lt;/&gt;；</span></span><br><span class="line"><span class="comment">    (3)return之前，可以做任意的业务逻辑，但是不能使用this.setState()，会造成死循环；</span></span><br><span class="line"><span class="comment">    (4)render()在装载阶段和更新阶段都会运行；</span></span><br><span class="line"><span class="comment">    (5)当render方法返回null的时候，不会影响生命周期函数的正常执行。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h5 id="10-A-组件嵌套-B-组件，生命周期执行顺序"><a href="#10-A-组件嵌套-B-组件，生命周期执行顺序" class="headerlink" title="10. A 组件嵌套 B 组件，生命周期执行顺序"></a>10. A 组件嵌套 B 组件，生命周期执行顺序</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    父组件创建阶段的生命周期钩子函数 constructor</span></span><br><span class="line"><span class="comment">    父组件创建阶段的生命周期钩子函数 render</span></span><br><span class="line"><span class="comment">    子组件创建阶段的生命周期钩子函数 constructor</span></span><br><span class="line"><span class="comment">    子组件创建阶段的生命周期钩子函数 render</span></span><br><span class="line"><span class="comment">    子组件创建阶段的生命周期钩子函数 componentDidMount</span></span><br><span class="line"><span class="comment">    父组件创建阶段的生命周期钩子函数 componentDidMount</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h5 id="11-新出来两个钩子函数？和砍掉的will系列有啥区别？"><a href="#11-新出来两个钩子函数？和砍掉的will系列有啥区别？" class="headerlink" title="11. 新出来两个钩子函数？和砍掉的will系列有啥区别？"></a>11. 新出来两个钩子函数？和砍掉的will系列有啥区别？</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// react16 中废弃了三个钩子</span></span><br><span class="line">componentWillMount                     <span class="comment">// 组件将要挂载的钩子</span></span><br><span class="line">componentWillReceiveProps        <span class="comment">// 组件将要接收一个新的参数时的钩子</span></span><br><span class="line">componentWillUpdate                    <span class="comment">// 组件将要更新的钩子</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 新增了方法</span></span><br><span class="line">getDerivedStateFromProps        <span class="comment">// 静态方法</span></span><br><span class="line">getSnapshotBeforeUpdate</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">        在16.8版本以后，react将diff运算改进为Fiber，这样的话当我们调用setState方法进行更新的时候，在reconciler 层中js运算会按照节点为单位拆分成一个个小的工作单元，在render前可能会中断或恢复，就有可能导致在render前这些生命周期在进行一次更新时存在多次执行的情况，此时如果我们在里面使用ref操作dom的话，就会造成页面频繁重绘，影响性能。</span></span><br><span class="line"><span class="comment">        所以废弃了这几个will系列的勾子，增加了 getDerivedStateFromProps这个静态方法，这样的话我们就不能在其中使用this.refs以及this上的方法了；getSnapshotBeforeUpdate 这个方法已经到了commit阶段，只会执行一次，给想读取 dom 的用户一些空间。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h5 id="12-React-hooks-用过吗，为什么要用？"><a href="#12-React-hooks-用过吗，为什么要用？" class="headerlink" title="12. React hooks 用过吗，为什么要用？"></a>12. React hooks 用过吗，为什么要用？</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">        Hooks 是React在16.8版本中出的一个新功能，本质是一种函数，可以实现组件逻辑复用，让我们在函数式组件中使用类组件中的状态、生命周期等功能，hooks的名字都是以use开头。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        react：</span></span><br><span class="line"><span class="comment">        1、useState——创建状态</span></span><br><span class="line"><span class="comment">                接收一个参数作为初始值；返回一个数组，第一个值为状态，第二个值为改变状态的函数</span></span><br><span class="line"><span class="comment">        2、useEffect——副作用（数据获取、dom操作影响页面——在渲染结束之后执行</span></span><br><span class="line"><span class="comment">                (1)第一个参数为函数，第二个参数为依赖列表，只有依赖更新时才会执行函数；返回一个函数，当页面刷新的时候先执行返回函数再执行参数函数</span></span><br><span class="line"><span class="comment">                (2)如果不接受第二个参数，那么在第一次渲染完成之后和每次更新渲染页面的时候，都会调用useEffect的回调函数</span></span><br><span class="line"><span class="comment">    3、useRef</span></span><br><span class="line"><span class="comment">        返回一个可变的ref对象，此索引在整个生命周期中保持不变。可以用来获取元素或组件的实例，用来做输入框的聚焦或者动画的触发。    </span></span><br><span class="line"><span class="comment">    4、useMemo——优化函数组件中的功能函数——在渲染期间执行</span></span><br><span class="line"><span class="comment">       （1）接收一个函数作为参数，同样接收第二个参数作为依赖列表，返回值可以是任何，函数、对象等都可以</span></span><br><span class="line"><span class="comment">       （2）这种优化有助于避免在每次渲染时都进行高开销的计算，仅会在某个依赖项改变时才重新计算            </span></span><br><span class="line"><span class="comment">        5、useContext——获取上下文注入的值    </span></span><br><span class="line"><span class="comment">                (1)接受一个context 对象，并返回该对象&lt;MyContext.Provider&gt; 元素的 value值；</span></span><br><span class="line"><span class="comment">                        const value = useContext(MyContext)；        </span></span><br><span class="line"><span class="comment">        6、useLayoutEffect——有DOM操作的副作用——</span></span><br><span class="line"><span class="comment">        简单来说就是调用时机不同，`useLayoutEffect`和原来`componentDidMount`&amp;`componentDidUpdate`一致，在react完成DOM更新后马上**同步**调用的代码，会阻塞页面渲染。而`useEffect`是会在整个页面渲染完才会调用的代码。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">官方建议优先使用`useEffect`</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&gt; However, **we recommend starting with useEffect first** and only trying useLayoutEffect if that causes a problem.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">在实际使用时如果想避免**页面抖动**（在`useEffect`里修改DOM很有可能出现）的话，可以把需要操作DOM的代码放在`useLayoutEffect`里。在这里做点dom操作，这些dom修改会和 react 做出的更改一起被一次性渲染到屏幕上，只有一次回流、重绘的代价。</span></span><br><span class="line"><span class="comment">        7、useCallback——与useMemo类似</span></span><br><span class="line"><span class="comment">                useMemo与useCallback相同，接收一个函数作为参数，也同样接收第二个参数作为依赖列表；useCallback是对传过来的回调函数优化，返回的是一个函数</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">react-router:</span></span><br><span class="line"><span class="comment">        被route包裹的组件，可以直接使用props进行路由相关操作，但是没有被route包裹的组件只能用withRouter高阶组件修饰或者使用hooks进行操作</span></span><br><span class="line"><span class="comment">        1、useHistory——跳转路由</span></span><br><span class="line"><span class="comment">        2、useLocation——得到url对象</span></span><br><span class="line"><span class="comment">        3、useParams——得到url上的参数</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">react-redux:</span></span><br><span class="line"><span class="comment">        1、useSelector——共享状态——从redux的store中提取数据</span></span><br><span class="line"><span class="comment">        2、useDispatch——共享状态——返回edux的store中对dispatch的引用    </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> getCinemaList = <span class="title function_">useMemo</span>(<span class="function">() =&gt;</span> cinemaList.<span class="title function_">filter</span>(<span class="function"><span class="params">item</span>=&gt;</span>item.<span class="property">name</span>.<span class="title function_">toUpperCase</span>().<span class="title function_">includes</span>(mytext.<span class="title function_">toUpperCase</span>()) || </span><br><span class="line">    item.<span class="property">address</span>.<span class="title function_">toUpperCase</span>().<span class="title function_">includes</span>(mytext.<span class="title function_">toUpperCase</span>())</span><br><span class="line">    ), [cinemaList,mytext])</span><br></pre></td></tr></table></figure><h5 id="13-hooks-的使用有什么注意事项"><a href="#13-hooks-的使用有什么注意事项" class="headerlink" title="13. hooks 的使用有什么注意事项"></a>13. hooks 的使用有什么注意事项</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">        （1）只能在React函数式组件或自定义Hook中使用Hook。</span></span><br><span class="line"><span class="comment">        （2）不要在循环，条件或嵌套函数中调用Hook，必须始终在React函数的顶层使用Hook。这是因为React需要利用调用顺序来正确更新相应的状态，以及调用相应的钩子函数。一旦在循环或条件分支语句中调用Hook，就容易导致调用顺序的不一致性，从而产生难以预料到的后果。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h5 id="14-Hooks-会取代-render-props-和高阶组件吗？"><a href="#14-Hooks-会取代-render-props-和高阶组件吗？" class="headerlink" title="14. Hooks 会取代 render props 和高阶组件吗？"></a>14. Hooks 会取代 <code>render props</code> 和高阶组件吗？</h5><p><a href="https://zh-hans.reactjs.org/docs/hooks-faq.html#do-hooks-replace-render-props-and-higher-order-components">官方简答</a></p><blockquote><ul><li>可以取代，但没必要</li><li>在Hook的渐进策略中也有提到，没有计划从React中移除class，在新的代码中同时使用Hook和class，所以这些方案目前还是可以有勇武之地</li></ul></blockquote><p><strong>what</strong></p><blockquote><ul><li>为什么要把这3种技术拿过来对比？</li></ul><blockquote><p>都在处理同一个问题，<strong><em>逻辑复用\</em></strong></p></blockquote><ul><li><a href="https://zh-hans.reactjs.org/docs/higher-order-components.html">高阶组件HOC</a>—-不是 <em>React API</em> 的一部分，是基于 <em>React</em> 的<strong>组合特性</strong>形成的设计模式。</li></ul><blockquote><p>高阶组件是参数为组件，返回值为新组件的<strong>函数</strong>（将组件转换为另一个组件，纯函数，无副作用）</p></blockquote><ul><li><a href="https://zh-hans.reactjs.org/docs/render-props.html#gatsby-focus-wrapper">Render Props</a></li></ul><blockquote><p>是指一种在 <em>React</em> 组件之间使用一个值为函数的 <em>prop</em> 共享代码的 <strong>简单技术？</strong></p></blockquote><ul><li><a href="https://zh-hans.reactjs.org/docs/hooks-intro.html">Hooks</a></li></ul><blockquote><p>React16.8新增的特性，是一些可以让你在函数组件里“钩入”React state及生命周期等特性的函数，</p></blockquote></blockquote><p><strong>why</strong></p><blockquote><p>虽然 <strong><em>HOC\</em></strong> &amp; <strong><em>Render Props\</em></strong> 能处理逻辑复用的问题，但是却存在各自的问题。</p><p><strong><em>HOC\</em></strong> 存在的问题</p><blockquote><ul><li>写法破坏了原来组件的结构，DevTools中组件会形成“嵌套地狱”</li><li>不要在 <strong>render</strong> 方法中使用 <strong>HOC</strong> 每次调用render函数会创建一个新的高阶组件导致该组件及其子组件的状态丢失</li><li>需要修复静态方法，即拷贝原组件的静态方法到高级组件中</li><li>如需传递Ref则需要通过React.forwardRef创建组件</li></ul></blockquote><p><strong><em>Render Props\</em></strong> 存在的问题</p><blockquote><ul><li>同样的写法会破坏原来组件的结构，DevTools中组件会形成“嵌套地狱”</li><li>与React.PureComponent组件使用有冲突</li></ul></blockquote><p><strong><em>Hook\</em></strong> 目前最优雅的实现，React为共享状态逻辑提供最好的原生途径</p><blockquote><ul><li>没有破坏性改动，完全可选，100%向后兼容</li><li>解决复杂组件，中逻辑状态、副作用和各种生命周期函数中逻辑代码混在一起，难以拆分，甚至形成bug的问题</li><li>处理class组件中</li></ul></blockquote></blockquote><p><strong>when</strong></p><blockquote><ul><li>在函数组件中意识到要向其添加一些state—-useState</li><li>有副作用的行为时</li></ul></blockquote><p><strong>where</strong></p><blockquote><ul><li>只能在函数最外层调用Hook，不要在循环、条件判断或者子函数中调用</li><li>只能在函数组件或者自定义Hook中调用Hook</li></ul></blockquote><h5 id="15-列举重新渲染-render-的情况"><a href="#15-列举重新渲染-render-的情况" class="headerlink" title="15. 列举重新渲染 render 的情况"></a>15. 列举重新渲染 render 的情况</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="title function_">setState</span>() </span><br><span class="line"><span class="variable language_">this</span>.<span class="title function_">forceUpdate</span>()</span><br><span class="line"><span class="comment">// 接受到新的props</span></span><br><span class="line"><span class="comment">// 通过状态管理，mobx、redux等</span></span><br><span class="line"><span class="comment">// 改变上下文</span></span><br></pre></td></tr></table></figure><h5 id="16-如何避免组件的重新渲染？"><a href="#16-如何避免组件的重新渲染？" class="headerlink" title="16. 如何避免组件的重新渲染？"></a>16. 如何避免组件的重新渲染？</h5><blockquote><p>当porps/state改变时组件会执行render函数也就是重新渲染</p><ul><li>class组件中 使用shouldComponentUpdate钩子函数</li><li>PureComponent默认有避免重新渲染的功能</li><li>函数组件使用高阶组件memo处理</li></ul></blockquote><h5 id="17-渲染一个react组件的过程"><a href="#17-渲染一个react组件的过程" class="headerlink" title="17. 渲染一个react组件的过程"></a>17. 渲染一个react组件的过程</h5><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">        1、babel编译</span></span><br><span class="line"><span class="comment">        当我们对代码进行编译的时候，babel会将我们在组件中编写的jsx代码转化为React.createElement的表达式，createElement方法有三个参数，分别为type(元素类型）、attributes(元素所有属性)、children(元素所有子节点)；</span></span><br><span class="line"><span class="comment">        2、生成element</span></span><br><span class="line"><span class="comment">        当render方法被触发以后，createElement方法会执行，返回一个element对象，这个对象描述了真实节点的信息，其实就是虚拟dom节点；</span></span><br><span class="line"><span class="comment">        3、生成真实节点(初次渲染)</span></span><br><span class="line"><span class="comment">        这时候我们会判断element的类型，如果是null、false则实例一个ReactDOMEmptyComponent对象; 是string、number类型的话则实例一个ReactDOMTextComponent对象； 如果element是对象的话，会进一步判断type元素类型，是原生dom元素，则实例化ReactDOMComponent； 如果是自定义组件，则实例化ReactCompositeComponentWrapper；</span></span><br><span class="line"><span class="comment">        在这些类生成实例对象的时候，在其内部会调用 mountComponent方法，这个方法里面有一系列浏览器原生dom方法，可以将element渲染成真实的dom并插入到文档中；</span></span><br><span class="line"><span class="comment">        4、生命周期</span></span><br><span class="line"><span class="comment">        componentDidMount：会在组件挂载后(插入DOM树中) 立即调用。一般可以在这里请求数据；</span></span><br><span class="line"><span class="comment">        componentDidUpdate：会在数据更新后立即调用，首次渲染不会执行此方法；可以在其中直接调用 setState，但必须用if语句进行判断，防止死循环；</span></span><br><span class="line"><span class="comment">        conponentWillUnmount：会在组件卸载及销毁之前调用，在此方法中执行必要的清理操作，如清除timer；</span></span><br><span class="line"><span class="comment">        static getDerivedStateFromProps(prps,state)：这个生命周期函数代替了componentWillMount和componentWillUpdate生命周期；props和state发生改变则调用，在初始化挂载及后续更新时都会被调用，返回一个对象来更新state，如果返回null则不更新任何内容；</span></span><br><span class="line"><span class="comment">        shouldComponentUpdate(nextProps,nextState)：这个生命周期函数的返回值用来判断React组件是否因为当前 state 或 props 更改而重新渲染，默认返回值是true；这个方法在初始化渲染或使用forceUpdate()时不会调用；当将旧的state的值原封不动赋值给新的state（即不改变state的值，但是调用了setState）和 无数据交换的父组件的重新渲染都会导致组件重新渲染，这时候都可以通过shouldComponentUpdate来优化。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h5 id="18-类组件怎么做性能优化？函数组件怎么做性能优化？"><a href="#18-类组件怎么做性能优化？函数组件怎么做性能优化？" class="headerlink" title="18. 类组件怎么做性能优化？函数组件怎么做性能优化？"></a>18. 类组件怎么做性能优化？函数组件怎么做性能优化？</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">类组件：</span></span><br><span class="line"><span class="comment">    （1）使用shouldComponentUpdate：这个生命周期可以让我们决定当前状态或属性的改变是否重新渲染组件，默认返回ture，返回false时不会执行render，在初始化渲染或使用forceUpdate()时不会调用；如果在shouldComponentUpdate比较的值是引用类型的话，可能达不到我们想要的效果，因为引用类型指向同一个地址；</span></span><br><span class="line"><span class="comment">        当将旧的state的值原封不动赋值给新的state（即不改变state的值，但是调用了setState）和 无数据交换的父组件的重新渲染都会导致组件重新渲染，这时候都可以通过shouldComponentUpdate来优化；</span></span><br><span class="line"><span class="comment">    （2）React.PureComponent：基本上和Component用法一致，不同之处在于 PureComponent不需要开发者自己设置shouldComponentUpdate，因为PureComponent自带通过props和state的浅对比来实现 shouldComponentUpate；但是如果props和state对象包含复杂的数据结构，它可能会判断错误(表现为对象深层的数据已改变，视图却没有更新）；</span></span><br><span class="line"><span class="comment">    （3）使用Immutable：immutable是一种持久化数据，一旦被创建就不会被修改，修改immutable对象的时候返回新的immutable；也就是说在使用旧数据创建新数据的时候，会保证旧数据同时可用且不变；为了避免深度复制所有节点的带来的性能损耗，immutable使用了结构共享，即如果对象树中的一个节点发生变化，只修改这个节点和受他影响的父节点，其他节点仍然共享；</span></span><br><span class="line"><span class="comment">    （4）bind函数：在react中改变this的指向有三种方法，a)constructor中用bind绑定; b)使用时通过bind绑定; 3)使用箭头函数；选择第一种只在组件初始化的时候执行一次，第二种组件在每次render都要重新绑定，第三种在每次render时候都会生成新的箭头函数，所以选择第一种；</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">函数组件：</span></span><br><span class="line"><span class="comment">    （1）useCallback：接收一个函数作为参数，接收第二个参数作为依赖列表，返回值为函数，有助于避免在每次渲染时都进行高开销的计算，仅会在某个依赖项改变时才重新计算；可以使用useCallback把要传递给子组件的函数包裹起来，这样父组件刷新的时候，传递给子组件的函数指向不会发生改变，可以减少子组件的渲染次数；</span></span><br><span class="line"><span class="comment">            const handleUseCallback=useCallback(handleClick,[])</span></span><br><span class="line"><span class="comment">            &lt;Child handleClick=&#123;handleUseCallback&#125; /&gt;</span></span><br><span class="line"><span class="comment">    （2）useMemo：useMemo的使用和useCallback差不多，只是useCallback返回的是一个函数，useMemo返回值可以是函数、对象等都可以；</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">两者都可使用：</span></span><br><span class="line"><span class="comment">    （1）React.memo：React.memo 功能同React.PureComponent，但React.memo是高阶组件，既可以用在类组件中也可以用在函数组件中；memo还可以接收第二个参数，是一个可定制化的比较函数，其返回值与 shouldComponentUpdate的相反；</span></span><br><span class="line"><span class="comment">    （2）使用key：在列表渲染时使用key，这样当组件发生增删改、排序等操作时，diff运算后可以根据key值直接调整DOM顺序，避免不必要的渲染而避免性能的浪费；</span></span><br><span class="line"><span class="comment">    （3）不要滥用props：尽量只传需要的数据，避免多余的更新，尽量避免使用&#123;…props&#125;；</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h5 id="19-React-按需加载"><a href="#19-React-按需加载" class="headerlink" title="19. React 按需加载"></a>19. React 按需加载</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1、使用React.lazy， 但是React.lazy技术还不支持服务端渲染</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">OtherComponent</span> = <span class="title class_">React</span>.<span class="title function_">lazy</span>(<span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;./OtherComponent&#x27;</span>))</span><br><span class="line"><span class="comment">// 2、使用Loadable Components这个库</span></span><br><span class="line"><span class="keyword">import</span> loadable <span class="keyword">from</span> <span class="string">&#x27;@loadable/component&#x27;</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">OtherComponent</span> = <span class="title function_">loadable</span>(<span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;./OtherComponent&#x27;</span>))</span><br></pre></td></tr></table></figure><h5 id="20-纯函数有什么特点，副作用函数特点"><a href="#20-纯函数有什么特点，副作用函数特点" class="headerlink" title="20. 纯函数有什么特点，副作用函数特点"></a>20. 纯函数有什么特点，副作用函数特点</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">        纯函数与外界交换数据只有一个唯一渠道——参数和返回值；函数从函数外部接受的所有输入信息都通过参数传递到该函数内部；函数输出到函数外部的所有信息都通过返回值传递到该函数外部。</span></span><br><span class="line"><span class="comment">        纯函数的优点：无状态，线程安全；纯函数相互调用组装起来的函数，还是纯函数；应用程序或者运行环境可以对纯函数的运算结果进行缓存，运算加快速度。</span></span><br><span class="line"><span class="comment">        函数副作用是指当调用函数时，除了返回函数值之外，还对主调用函数产生附加的影响。比如调接口、修改全局变量、抛出一个异常或以一个错误终止、打印到终端或读取用户输入、读取或写入一个文件等，所以说副作用是编程中最关键的部分，因为我们需要跟用户、跟数据进行交互。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h5 id="21-React-中的StrictMode-严格模式-是什么？"><a href="#21-React-中的StrictMode-严格模式-是什么？" class="headerlink" title="21 React 中的StrictMode(严格模式)是什么？"></a>21 React 中的StrictMode(严格模式)是什么？</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    React的StrictMode是一种辅助组件，用&lt;StrictMode /&gt;包装组件，可以帮助我们编写更好的react组件，不会渲染出任何可见的ui；仅在开发模式下运行，它们不会影响生产构建，可以做以下检查：</span></span><br><span class="line"><span class="comment">    （1）验证内部组件是否遵循某些推荐做法，如果没有，会在控制台给出警告；</span></span><br><span class="line"><span class="comment">    （2）验证是否使用的已经废弃的方法，如果有，会在控制台给出警告；</span></span><br><span class="line"><span class="comment">    （3）通过识别潜在的风险预防一些副作用。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h5 id="22-如何在-React-的-Props-上应用验证？"><a href="#22-如何在-React-的-Props-上应用验证？" class="headerlink" title="22. 如何在 React 的 Props 上应用验证？"></a>22. 如何在 React 的 Props 上应用验证？</h5><blockquote><p>使用PropTypes进行类型检查</p></blockquote><p><a href="https://zh-hans.reactjs.org/docs/typechecking-with-proptypes.html#gatsby-focus-wrapper">PropTypes</a>自React v15.5起，请使用这个库<a href="https://www.npmjs.com/package/prop-types">prop-types</a></p><p>What &amp; Why &amp; When</p><blockquote><ul><li>随着应用的不断增长，也是为了使程序设计更加严谨，我们通常需要对数据的类型（值）进行一些必要的验证</li><li>出于性能方面的考虑，propTypes仅在开发模式下进行检测,在程序运行时就能检测出错误，不能使用到用户交互提醒用户操作错误等</li><li>也可以使用<a href="https://flow.org/">Flow</a>或者<a href="https://www.typescriptlang.org/">TypeScript</a>做类型检查，后期建议用typescript进行替代更好</li></ul></blockquote><p>Where</p><blockquote><ul><li>class组件</li><li>函数组件</li><li><a href="https://zh-hans.reactjs.org/docs/react-api.html#reactmemo">React.memo</a>高阶组件 <strong><em>可自行扩展\</em></strong></li><li><a href="https://zh-hans.reactjs.org/docs/react-api.html#reactforwardref">React.forwardRef</a>组件 <strong><em>可自行扩展\</em></strong></li></ul></blockquote><p>How</p><blockquote><p>我们在组件类下添加一个静态属性 propTypes (属性名不能更改)，它的值也是一个对象，用来设置组件中props的验证规则，key 是要验证的属性名称，value 是验证规则。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类组件</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">PropTypes</span> <span class="keyword">from</span> <span class="string">&#x27;prop-types&#x27;</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Greeting</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, &#123;this.props.name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 指定 props 的默认值：</span></span><br><span class="line"><span class="title class_">Greeting</span>.<span class="property">defaultProps</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Stranger&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 类组件在这里做检测</span></span><br><span class="line"><span class="title class_">Greeting</span>.<span class="property">propTypes</span> = &#123;</span><br><span class="line">  <span class="comment">// v15.4 and below</span></span><br><span class="line">  <span class="comment">// name: React.PropTypes.string</span></span><br><span class="line">  <span class="attr">name</span>: <span class="title class_">PropTypes</span>.<span class="property">string</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数组件</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">HelloWorldComponent</span>(<span class="params">&#123; name &#125;</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Hello, &#123;name&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 函数组件在这里做检测</span></span><br><span class="line"><span class="title class_">HelloWorldComponent</span>.<span class="property">propTypes</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="title class_">PropTypes</span>.<span class="property">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">HelloWorldComponent</span></span><br></pre></td></tr></table></figure><h5 id="23-什么是高阶组件、受控组件及非受控组件？都有啥区别"><a href="#23-什么是高阶组件、受控组件及非受控组件？都有啥区别" class="headerlink" title="23. 什么是高阶组件、受控组件及非受控组件？都有啥区别"></a>23. 什么是高阶组件、受控组件及非受控组件？都有啥区别</h5><p><strong><em>定义\</em></strong></p><blockquote><ul><li><a href="https://zh-hans.reactjs.org/docs/higher-order-components.html">高阶组件HOC</a>—-不是 <em>React API</em> 的一部分，是基于 <em>React</em> 的<strong>组合特性</strong>形成的设计模式。</li></ul><blockquote><p>高阶组件是参数为组件，返回值为新组件的<strong>函数</strong>（将组件转换为另一个组件，纯函数，无副作用）</p></blockquote><ul><li><a href="https://zh-hans.reactjs.org/docs/forms.html#controlled-components">受控组件</a></li></ul><blockquote><p>在表单元素中，state是唯一数据源，渲染表单的React组件控制着用户输入过程中表单发生的操作。被React以这种方式控制取值的表单输入元素叫做受控组件</p></blockquote><ul><li><a href="https://zh-hans.reactjs.org/docs/uncontrolled-components.html">非受控组件</a></li></ul><blockquote><p>表单数据由DOM节点来处理，而不是用state来管理数据，一般可以使用ref来从DOM节点中获取表单数据</p></blockquote></blockquote><p><strong><em>区别\</em></strong></p><blockquote><ul><li>受控组件和非受控组件是表单中的组件，高阶组件相当于对某个组件注入一些属性方法</li><li>高阶组件是解决代码复用性问题产生的技术</li><li>受控组件必须要有一个value，结合onChange来控制这个value，取值为event.target.value/event.target.checked</li><li>非受控组件相当于操作DOM，一般有个defaultValue，通过onBlur触发响应方法</li></ul></blockquote><h5 id="24-请你说说React的路由是什么？"><a href="#24-请你说说React的路由是什么？" class="headerlink" title="24. 请你说说React的路由是什么？"></a>24. 请你说说React的路由是什么？</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">        路由分为前端路由和后端路由，后端路由是服务器根据用户发起的请求而返回不同内容，前端路由是客户端根据不同的URL去切换组件；在web应用前端开发中，路由系统是最核心的部分，当页面的URL发生改变时，页面的显示结果可以根据URL的变化而变化，但是页面不会刷新。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        react生态中路由通常是使用react-router来进行配置，其主要构成为：</span></span><br><span class="line"><span class="comment">（1）Router——对应路由的两种模式，包括&lt;BrowsersRouter&gt;与&lt;HashRouter&gt;；</span></span><br><span class="line"><span class="comment">（2）route matching组件——控制路径对应的显示组件，可以进行同步加载和异步加载，&lt;Route&gt;；</span></span><br><span class="line"><span class="comment">（3）navigation组件——用做路由切换和跳转，&lt;Link&gt;；</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        BrowserRouter与HashRouter的区别：</span></span><br><span class="line"><span class="comment">（1）底层原理不一样：BrowserRouter使用的是H5的history API，不兼容IE9及以下版本；HashRouter使用的是URL的哈希值；</span></span><br><span class="line"><span class="comment">（2）path表现形式不一样：BrowserRouter的路径中没有#,例如：localhost:3000/demo/test；HashRouter的路径包含#,例如：localhost:3000/#/demo/test；</span></span><br><span class="line"><span class="comment">（3）刷新后对路由state参数的影响：BrowserRouter没有任何影响，因为state保存在history对象中；HashRouter刷新后会导致路由state参数的丢失；</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h5 id="25-React路由懒加载的实现"><a href="#25-React路由懒加载的实现" class="headerlink" title="25. React路由懒加载的实现"></a>25. React路由懒加载的实现</h5><ul><li><strong><em>原理\</em></strong></li></ul><blockquote><ul><li>webpack代码分割</li><li>React利用 React.lazy与import()实现了渲染时的动态加载</li><li>利用Suspense来处理异步加载资源时页面应该如何显示的问题</li></ul></blockquote><ul><li><em>1.React.lazy</em></li></ul><blockquote><ul><li>通过lazy() api来动态import需要懒加载的组件</li><li>import的组件目前只支持export default的形式导出</li><li>Suspense来包裹懒加载的组件进行加载，可以设置fallback现实加载中效果</li><li>React.lazy可以结合Router来对模块进行懒加载。</li></ul></blockquote><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">BrowserRouter</span> <span class="keyword">as</span> <span class="title class_">Router</span>, <span class="title class_">Route</span>, <span class="title class_">Switch</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;react-router-dom&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Suspense</span>, lazy &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Home</span> = <span class="title function_">lazy</span>(<span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;./routes/Home&#x27;</span>))</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">AnyComponent</span> = <span class="title function_">lazy</span>(<span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;./routes/AnyComponent&#x27;</span>))</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">Router</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">Suspense</span> <span class="attr">fallback</span>=<span class="string">&#123;</span>&lt;<span class="attr">div</span>&gt;</span>Loading...<span class="tag">&lt;/<span class="name">div</span>&gt;</span>&#125;&gt;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Switch</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Route</span> <span class="attr">exact</span> <span class="attr">path</span>=<span class="string">&quot;/&quot;</span> <span class="attr">component</span>=<span class="string">&#123;Home&#125;/</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/anyManage&quot;</span> <span class="attr">component</span>=<span class="string">&#123;AnyComponent&#125;/</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        ...</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">Switch</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">Suspense</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">Router</span>&gt;</span></span></span><br></pre></td></tr></table></figure><ul><li><em>2.react-loadable</em></li></ul><blockquote><p>react-loadable是以组件级别来分割代码的，这意味着，我们不仅可以根据路由按需加载，还可以根据组件按需加载，使用方式和路由分割一样，只用修改组件的引入方式即可</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 路由懒加载（异步组件）</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Loadable</span> <span class="keyword">from</span> <span class="string">&#x27;react-loadable&#x27;</span>;</span><br><span class="line"><span class="comment">//通用过场组件</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">LoadingComponent</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>loading<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> (loader, loading=<span class="title class_">LoadingComponent</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Loadable</span>(&#123;</span><br><span class="line">    loader,</span><br><span class="line">    loading</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Route中调用</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">BrowserRouter</span>, <span class="title class_">Route</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;react-router-dom&#x27;</span></span><br><span class="line"><span class="keyword">const</span> loadable <span class="keyword">from</span> <span class="string">&#x27;./loadable&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">AnyComponent</span> = <span class="title function_">loadable</span>(<span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;./AnyComponent&#x27;</span>))</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">Routes</span> = (<span class="params"></span>) =&gt; (</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">BrowserRouter</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/home&quot;</span> <span class="attr">component</span>=<span class="string">&#123;AnyComponent&#125;/</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">BrowserRouter</span>&gt;</span></span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">Routes</span>;</span><br></pre></td></tr></table></figure><ul><li><em>3.webpack配置中使用lazyload-loader</em></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack 配置中</span></span><br><span class="line"><span class="attr">module</span>: &#123;</span><br><span class="line"> <span class="attr">rules</span>: [</span><br><span class="line"> &#123;</span><br><span class="line"> <span class="attr">test</span>: <span class="regexp">/.(js|jsx)$/</span>,,</span><br><span class="line"> <span class="attr">use</span>: [</span><br><span class="line"> <span class="string">&#x27;babel-loader&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;lazyload-loader&#x27;</span></span><br><span class="line"> ]</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line"><span class="comment">// 业务代码中</span></span><br><span class="line"><span class="comment">// 使用lazy! 前缀 代表需要懒加载的Router</span></span><br><span class="line"> <span class="keyword">import</span> <span class="title class_">Shop</span> <span class="keyword">from</span> <span class="string">&#x27;lazy!./src/view/Shop&#x27;</span>;</span><br><span class="line"> <span class="comment">// Router 正常使用</span></span><br><span class="line"> <span class="language-xml"><span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/shop&quot;</span> <span class="attr">component</span>=<span class="string">&#123;Shop&#125;</span> /&gt;</span></span></span><br></pre></td></tr></table></figure><ul><li><em>4.import()</em> webpack v2+</li></ul><blockquote><p>符合ECMAScript提议的import()语法，该提案与普通 import 语句或 require 函数的类似，但返回一个 Promise 对象</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">component</span>(<span class="params"></span>) &#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">import</span>( <span class="comment">/* webpackChunkName: &quot;lodash&quot; */</span> <span class="string">&#x27;lodash&#x27;</span>).<span class="title function_">then</span>(<span class="function"><span class="params">_</span> =&gt;</span> &#123;</span><br><span class="line"> <span class="keyword">var</span> element = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line"> element.<span class="property">innerHTML</span> = _.<span class="title function_">join</span>([<span class="string">&#x27;Hello&#x27;</span>, <span class="string">&#x27;webpack&#x27;</span>], <span class="string">&#x27; &#x27;</span>);</span><br><span class="line"> <span class="keyword">return</span> element;</span><br><span class="line"> &#125;).<span class="title function_">catch</span>(<span class="function"><span class="params">error</span> =&gt;</span> <span class="string">&#x27;An error occurred while loading the component&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 或者使用async</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">getComponent</span>(<span class="params"></span>) &#123;</span><br><span class="line"> <span class="keyword">var</span> element = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line"> <span class="keyword">const</span> _ = <span class="keyword">await</span> <span class="keyword">import</span>(<span class="comment">/* webpackChunkName: &quot;lodash&quot; */</span> <span class="string">&#x27;lodash&#x27;</span>);</span><br><span class="line"> element.<span class="property">innerHTML</span> = _.<span class="title function_">join</span>([<span class="string">&#x27;Hello&#x27;</span>, <span class="string">&#x27;webpack&#x27;</span>], <span class="string">&#x27; &#x27;</span>);</span><br><span class="line"> <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><em>5.requre.ensure</em> webpack v1 v2</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>.<span class="title function_">ensure</span>([], <span class="keyword">function</span>(<span class="params"><span class="built_in">require</span></span>)&#123;</span><br><span class="line"> <span class="keyword">var</span> list = <span class="built_in">require</span>(<span class="string">&#x27;./list&#x27;</span>);</span><br><span class="line"> list.<span class="title function_">show</span>();</span><br><span class="line">，<span class="string">&#x27;list&#x27;</span>);</span><br><span class="line">&lt;!-- <span class="title class_">Router</span> --&gt;</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Foo</span> = <span class="built_in">require</span>.<span class="title function_">ensure</span>([], <span class="function">() =&gt;</span> &#123;</span><br><span class="line"> <span class="built_in">require</span>(<span class="string">&quot;Foo&quot;</span>);</span><br><span class="line">&#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&quot;We failed to load chunk: &quot;</span> + err);</span><br><span class="line">&#125;, <span class="string">&quot;chunk-name&quot;</span>);</span><br><span class="line"><span class="comment">//react-router2 or 3</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/foo&quot;</span> <span class="attr">getComponent</span>=<span class="string">&#123;Foo&#125;</span> /&gt;</span></span></span><br></pre></td></tr></table></figure><h5 id="26-React-router-dom内部是怎么样实现的，怎么做路由守卫？"><a href="#26-React-router-dom内部是怎么样实现的，怎么做路由守卫？" class="headerlink" title="26. React-router-dom内部是怎么样实现的，怎么做路由守卫？"></a>26. React-router-dom内部是怎么样实现的，怎么做路由守卫？</h5><h6 id="内部实现"><a href="#内部实现" class="headerlink" title="内部实现"></a>内部实现</h6><ul><li>总</li></ul><blockquote><p>react-router-dom利用了Context API，通过上下文对象将当前路由信息对象注入到 <em>Router</em> 组件中，所以 <em>Router</em> 组件中 <em>render()</em> 渲染的内容就是 <em>ContextAPI</em> 提供的 <em>Provider</em> 组件，然后接收 <em>Router</em> 组件中的当前路由信息对象。 这样 <em>Router</em> 组件下的所有组件都能通过上下文拿到当前路由信息对象，即其中的<em>Switch</em> 、 <em>Route</em> 、 <em>Link</em> 、<em>Redirect</em> 等组件都可以拿到当前路由信息对象，然后通过改变当前路由信息来实现动态切换 <em>Route</em> 组件的渲染。</p></blockquote><ul><li>分</li></ul><blockquote><ul><li>RouterContext：react-router使用context实现跨组件间数据传递，所以react-router定义了一个routerContext作为数据源，</li><li>Router：BrowserRouter和HashRouter将当前路由注入到上下文中，同时路由信息包含location、match、history</li><li>Route：路由规则，获取RouterContext的信息(location对象)，获取path和component属性，判断path和当前的location是否匹配，如果匹配，则渲染component，否则返回null，不渲染任何内容</li><li>Switch：遍历所有子元素(Route)，判断Route的path和location是否匹配，如果匹配，则渲染，否则不渲染</li><li>Redireact：未能配则重定向到指定页面</li><li>Link/NavLink: Link组件本质就是a标签，它修改了a标签的默认行为，当点击Link时，会导航到对应的路由，导致locaiton对象的改变，出发组件的更新</li><li>withRouter：对传入的组件进行加强，功能就是获取routerContext上面的信息，然后作为props传给需要加强的组件</li></ul></blockquote><h6 id="怎么做路由守卫"><a href="#怎么做路由守卫" class="headerlink" title="怎么做路由守卫"></a>怎么做路由守卫</h6><ul><li>路由里设置meta元字符实现路由拦截</li></ul><blockquote><ul><li>React Router 4.0之前也像vue中一样有个钩子函数 <em>onEnter</em> 可实现</li><li>ReactRouter 4.0开始自己实现如下</li></ul></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// routerMap.js中</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Index</span> <span class="keyword">from</span> <span class="string">&#x27;./page/index&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> [</span><br><span class="line">  &#123; <span class="attr">path</span>:<span class="string">&#x27;/&#x27;</span>, <span class="attr">name</span>: <span class="string">&#x27;App&#x27;</span>, <span class="attr">component</span>:<span class="title class_">Index</span>, <span class="attr">auth</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">  ...</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment">//入口文件 app.js中</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">BrowserRouter</span> <span class="keyword">as</span> <span class="title class_">Router</span>, <span class="title class_">Switch</span> &#125; <span class="keyword">from</span> <span class="string">&quot;react-router-dom&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">FrontendAuth</span> <span class="keyword">from</span> <span class="string">&quot;./FrontendAuth&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> routerMap <span class="keyword">from</span> <span class="string">&quot;./routerMap&quot;</span>;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">Router</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Switch</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">FrontendAuth</span> <span class="attr">routerConfig</span>=<span class="string">&#123;routerMap&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">Switch</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">Router</span>&gt;</span></span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 高阶组件FrontendAuth 处理路由跳转，即路由守卫功能</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//FrontendAuth.js</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; <span class="title class_">Component</span> &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Route</span>, <span class="title class_">Redirect</span> &#125; <span class="keyword">from</span> <span class="string">&quot;react-router-dom&quot;</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FrontendAuth</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line">  <span class="comment">// eslint-disable-next-line no-useless-constructor</span></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(props);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; routerConfig, location &#125; = <span class="variable language_">this</span>.<span class="property">props</span>;</span><br><span class="line">    <span class="keyword">const</span> &#123; pathname &#125; = location;</span><br><span class="line">    <span class="keyword">const</span> isLogin = sessionStorage.<span class="title function_">getItem</span>(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(pathname, isLogin);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(location);</span><br><span class="line">    <span class="comment">// 如果该路由不用进行权限校验，登录状态下登陆页除外</span></span><br><span class="line">    <span class="comment">// 因为登陆后，无法跳转到登陆页</span></span><br><span class="line">    <span class="comment">// 这部分代码，是为了在非登陆状态下，访问不需要权限校验的路由</span></span><br><span class="line">    <span class="keyword">const</span> targetRouterConfig = routerConfig.<span class="title function_">find</span>(</span><br><span class="line">      <span class="function">(<span class="params">item</span>) =&gt;</span> item.<span class="property">path</span> === pathname</span><br><span class="line">    );</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(targetRouterConfig);</span><br><span class="line">    <span class="keyword">if</span> (targetRouterConfig &amp;&amp; !targetRouterConfig.<span class="property">auth</span> &amp;&amp; !isLogin) &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123; component &#125; = targetRouterConfig;</span><br><span class="line">      <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Route</span> <span class="attr">exact</span> <span class="attr">path</span>=<span class="string">&#123;pathname&#125;</span> <span class="attr">component</span>=<span class="string">&#123;component&#125;</span> /&gt;</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isLogin) &#123;</span><br><span class="line">      <span class="comment">// 如果是登陆状态，想要跳转到登陆，重定向到主页</span></span><br><span class="line">      <span class="keyword">if</span> (pathname === <span class="string">&quot;/login&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Redirect</span> <span class="attr">to</span>=<span class="string">&quot;/&quot;</span> /&gt;</span></span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果路由合法，就跳转到相应的路由</span></span><br><span class="line">        <span class="keyword">if</span> (targetRouterConfig) &#123;</span><br><span class="line">          <span class="keyword">return</span> (</span><br><span class="line">            <span class="language-xml"><span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&#123;pathname&#125;</span> <span class="attr">component</span>=<span class="string">&#123;targetRouterConfig.component&#125;</span> /&gt;</span></span></span><br><span class="line">          );</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 如果路由不合法，重定向到 404 页面</span></span><br><span class="line">          <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Redirect</span> <span class="attr">to</span>=<span class="string">&quot;/404&quot;</span> /&gt;</span></span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 非登陆状态下，当路由合法时且需要权限校验时，跳转到登陆页面，要求登陆</span></span><br><span class="line">      <span class="keyword">if</span> (targetRouterConfig &amp;&amp; targetRouterConfig.<span class="property">auth</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Redirect</span> <span class="attr">to</span>=<span class="string">&quot;/login&quot;</span> /&gt;</span></span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 非登陆状态下，路由不合法时，重定向至 404</span></span><br><span class="line">        <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Redirect</span> <span class="attr">to</span>=<span class="string">&quot;/404&quot;</span> /&gt;</span></span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">FrontendAuth</span>;</span><br></pre></td></tr></table></figure><ul><li>总结一下，实现路由守卫需要考虑到以下的问题：</li></ul><blockquote><ul><li>未登录情况下，访问不需要权限校验的合法页面：允许访问</li><li>未登录情况下，访问需要权限校验的页面：禁止访问，跳转至登陆页</li><li>未登录情况下，访问所有的非法页面：禁止访问，跳转至 404</li><li>登陆情况下，访问登陆页面：禁止访问，跳转至主页</li><li>登陆情况下，访问除登陆页以外的合法页面：允许访问</li><li>登陆情况下，访问所有的非法页面：禁止访问，跳转至 404</li></ul></blockquote><h5 id="27-React有哪些性能优化的手段？"><a href="#27-React有哪些性能优化的手段？" class="headerlink" title="27. React有哪些性能优化的手段？"></a>27. React有哪些性能优化的手段？</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    1、使用纯组件；</span></span><br><span class="line"><span class="comment">    2、使用 React.memo 进行组件记忆（React.memo 是一个高阶组件），对于相同的输入，不重复执行；</span></span><br><span class="line"><span class="comment">    3、如果是类组件，使用 shouldComponentUpdate（这是在重新渲染组件之前触发的其中一个生命周期事件）生命周期事件，可以利用此事件来决定何时需要重新渲染组件；</span></span><br><span class="line"><span class="comment">    4、路由懒加载；</span></span><br><span class="line"><span class="comment">    5、使用 React Fragments 避免额外标记；</span></span><br><span class="line"><span class="comment">    6、不要使用内联函数定义（如果我们使用内联函数，则每次调用“render”函数时都会创建一个新的函数实例）；</span></span><br><span class="line"><span class="comment">    7、避免在Willxxx系列的生命周期中进行异步请求，操作dom等；</span></span><br><span class="line"><span class="comment">    8、如果是类组件，事件函数在Constructor中绑定bind改变this指向；</span></span><br><span class="line"><span class="comment">    9、避免使用内联样式属性；</span></span><br><span class="line"><span class="comment">    10、优化 React 中的条件渲染；</span></span><br><span class="line"><span class="comment">    11、不要在 render 方法中导出数据；</span></span><br><span class="line"><span class="comment">    12、列表渲染的时候加key；</span></span><br><span class="line"><span class="comment">    13、在函数组件中使用useCallback和useMemo来进行组件优化，依赖没有变化的话，不重复执行；</span></span><br><span class="line"><span class="comment">    14、类组件中使用immutable对象；</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h5 id="28-描述-Flux-与-MVC？"><a href="#28-描述-Flux-与-MVC？" class="headerlink" title="28. 描述 Flux 与 MVC？"></a>28. 描述 Flux 与 MVC？</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">        传统的 MVC 模式在分离数据(Model)、UI(View和逻辑(Controller)方面工作得很好，但是 MVC 架构经常遇到两个主要问题:</span></span><br><span class="line"><span class="comment">        数据流不够清晰——跨视图发生的级联更新常常会导致混乱的事件网络，难于调试。</span></span><br><span class="line"><span class="comment">        缺乏数据完整性——模型数据可以在任何地方发生突变，从而在整个UI中产生不可预测的结果。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        使用 Flux 模式的复杂用户界面不再遭受级联更新，任何给定的React 组件都能够根据 store 提供的数据重建其状态。Flux 模式还通过限制对共享数据的直接访问来加强数据完整性。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h5 id="29-Redux遵循的三个原则是什么？"><a href="#29-Redux遵循的三个原则是什么？" class="headerlink" title="29. Redux遵循的三个原则是什么？"></a>29. Redux遵循的三个原则是什么？</h5><blockquote><p><strong><em>单一数据源\</em></strong></p><ul><li>整个应用的state被存储在一棵object tree中，并且整个 object tree 只存在于唯一一个 store 中</li></ul><p><strong><em>State是只读的\</em></strong></p><ul><li>唯一改变state的方法就是触发 action，action是一个描述已发生事件的普通对象</li><li>这样确保视图和网络请求不能直接修改state</li></ul><p><strong><em>使用纯函数来执行修改\</em></strong></p><ul><li>为了描述action如何改变state tree，你需要编写reducers</li></ul></blockquote><h5 id="30-react中使用setState不能立刻获取值，怎么办"><a href="#30-react中使用setState不能立刻获取值，怎么办" class="headerlink" title="30. react中使用setState不能立刻获取值，怎么办"></a>30. react中使用setState不能立刻获取值，怎么办</h5><blockquote><p>setState 只在合成事件和钩子函数中是异步的，在原生事件和 setTimeout 中都是同步</p><ul><li>①addeventListener添加的事件或者dom事件中触发</li><li>②setState接收的参数还可以是一个函数，在这个函数中可以拿先前的状态，并通过这个函数的返回值得到下一个状态。</li></ul></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="variable language_">this</span>.<span class="title function_">setState</span>(<span class="function">(<span class="params">preState</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">xxx</span>: preState.<span class="property">xxx</span> + yyy</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><ul><li>③async/await 异步调用处理</li></ul></blockquote><h5 id="31-聊聊-Redux-和-Vuex-的设计思想"><a href="#31-聊聊-Redux-和-Vuex-的设计思想" class="headerlink" title="31. 聊聊 Redux 和 Vuex 的设计思想"></a>31. 聊聊 Redux 和 Vuex 的设计思想</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">        Flux的核心思想就是数据和逻辑永远单向流动，由三大部分组成 dispatcher(负责分发事件), store(负责保存数据，同时响应事件并更新数据)和 view(负责订阅store中的数据，并使用这些数据渲染相应的页面)，Redux和Vuex是flux思想的具体实现，都是用来做状态管理的工具，Redux主要在react中使用，Vuex主要在vue中使用。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        Redux设计和使用的三大原则：</span></span><br><span class="line"><span class="comment">      （1）单一的数据源：整个应用的 state被储存在唯一一个 store中；</span></span><br><span class="line"><span class="comment">      （2）状态是只读的：Store.state不能直接修改（只读），必须调用dispatch(action) =&gt; store.reducer =&gt; return newState；action是一个对象，有type（操作类型）和payload（新值）属性；</span></span><br><span class="line"><span class="comment">      （3）状态修改均由纯函数完成：在Redux中，通过纯函数reducer来确定状态的改变，因为reducer是纯函数，所以相同的输入，一定会得到相同的输出，同时也不支持异步；返回值是一个全新的state；</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        vuex由State + Muatations(commit) + Actions(dispatch) 组成：</span></span><br><span class="line"><span class="comment">      （1）全局只有一个Store实例（单一数据源）；</span></span><br><span class="line"><span class="comment">      （2）Mutations必须是同步事务，不同步修改的话，会很难调试，不知道改变什么时候发生，也很难确定先后顺序，A、B两个mutation，调用顺序可能是A -&gt; B，但是最终改变 State的结果可能是B -&gt; A；</span></span><br><span class="line"><span class="comment">      （3）Actions负责处理异步事务，然后在异步回调中触发一个或多个mutations，也可以在业务代码中处理异步事务，然后在回调中同样操作；</span></span><br><span class="line"><span class="comment">      （4）模块化通过module方式来处理，这个跟Redux-combineReducer类似，在应用中可以通过namespaceHelper来简化使用；</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h5 id="32-redux本来是同步的，为什么它能执行异步代码？中间件的实现原理是什么？"><a href="#32-redux本来是同步的，为什么它能执行异步代码？中间件的实现原理是什么？" class="headerlink" title="32. redux本来是同步的，为什么它能执行异步代码？中间件的实现原理是什么？"></a>32. redux本来是同步的，为什么它能执行异步代码？中间件的实现原理是什么？</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">        当我们需要修改store中值的时候，我们是通过 dispatch(action)将要修改的值传到reducer中的，这个过程是同步的，如果我们要进行异步操作的时候，就需要用到中间件；中间件其实是提供了一个分类处理action的机会，在 middleware 中，我们可以检阅每一个流过的action，并挑选出特定类型的 action进行相应操作，以此来改变 action；</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">         applyMiddleware 是个三级柯里化的函数。它将陆续的获得三个参数：第一个是 middlewares 数组，第二个是 Redux 原生的 createStore，最后一个是 reducer；然后applyMiddleware会将不同的中间件一层一层包裹到原生的 dispatch 之上；</span></span><br><span class="line"><span class="comment">         redux-thunk 中间件的作用就是让我们可以异步执行redux，首先检查参数 action 的类型，如果是函数的话，就执行这个 action这个函数，并把 dispatch, getState, extraArgument 作为参数传递进去，否则就调用next让下一个中间件继续处理action。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// redux-thunk部分源码</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createThunkMiddleware</span>(<span class="params">extraArgument</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">&#123; dispatch, getState &#125;</span>) =&gt;</span> <span class="function"><span class="params">next</span> =&gt;</span> <span class="function"><span class="params">action</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> action === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">action</span>(dispatch, getState, extraArgument)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">next</span>(action)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> thunk = <span class="title function_">createThunkMiddleware</span>()</span><br><span class="line">thunk.<span class="property">withExtraArgument</span> = createThunkMiddleware</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> thunk</span><br></pre></td></tr></table></figure><h5 id="33-redux中sages和thunk中间件的区别，优缺点"><a href="#33-redux中sages和thunk中间件的区别，优缺点" class="headerlink" title="33. redux中sages和thunk中间件的区别，优缺点"></a>33. redux中sages和thunk中间件的区别，优缺点</h5><ul><li>区别</li></ul><blockquote><ul><li>redux-thunk异步采取 async/await redux-saga采取generate函数</li></ul></blockquote><ul><li>优缺点</li></ul><blockquote><ul><li>redux-thunk</li></ul><blockquote><p>优点： 库小，代码就几行 缺点：代码臃肿，reducer不再是纯粹函数，直接返回对象，违背了当初的设计原则；action的形式不统一，异步操作太为分散，分散在了各个action中</p></blockquote><ul><li>redux-saga</li></ul><blockquote><p>优点： 将异步与reducer区分开了，更加优雅，适合大量APi请求，而且每个请求之间存在复杂的以来关系 缺点：学习曲线比较陡，理解async await；而且库也比较大，即使发布的最小也有25kb,gzip压缩后也有7KB,React压缩后才45kb</p></blockquote></blockquote><h5 id="34-redux-和-mobx-的区别"><a href="#34-redux-和-mobx-的区别" class="headerlink" title="34. redux 和 mobx 的区别"></a>34. redux 和 mobx 的区别</h5><blockquote><ul><li>①Redux的编程范式是函数式的而Mobx是面向对象的</li><li>②因此数据上来说Redux理想的是immutable的，每次都返回一个新的数据，而Mobx从始至终都是一份引用。因此Redux是支持数据回溯的</li><li>③然而和Redux相比，使用Mobx的组件可以做到精确更新，这一点得益于Mobx的observable；对应的，Redux是用dispatch进行广播，通过Provider和connect来比对前后差别控制更新粒度，有时需要自己写SCU；Mobx更加精细一点</li><li>④Mobx-react vs React-rdux：</li></ul><blockquote><p>redux,采取Provider和connect方式，mobx采取Provider和inject、observer</p></blockquote></blockquote><h5 id="35-什么是-immutable？为什么要使用它？"><a href="#35-什么是-immutable？为什么要使用它？" class="headerlink" title="35. 什么是 immutable？为什么要使用它？"></a>35. 什么是 immutable？为什么要使用它？</h5><blockquote><p>immutable是一种持久化数据。一旦被创建就不会被修改。修改immutable对象的时候返回新的immutable。但是原数据不会改变。</p><p>在Rudux中因为深拷贝对性能的消耗太大了（用到了递归，逐层拷贝每个节点）。 但当你使用immutable数据的时候：只会拷贝你改变的节点，从而达到了节省性能。 总结：immutable的不可变性让纯函数更强大，每次都返回新的immutable的特性让程序员可以对其进行链式操作，用起来更方便。</p><p>因为在react中，react的生命周期中的setState()之后的shouldComponentUpdate()阶段默认返回true，所以会造成本组件和子组件的多余的render，重新生成virtual dom，并进行virtual dom diff，所以解决办法是我们在本组件或者子组件中的shouldComponentUpdate()函数中比较，当不需要render时，不render。</p><p>当state中的值是对象时，我们必须使用深拷贝和深比较！</p><p>如果不进行深拷贝后再setState，会造成this.state和nextState指向同一个引用，所以shouldComponentUpdate()返回值一定是false，造成state值改了，而组件未渲染（这里不管shouldComponentUpdate中使用的是深比较还是浅比较）。所以必须深拷贝。</p><p>如果不在shouldComponentUpdate中进行深比较，会造成即使state中的对象值没有改变，因为是不同的对象，而在shouldComponentUpdate返回true，造成不必要的渲染。</p><p>所以只能是深拷贝和深比较。</p></blockquote><h4 id="九-小程序高频面试题"><a href="#九-小程序高频面试题" class="headerlink" title="九. 小程序高频面试题"></a>九. 小程序高频面试题</h4><h5 id="1-简述微信小程序原理"><a href="#1-简述微信小程序原理" class="headerlink" title="1. 简述微信小程序原理"></a>1. 简述微信小程序原理</h5><blockquote><p>微信小程序采用 <code>JavaScript</code>、<code>WXML</code>、<code>WXSS</code> 三种技术进行开发,本质就是一个单页面应用，所有的页面渲染和事件处理，都在一个页面内进行，但又可以通过微信客户端调用原生的各种接口微信的架构，是数据驱动的架构模式，它的 <code>UI</code> 和数据是分离的，所有的页面更新，都需要通过对数据的更改来实现 小程序分为两个部分 <code>webview</code> 和 <code>appService</code> 。其中 <code>webview</code> 主要用来展现 <code>UI</code> ，<code>appService</code> 有来处理业务逻辑、数据及接口调用。它们在两个进程中运行，通过系统层 <code>JSBridge</code> 实现通信，实现 <code>UI</code> 的渲染、事件的处理</p></blockquote><h5 id="2-简单描述下微信小程序的相关文件类型"><a href="#2-简单描述下微信小程序的相关文件类型" class="headerlink" title="2. 简单描述下微信小程序的相关文件类型"></a>2. 简单描述下微信小程序的相关文件类型</h5><blockquote><p>微信小程序项目结构主要有四个文件类型</p></blockquote><ul><li><code>WXML</code>（WeiXin Markup Language）是框架设计的一套标签语言，结合基础组件、事件系统，可以构建出页面的结构。内部主要是微信自己定义的一套组件</li><li><code>WXSS</code> (WeiXin Style Sheets)是一套样式语言，用于描述 <code>WXML</code> 的组件样式</li><li><code>js</code> 逻辑处理，网络请求</li><li><code>json</code> 小程序设置，如页面注册，页面标题及<code>tabBar</code></li></ul><blockquote><p>主要文件</p></blockquote><ul><li><code>app.json</code> 必须要有这个文件，如果没有这个文件，项目无法运行，因为微信框架把这个作为配置文件入口，整个小程序的全局配置。包括页面注册，网络设置，以及小程序的 <code>window</code> 背景色，配置导航条样式，配置默认标题</li><li><code>app.js</code> 必须要有这个文件，没有也是会报错！但是这个文件创建一下就行 什么都不需要写以后我们可以在这个文件中监听并处理小程序的生命周期函数、声明全局变量</li><li><code>app.wxss</code> 可选</li></ul><h5 id="3-小程序的双向绑定和vue哪里不一样"><a href="#3-小程序的双向绑定和vue哪里不一样" class="headerlink" title="3. 小程序的双向绑定和vue哪里不一样"></a>3. 小程序的双向绑定和vue哪里不一样</h5><ol><li>小程序直接修改 <code>this.data</code> 的属性是不可以同步到视图的，必须调用：</li></ol> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="title function_">setData</span>(&#123;</span><br><span class="line">    <span class="comment">// 这里设置</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ol><li>在vue中,只需要再表单元素上加上v-model,然后再绑定data中对应的一个值，当表单元素内容发生变化时，data中对应的值也会相应改变，这是vue非常nice的一点。 但是在小程序中，却没有这个功能。那怎么办呢？当表单内容发生变化时，会触发表单元素上绑定的方法，然后在该方法中，通过this.setData({key:value})来将表单上的值赋值给data中的对应值。下面是代码，可以感受一下:</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;input bindinput=<span class="string">&quot;bindReason&quot;</span> placeholder=<span class="string">&quot;填写理由&quot;</span> <span class="keyword">class</span>=<span class="string">&#x27;reason&#x27;</span> value=<span class="string">&#x27;&#123;&#123;reason&#125;&#125;&#x27;</span> name=<span class="string">&quot;reason&quot;</span> /&gt;  </span><br><span class="line">  <span class="title class_">Page</span>(&#123;  </span><br><span class="line">  <span class="attr">data</span>:&#123;  </span><br><span class="line">  <span class="attr">reason</span>:<span class="string">&#x27;&#x27;</span>  </span><br><span class="line">  &#125;,  </span><br><span class="line">  <span class="title function_">bindReason</span>(<span class="params">e</span>) &#123;  </span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">setData</span>(&#123;  </span><br><span class="line">  <span class="attr">reason</span>: e.<span class="property">detail</span>.<span class="property">value</span>  </span><br><span class="line">  &#125;)  </span><br><span class="line">  &#125;  </span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><p>当页面表单元素很多的时候，更改值就是一件体力活了。和小程序一比较，vue的v-model简直爽的不要不要的。</p><ol><li>取值</li></ol><ul><li><p>vue中，通过this.reason取值</p></li><li><p>小程序中，通过this.data.reason取值</p></li></ul><h5 id="4-如何自定义小程序的navigationBar"><a href="#4-如何自定义小程序的navigationBar" class="headerlink" title="4. 如何自定义小程序的navigationBar"></a>4. 如何自定义小程序的navigationBar</h5><ul><li><p>思路</p><blockquote><p>隐藏原生样式 获取胶囊按钮、状态栏相关数据以供后续计算 根据不同机型计算出该机型的导航栏高度，进行适配 编写新的导航栏 引用到页面</p></blockquote></li></ul><p>参考<a href="https://zhuanlan.zhihu.com/p/117244248">这里</a></p><h5 id="5-说说小程序中wx-if和hidden的区别"><a href="#5-说说小程序中wx-if和hidden的区别" class="headerlink" title="5. 说说小程序中wx:if和hidden的区别"></a>5. 说说小程序中wx:if和hidden的区别</h5><blockquote><p>相同点：</p></blockquote><p>wx:if 与 hidden 都用来控制小程序元素的显示</p><blockquote><p>不同点</p></blockquote><p>wx:if：</p><ul><li>1、条件为 true 时显示</li><li>2、当元素显示时渲染</li><li>3、元素变为不显示时销毁元素</li></ul><p>hidden：</p><ul><li>1、条件为 false 时显示</li><li>2、当元素显示时渲染</li><li>3、元素变为不显示时保留元素</li><li>4、相当于使用了dispaly</li></ul><p>总结： 1、当元素频繁切换是否显示时使用 hidden ，因为 wx:if 会频繁地销毁渲染元素 2、当元素不频繁切换是否显示时使用 wx:if，因为 wx:if 会避免页面加载时渲染过多，导致页面加载缓慢</p><h5 id="6-小程序的-wxss-和-css-有哪些不一样的地方"><a href="#6-小程序的-wxss-和-css-有哪些不一样的地方" class="headerlink" title="6. 小程序的 wxss 和 css 有哪些不一样的地方"></a>6. 小程序的 wxss 和 css 有哪些不一样的地方</h5><blockquote><p><code>WXSS</code> 和 <code>CSS</code> 类似，不过在 <code>CSS</code> 的基础上做了一些补充和修改</p></blockquote><ul><li>尺寸单位 <code>rpx</code></li></ul><p><code>rpx</code> 是响应式像素,可以根据屏幕宽度进行自适应。规定屏幕宽为 <code>750rpx</code>。如在 <code>iPhone6</code> 上，屏幕宽度为 <code>375px</code>，共有 <code>750</code> 个物理像素，则 <code>750rpx = 375px = 750</code> 物理像素</p><ul><li>使用 <code>@import</code> 标识符来导入外联样式。<code>@import</code> 后跟需要导入的外联样式表的相对路径，用;表示语句结束</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** index.wxss **/</span></span><br><span class="line"><span class="keyword">@import</span> <span class="string">&#x27;./base.wxss&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line">    <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="7-小程序页面间有哪些传递数据的方法"><a href="#7-小程序页面间有哪些传递数据的方法" class="headerlink" title="7. 小程序页面间有哪些传递数据的方法"></a>7. 小程序页面间有哪些传递数据的方法</h5><ul><li>使用全局变量实现数据传递</li></ul><p>在 <code>app.js</code> 文件中定义全局变量 <code>globalData</code>， 将需要存储的信息存放在里面</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// app.js</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">App</span>(&#123;</span><br><span class="line">     <span class="comment">// 全局变量</span></span><br><span class="line">  <span class="attr">globalData</span>: &#123;</span><br><span class="line">    <span class="attr">userInfo</span>: <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>使用的时候，直接使用 <code>getApp()</code> 拿到存储的信息</p><ul><li>使用 <code>wx.navigateTo</code> 与 <code>wx.redirectTo</code> 的时候，可以将部分数据放在 <code>url</code> 里面，并在新页面 <code>onLoad</code> 的时候初始化</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//pageA.js</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Navigate</span></span><br><span class="line">wx.<span class="title function_">navigateTo</span>(&#123;</span><br><span class="line">  <span class="attr">url</span>: <span class="string">&#x27;../pageD/pageD?name=raymond&amp;gender=male&#x27;</span>,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Redirect</span></span><br><span class="line">wx.<span class="title function_">redirectTo</span>(&#123;</span><br><span class="line">  <span class="attr">url</span>: <span class="string">&#x27;../pageD/pageD?name=raymond&amp;gender=male&#x27;</span>,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// pageB.js</span></span><br><span class="line">...</span><br><span class="line"><span class="title class_">Page</span>(&#123;</span><br><span class="line">  <span class="attr">onLoad</span>: <span class="keyword">function</span>(<span class="params">option</span>)&#123;<span class="comment">//option里面可以拿到路由参数</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(option.<span class="property">name</span> + <span class="string">&#x27;is&#x27;</span> + option.<span class="property">gender</span>)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setData</span>(&#123;</span><br><span class="line">      <span class="attr">option</span>: option</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>需要注意的问题：</p><p><code>wx.navigateTo</code> 和 <code>wx.redirectTo</code> 不允许跳转到 <code>tab</code> 所包含的页面</p><p><code>onLoad</code> 只执行一次</p><ul><li>使用本地缓存 <code>Storage</code> 相关</li></ul><h5 id="8-小程序的生命周期函数"><a href="#8-小程序的生命周期函数" class="headerlink" title="8. 小程序的生命周期函数"></a>8. 小程序的生命周期函数</h5><ul><li><code>onLoad</code> 页面加载时触发。一个页面只会调用一次，可以在 <code>onLoad</code> 的参数中获取打开当前页面路径中的参数,建议在此调接口</li><li><code>onShow()</code> 页面显示/切入前台时触发，不建议在此调接口</li><li><code>onReady()</code> 页面初次渲染完成时触发。一个页面只会调用一次，代表页面已经准备妥当，可以和视图层进行交互</li><li><code>onHide()</code> 页面隐藏/切入后台时触发。 如 <code>navigateTo</code> 或底部 <code>tab</code> 切换到其他页面，小程序切入后台等</li><li><code>onUnload()</code> 页面卸载时触发。如 <code>redirectTo</code> 或 <code>navigateBack</code> 到其他页面时</li></ul><p>详见 <a href="https://link.zhihu.com/?target=https%3A//developers.weixin.qq.com/miniprogram/dev/framework/app-service/page.html%23生命周期回调函数">生命周期回调函数</a></p><h5 id="9-哪些方法可以用来提高微信小程序的应用速度"><a href="#9-哪些方法可以用来提高微信小程序的应用速度" class="headerlink" title="9. 哪些方法可以用来提高微信小程序的应用速度"></a>9. 哪些方法可以用来提高微信小程序的应用速度</h5><p>1、提高页面加载速度</p><p>2、用户行为预测</p><p>3、减少默认 <code>data</code> 的大小</p><p>4、组件化方案</p><h5 id="10-微信小程序的优劣势"><a href="#10-微信小程序的优劣势" class="headerlink" title="10. 微信小程序的优劣势"></a>10. 微信小程序的优劣势</h5><blockquote><p>优势</p></blockquote><ul><li>即用即走，不用安装，省流量，省安装时间，不占用桌面</li><li>依托微信流量，天生推广传播优势</li><li>开发成本比 <code>App</code> 低</li></ul><blockquote><p>缺点</p></blockquote><ul><li>用户留存，即用即走是优势，也存在一些问题</li><li>入口相对传统 <code>App</code> 要深很多</li><li>限制较多,页面大小不能超过2M。不能打开超过10个层级的页面</li></ul><h5 id="11-怎么解决小程序的异步请求问题"><a href="#11-怎么解决小程序的异步请求问题" class="headerlink" title="11. 怎么解决小程序的异步请求问题"></a>11. 怎么解决小程序的异步请求问题</h5><blockquote><p>小程序支持大部分 <code>ES6</code> 语法</p></blockquote><ul><li>在返回成功的回调里面处理逻辑</li><li><code>Promise</code> 异步</li></ul><h5 id="12-小程序关联微信公众号如何确定用户的唯一性"><a href="#12-小程序关联微信公众号如何确定用户的唯一性" class="headerlink" title="12. 小程序关联微信公众号如何确定用户的唯一性"></a>12. 小程序关联微信公众号如何确定用户的唯一性</h5><blockquote><p>如果开发者拥有多个移动应用、网站应用、和公众帐号（包括小程序），可通过 <code>unionid</code> 来区分用户的唯一性，因为只要是同一个微信开放平台帐号下的移动应用、网站应用和公众帐号（包括小程序），用户的 <code>unionid</code> 是唯一的。换句话说，同一用户，对同一个微信开放平台下的不同应用，<code>unionid</code> 是相同的</p></blockquote><h5 id="13-如何实现下拉刷新"><a href="#13-如何实现下拉刷新" class="headerlink" title="13. 如何实现下拉刷新"></a>13. 如何实现下拉刷新</h5><ul><li>首先在全局 <code>config</code> 中的 <code>window</code> 配置 <code>enablePullDownRefresh</code></li><li>在 <code>Page</code> 中定义 <code>onPullDownRefresh</code> 钩子函数,到达下拉刷新条件后，该钩子函数执行，发起请求方法</li><li>请求返回后，调用 <code>wx.stopPullDownRefresh</code> 停止下拉刷新</li></ul><p>参考 <a href="https://link.zhihu.com/?target=https%3A//juejin.im/post/5a781c756fb9a063606eb742">这里</a></p><h5 id="14-bindtap-和-catchtap-的区别是什么"><a href="#14-bindtap-和-catchtap-的区别是什么" class="headerlink" title="14. bindtap 和 catchtap 的区别是什么"></a>14. bindtap 和 catchtap 的区别是什么</h5><p>相同点：首先他们都是作为点击事件函数，就是点击时触发。在这个作用上他们是一样的，可以不做区分</p><p>不同点：他们的不同点主要是bindtap是不会阻止冒泡事件的，catchtap是阻止冒泡的</p><h5 id="15-简述微信支付的业务流程"><a href="#15-简述微信支付的业务流程" class="headerlink" title="15. 简述微信支付的业务流程"></a>15. 简述微信支付的业务流程</h5><ul><li><p>步骤1：用户在商户APP中选择商品，提交订单，选择微信支付。</p></li><li><p>步骤2：商户后台收到用户支付单，调用微信支付统一下单接口。参见<a href="https://pay.weixin.qq.com/wiki/doc/api/app/app.php?chapter=9_1">统一下单API</a>。</p></li><li><p>步骤3：统一下单接口返回正常的prepay_id，再按签名规范重新生成签名后，将数据传输给APP。参与签名的字段名为<code>appid</code>，<code>partnerid</code>，<code>prepayid</code>，<code>noncestr</code>，<code>timestamp</code>，<code>package</code>。注意：package的值格式为<code>Sign=WXPay</code></p></li><li><p>步骤4：商户APP调起微信支付。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">wx.<span class="title function_">requestPayment</span>(&#123;</span><br><span class="line">  <span class="attr">timeStamp</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">  <span class="attr">nonceStr</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">  <span class="attr">package</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">  <span class="attr">signType</span>: <span class="string">&#x27;MD5&#x27;</span>,</span><br><span class="line">  <span class="attr">paySign</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">  success (res) &#123; &#125;,</span><br><span class="line">  fail (res) &#123; &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>步骤5：商户后台接收支付通知。<code>api</code>参见<a href="https://pay.weixin.qq.com/wiki/doc/api/app/app.php?chapter=9_7">支付结果通知API</a></p></li><li><p>步骤6：商户后台查询支付结果。，<code>api</code>参见<a href="https://pay.weixin.qq.com/wiki/doc/api/app/app.php?chapter=9_2">查询订单API</a>（查单实现可参考：<a href="https://pay.weixin.qq.com/wiki/doc/api/app/app.php?chapter=23_9&amp;index=1">支付回调和查单实现指引</a>） 详情参考<a href="https://pay.weixin.qq.com/wiki/doc/api/app/app.php?chapter=8_3">这里</a></p></li></ul><h5 id="16-什么是小程序自定义组件样式隔离-他有哪几种隔离模式？"><a href="#16-什么是小程序自定义组件样式隔离-他有哪几种隔离模式？" class="headerlink" title="16. 什么是小程序自定义组件样式隔离,他有哪几种隔离模式？"></a>16. 什么是小程序自定义组件样式隔离,他有哪几种隔离模式？</h5><p>默认情况下，自定义组件的样式只受到自定义组件 wxss 的影响。除非以下两种情况：</p><ul><li><code>app.wxss</code> 或页面的 <code>wxss</code> 中使用了标签名选择器（或一些其他特殊选择器）来直接指定样式，这些选择器会影响到页面和全部组件。通常情况下这是不推荐的做法。</li><li>指定特殊的样式隔离选项 <code>styleIsolation</code> 。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Component</span>(&#123;</span><br><span class="line">  <span class="attr">options</span>: &#123;</span><br><span class="line">    <span class="attr">styleIsolation</span>: <span class="string">&#x27;isolated&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><a href="https://developers.weixin.qq.com/s/xPQhJcm37e7h">在开发者工具中预览效果</a></p><p><code>styleIsolation</code> 选项从基础库版本 <a href="https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html">2.6.5</a> 开始支持。它支持以下取值：</p><ul><li><code>isolated</code> 表示启用样式隔离，在自定义组件内外，使用 class 指定的样式将不会相互影响（一般情况下的默认值）；</li><li><code>apply-shared</code> 表示页面 wxss 样式将影响到自定义组件，但自定义组件 wxss 中指定的样式不会影响页面；</li><li><code>shared</code> 表示页面 wxss 样式将影响到自定义组件，自定义组件 wxss 中指定的样式也会影响页面和其他设置了 <code>apply-shared</code> 或 <code>shared</code> 的自定义组件。（这个选项在插件中不可用。）</li></ul><h5 id="17-在小程序中又哪些方法让图片宽高比例保持不变？"><a href="#17-在小程序中又哪些方法让图片宽高比例保持不变？" class="headerlink" title="17. 在小程序中又哪些方法让图片宽高比例保持不变？"></a>17. 在小程序中又哪些方法让图片宽高比例保持不变？</h5><ul><li><p>使用mode：widthFix</p><blockquote><p><code>widthFix</code>：宽度不变，高度自动变化，保持原图宽高比不变。 首先我们先设置image的mode为<code>widthFix</code>，然后给图片加一个固定<code>rpx</code>的宽度，比如：<code>730rpx</code>。 这样图片也可以自适应了。。因为小程序的<code>rpx</code>本身就是一个自适应显示的单位</p></blockquote></li></ul><h5 id="18-小程序组件传参-父子，子父"><a href="#18-小程序组件传参-父子，子父" class="headerlink" title="18. 小程序组件传参(父子，子父)"></a>18. 小程序组件传参(父子，子父)</h5><ul><li><p>父传子</p><blockquote><p>自定义属性，属性的值来自声明式变量 子组件通过props接收</p></blockquote></li><li><p>子传父</p><blockquote><p>自定义事件，父组件通过事件接收子组件传过来的值 自定义封装组件的例子：</p></blockquote></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&lt;component-tag-name inner-text=<span class="string">&quot;Some text&quot;</span>&gt;&lt;/component-tag-name&gt;</span><br><span class="line"><span class="title class_">Component</span>(&#123;</span><br><span class="line">  <span class="attr">properties</span>: &#123;</span><br><span class="line">    <span class="comment">// 这里定义了 innerText 属性，属性值可以在组件使用时指定</span></span><br><span class="line">    <span class="attr">innerText</span>: &#123;</span><br><span class="line">      <span class="attr">type</span>: <span class="title class_">String</span>,</span><br><span class="line">      <span class="attr">value</span>: <span class="string">&#x27;default value&#x27;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">data</span>: &#123;</span><br><span class="line">    <span class="comment">// 这里是一些组件内部数据</span></span><br><span class="line">    <span class="attr">someData</span>: &#123;&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">methods</span>: &#123;</span><br><span class="line">    <span class="comment">// 这里是一个自定义方法</span></span><br><span class="line">    <span class="attr">customMethod</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;component-tag-name <span class="attr">bind</span>:myevent=<span class="string">&quot;onMyEvent&quot;</span> /&gt;</span><br><span class="line"><span class="title class_">Component</span>(&#123;</span><br><span class="line">  <span class="attr">properties</span>: &#123;&#125;,</span><br><span class="line">  <span class="attr">methods</span>: &#123;</span><br><span class="line">    <span class="attr">onTap</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">      <span class="keyword">var</span> myEventDetail = &#123;&#125; <span class="comment">// detail对象，提供给事件监听函数</span></span><br><span class="line">      <span class="keyword">var</span> myEventOption = &#123;&#125; <span class="comment">// 触发事件的选项</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">triggerEvent</span>(<span class="string">&#x27;myevent&#x27;</span>, myEventDetail, myEventOption)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h5 id="19-小程序组件生命周期"><a href="#19-小程序组件生命周期" class="headerlink" title="19. 小程序组件生命周期"></a>19. 小程序组件生命周期</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Component</span>(&#123;</span><br><span class="line">  <span class="attr">lifetimes</span>: &#123;</span><br><span class="line">    <span class="attr">attached</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="comment">// 在组件实例进入页面节点树时执行</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">detached</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="comment">// 在组件实例被从页面节点树移除时执行</span></span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 以下是旧式的定义方式，可以保持对 &lt;2.2.3 版本基础库的兼容</span></span><br><span class="line">  <span class="attr">attached</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 在组件实例进入页面节点树时执行</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">detached</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 在组件实例被从页面节点树移除时执行</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><img src="%E7%AC%94%E8%AE%B0.assets/image-20230221093255673.png" alt="image-20230221093255673"></p><h5 id="20-小程序页面生命周期"><a href="#20-小程序页面生命周期" class="headerlink" title="20. 小程序页面生命周期"></a>20. 小程序页面生命周期</h5><ul><li>1、小程序注册完成后，加载页面，触发<code>onLoad</code>方法，一个页面只会调用一次。</li><li>2、页面载入后触发<code>onShow</code>方法，显示页面，每次打开页面都会调用一次。</li><li>3、首次显示页面，会触发<code>onReady</code>方法，渲染页面元素和样式，一个页面只会调用一次。</li><li>4、当小程序后台运行或跳转到其他页面时，触发<code>onHide</code>方法。</li><li>5、当小程序有后台进入到前台运行或重新进入页面时，触发<code>onShow</code>方法。</li><li>6、当使用重定向方法<code>wx.redirectTo(OBJECT)</code>或关闭当前页返回上一页<code>wx.navigateBack()</code>，触发<code>onUnload</code></li></ul><h5 id="21-小程序怎么样实现路由传参"><a href="#21-小程序怎么样实现路由传参" class="headerlink" title="21. 小程序怎么样实现路由传参"></a>21. 小程序怎么样实现路由传参</h5><ul><li><p>wx.navigateTo</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wx.<span class="title function_">navigateTo</span>(&#123;</span><br><span class="line">    <span class="attr">url</span>: <span class="string">&#x27;../placeIntroduce/placeIntroduce?placeId=2&#x27;</span>,<span class="comment">//在路径后面拼接</span></span><br><span class="line">  &#125;)</span><br><span class="line">    另外一个页面通过<span class="title function_">onload</span>(options)这个生命周期获取到placeId</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">- wx.redirectTo</span><br><span class="line">  </span><br><span class="line">  ```js</span><br><span class="line">wx.redirectTo （非 tabBar 的页面的路径，不能返回来，不限层）</span><br><span class="line">  wx.redirectTo (&#123;</span><br><span class="line">  url: &#x27;../placeIntroduce/placeIntroduce?placeId=2&#x27;,//在路径后面拼接</span><br></pre></td></tr></table></figure></li></ul><h5 id="22-小程序中的路由跳转switchTab-navigateTo-redirectTo的区别"><a href="#22-小程序中的路由跳转switchTab-navigateTo-redirectTo的区别" class="headerlink" title="22. 小程序中的路由跳转switchTab navigateTo redirectTo的区别"></a>22. 小程序中的路由跳转switchTab navigateTo redirectTo的区别</h5><ul><li>wx.navigateTo()：保留当前页面，跳转到应用内的某个页面。但是不能跳到 <code>tabbar</code> 页面</li><li>wx.redirectTo()：关闭当前页面，跳转到应用内的某个页面。但是不允许跳转到 <code>tabbar</code> 页面</li><li>wx.switchTab()：跳转到 <code>abBar</code> 页面，并关闭其他所有非 <code>tabBar</code> 页面</li><li>wx.navigateBack()关闭当前页面，返回上一页面或多级页面。可通过 <code>getCurrentPages()</code> 获取当前的页面栈，决定需要返回几层</li><li>wx.reLaunch()：关闭所有页面，打开到应用内的某个页面</li></ul><h5 id="23-小程序tabbar实现原理"><a href="#23-小程序tabbar实现原理" class="headerlink" title="23. 小程序tabbar实现原理"></a>23. 小程序tabbar实现原理</h5><ul><li><p>要实现tabbar的导航条其实很简单，我们要实现全局的tabbar只需要在app.json文件中定义即可，局部的就在局部的tabbar文件中实现。</p><blockquote><p>来看看app.json代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line"><span class="attr">pages</span>: [</span><br><span class="line">  <span class="string">&#x27;pages/index/index&#x27;</span>,</span><br><span class="line">  <span class="string">&quot;pages/search/search&quot;</span>,</span><br><span class="line">  <span class="string">&#x27;pages/news/news&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;pages/attention/attention&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;pages/collect/collect&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;pages/comment/comment&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;pages/my/my&#x27;</span>,</span><br><span class="line">  <span class="string">&quot;pages/detail/detail&quot;</span>,</span><br><span class="line">  <span class="string">&quot;pages/chat/chat&quot;</span>,</span><br><span class="line">],</span><br><span class="line"><span class="attr">window</span>: &#123;</span><br><span class="line">  <span class="attr">backgroundTextStyle</span>: <span class="string">&#x27;light&#x27;</span>,</span><br><span class="line">  <span class="attr">navigationBarBackgroundColor</span>: <span class="string">&#x27;#fff&#x27;</span>,</span><br><span class="line">  <span class="attr">navigationBarTitleText</span>: <span class="string">&#x27;小红书&#x27;</span>,</span><br><span class="line">  <span class="attr">navigationBarTextStyle</span>: <span class="string">&#x27;black&#x27;</span>,</span><br><span class="line">  <span class="attr">enablePullDownRefresh</span>: <span class="literal">true</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">tabBar</span>: &#123;</span><br><span class="line">  <span class="string">&quot;list&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">&quot;pagePath&quot;</span>: <span class="string">&quot;pages/index/index&quot;</span>,</span><br><span class="line">      <span class="string">&quot;text&quot;</span>: <span class="string">&quot;首页&quot;</span>,</span><br><span class="line">      <span class="string">&quot;iconPath&quot;</span>: <span class="string">&quot;assets/tabbar/1.png&quot;</span>,</span><br><span class="line">      <span class="string">&quot;selectedIconPath&quot;</span>: <span class="string">&quot;assets/tabbar/2.png&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">&quot;pagePath&quot;</span>: <span class="string">&quot;pages/news/news&quot;</span>,</span><br><span class="line">      <span class="string">&quot;text&quot;</span>: <span class="string">&quot;消息&quot;</span>,</span><br><span class="line">      <span class="string">&quot;iconPath&quot;</span>: <span class="string">&quot;assets/tabbar/news1.png&quot;</span>,</span><br><span class="line">      <span class="string">&quot;selectedIconPath&quot;</span>: <span class="string">&quot;assets/tabbar/news2.png&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">&quot;pagePath&quot;</span>: <span class="string">&quot;pages/my/my&quot;</span>,</span><br><span class="line">      <span class="string">&quot;text&quot;</span>: <span class="string">&quot;我的&quot;</span>,</span><br><span class="line">      <span class="string">&quot;iconPath&quot;</span>: <span class="string">&quot;assets/tabbar/3.png&quot;</span>,</span><br><span class="line">      <span class="string">&quot;selectedIconPath&quot;</span>: <span class="string">&quot;assets/tabbar/4.png&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">permission</span>: &#123;</span><br><span class="line">  <span class="string">&quot;scope.userLocation&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;desc&quot;</span>: <span class="string">&quot;为了更好的为你服务，请允许访问你的地址&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考<a href="https://www.cnblogs.com/izhaofu/p/6278589.html">这里</a></p></blockquote></li></ul><h5 id="24-小程序性能为什么那么好，为什么能做到即用即走的效果"><a href="#24-小程序性能为什么那么好，为什么能做到即用即走的效果" class="headerlink" title="24. 小程序性能为什么那么好，为什么能做到即用即走的效果"></a>24. 小程序性能为什么那么好，为什么能做到即用即走的效果</h5><ul><li>因为是轻量级的，代码包体积限制在2M以内，如果超过2M还可以进行分包，提高性能优化</li><li>运行在微信端,很多功能只需要使用API来实现，就可以实现跟APP的一样的功能</li><li>是基于微信宿主环境的，微信客户端提供双线程去执行wxml, wxss, js文件，让小程序可以快速的一下将数据渲染出来呈现在用户的面前</li></ul><h4 id="十-网络面试真题"><a href="#十-网络面试真题" class="headerlink" title="十. 网络面试真题"></a>十. 网络面试真题</h4><h5 id="1-url从输入到渲染页面的全过程"><a href="#1-url从输入到渲染页面的全过程" class="headerlink" title="1. url从输入到渲染页面的全过程"></a>1. url从输入到渲染页面的全过程</h5><ul><li>浏览器构建HTTP Request请求， DNS解析URL地址、生成HTTP请求报文、构建TCP连接、使用IP协议选择传输路线</li><li>将请求通过网络传输到服务端 从客户机到服务器需要通过许多网络设备，一般包括集线器、交换器、路由器等</li><li>服务器构建HTTP Response响应，响应客户端的请求</li><li>将响应体的数据通过网络传输返回给客户端</li><li>浏览器渲染页面 解析HTML、CSS、JS，生成RenderTree渲染页面</li></ul><h5 id="2-tcp三次握手，四次挥手，可靠传输原理"><a href="#2-tcp三次握手，四次挥手，可靠传输原理" class="headerlink" title="2. tcp三次握手，四次挥手，可靠传输原理"></a>2. tcp三次握手，四次挥手，可靠传输原理</h5><h6 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h6><ul><li><p>第一次握手：客户端发送syn报文，并发送seq为x序列号给服务端，等待服务端的确认。</p></li><li><p>第二次握手：服务端发送syn+ack报文，并发送seq为Y的序列号，在确认序列号为x+1</p></li><li><p>第三次握手：客户端发送ack报文，并发送seq序列号为z，在确认序列号为y+1</p><p>四次挥手</p></li><li><p>第一次挥手：先由客户端向服务器端发送一个FIN，请求关闭数据传输。</p></li><li><p>第二次挥手：当服务器接收到客户端的FIN时，向客户端发送一个ACK，其中ack的值等于FIN+SEQ</p></li><li><p>第三次挥手：然后服务器向客户端发送一个FIN，告诉客户端应用程序关闭。</p></li><li><p>第四次挥手：当客户端收到服务器端的FIN是，回复一个ACK给服务器端。其中ack的值等于FIN+SEQ</p></li></ul><h5 id="3-http200-和-302-的区别"><a href="#3-http200-和-302-的区别" class="headerlink" title="3. http200 和 302 的区别"></a>3. <code>http200</code> 和 <code>302</code> 的区别</h5><ul><li>http_200的意思是 成功处理了请求</li><li>http_302的意思是（临时移动）服务器目前从不同位置的网页响应请求， 但请求者应继续使用原有位置来进行以后的请求。</li></ul><h5 id="4-你知道哪些http首部字段？"><a href="#4-你知道哪些http首部字段？" class="headerlink" title="4. 你知道哪些http首部字段？"></a>4. 你知道哪些http首部字段？</h5><div class="table-container"><table><thead><tr><th>首部字段名</th><th>说明</th></tr></thead><tbody><tr><td>Cache-Control</td><td>控制缓存的行为</td></tr><tr><td>Connection</td><td>逐跳首部、连接的管理</td></tr><tr><td>Date</td><td>创建报文的日期时间</td></tr><tr><td>Program</td><td>报文指令</td></tr><tr><td>Trailer</td><td>报文末端的首部一览</td></tr><tr><td>Transfer-Encoding</td><td>指定报文主体的传输编码方式</td></tr><tr><td>Upgrade</td><td>升级为其他协议</td></tr><tr><td>Via</td><td>代理服务器的相关信息</td></tr><tr><td>Warning</td><td>错误通知</td></tr><tr><td>Authorization</td><td>Web认证信息</td></tr></tbody></table></div><h5 id="5-说一下http缓存策略，有什么区别，分别解决了什么问题？"><a href="#5-说一下http缓存策略，有什么区别，分别解决了什么问题？" class="headerlink" title="5. 说一下http缓存策略，有什么区别，分别解决了什么问题？"></a>5. 说一下http缓存策略，有什么区别，分别解决了什么问题？</h5><p>浏览器每次发起请求时，先在本地缓存中查找结果以及缓存标识，根据缓存标识来判断是否使用本地缓存, 如果缓存有效，则使用本地缓存。<br>向服务器发起请求并携带缓存标识。根据是否需向服务器发起HTTP请求， 将缓存过程划分为两个部分：强制缓存和协商缓存，强缓优先于协商缓存。</p><ul><li>强缓存，服务器通知浏览器一个缓存时间，在缓存时间内，下次请求，直接用缓存，不在时间内，执行比较缓存策略。</li><li>协商缓存，让客户端与服务器之间能实现缓存文件是否更新的验证、提升缓存的复用率， 将缓存信息中的Etag和Last-Modified,通过请求发送给服务器，由服务器校验，返回304状态码时，浏览器直接使用缓存。</li><li>解决问题<br>1.减少了冗余的数据传输<br>2.减少了服务器的负担，大大提升了网站的性能<br>3.加快了客户端加载网页的速度<br><img src="https://img-blog.csdnimg.cn/20200712001807223.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3h1ODM4MjA5NDkw,size_16,color_FFFFFF,t_70" alt="avatar"> </li></ul><h5 id="6-为什么浏览器要限制TCP的最大个数"><a href="#6-为什么浏览器要限制TCP的最大个数" class="headerlink" title="6. 为什么浏览器要限制TCP的最大个数"></a>6. 为什么浏览器要限制TCP的最大个数</h5><ul><li><p>建立一个tcp连接需要：1，socket文件描述符；2，IP地址；3，端口；4，内存</p></li><li><p>1、内存资源： 一个tcp连接最小占用内存为4096+4096 = 8k， 那么对于一个8G内存的机器，在不考虑其他限制下， 最多支持的并发量为：810241024/8 约等于100万， 在实际中，由于linux kernel对一些资源的限制， 加上程序的业务处理，所以，8G内存是很难达到100万连接的</p></li><li><p>2、CPU资源</p></li></ul><h5 id="7-HTTP2-0的特点"><a href="#7-HTTP2-0的特点" class="headerlink" title="7. HTTP2.0的特点"></a>7. HTTP2.0的特点</h5><p>  HTTP2.0大幅度的提高了web性能，在HTTP1.1完全语意兼容的基础上，进一步减少了网络的延迟。</p><p>  1、二进制分帧</p><p>  2、多路复用</p><p>  3、首部压缩</p><p>  4、流量控制</p><p>  5、请求优先级</p><p>  6、服务器推送</p><h5 id="8-说一下HTTP2-多路复用原理，以及多路复用优势？"><a href="#8-说一下HTTP2-多路复用原理，以及多路复用优势？" class="headerlink" title="8. 说一下HTTP2 多路复用原理，以及多路复用优势？"></a>8. 说一下HTTP2 多路复用原理，以及多路复用优势？</h5><p><img src="%E7%AC%94%E8%AE%B0.assets/image-20230221094228708.png" alt="image-20230221094228708"></p><p>HTTP/1.1中的消息是“管道串形化”的：只有等一个消息完成之后，才能进行下一条消息；而HTTP/2中多个消息交织在了一起，这无疑提高了“通信”的效率。这就是多路复用：<strong>在一个HTTP的连接上，多路“HTTP消息”同时工作</strong>。</p><h5 id="9-简述https原理，以及与http的区别"><a href="#9-简述https原理，以及与http的区别" class="headerlink" title="9. 简述https原理，以及与http的区别"></a>9. 简述https原理，以及与http的区别</h5><ul><li><p>HTTP协议工作在80端口，HTTPS协议工作在443端口</p></li><li><p>HTTPS需要申请证书（用于验证服务器身份）</p></li><li><p>HTTP在TCP三次握手建立连接之后即可开始传输数据；HTTPS协议则需要在建立TCP连接之后客户端与服务器在进行SSL加密，确定对话密钥，完成加密后才开始传输数据。</p></li><li><p>HTTPS协议传输是密文，HTTP协议传输是明文</p></li></ul><h5 id="10-CDN-是什么？描述下-CDN-原理？为什么要用-CDN"><a href="#10-CDN-是什么？描述下-CDN-原理？为什么要用-CDN" class="headerlink" title="10. CDN 是什么？描述下 CDN 原理？为什么要用 CDN?"></a>10. CDN 是什么？描述下 CDN 原理？为什么要用 CDN?</h5><p>  CDN的全称是Content Delivery Network，即内容分发网络 共有云厂商在全世界各地都遍布不计其数都数据中心和服务器， CDN服务简单来讲就是这些厂商将你的服务器上面的文档分发到他们不同地区的服务器的当中， 每个地区可以称为一个节点，这样用户在访问你的网址时， 浏览器发送的请求就会优先绕去离客户最近的节点来获取数据， 这样方便客户更快的速度访问网站。 CDN是构建在现有网络基础之上的智能虚拟网络，依靠部署在各地的边缘服务器， 通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容， 降低网络拥塞，提高用户访问响应速度和命中率。CDN的关键技术主要有内容存储和分发技术。</p><h5 id="11-为什么form表单提交没有跨域问题，但ajax有跨域问题"><a href="#11-为什么form表单提交没有跨域问题，但ajax有跨域问题" class="headerlink" title="11.  为什么form表单提交没有跨域问题，但ajax有跨域问题"></a>11.  为什么form表单提交没有跨域问题，但ajax有跨域问题</h5><p>  浏览器的策略本质是：一个域名下面的JS，没有经过允许是不能读取另一个域名的内容，但是浏览器不阻止你向另外一个域名发送请求。 所以form表单提交没有跨域问题，提交form表单到另外一个域名，原来页面是无法获取新页面的内容，或者说form提交后不需要返回，但是ajax是需要返回的。 而ajax是想要读取响应内容，浏览器是不允许你这么做的。 浏览器的安全策略限制的是js脚本，并不限制src，form表单提交之类的请求， 就是说form表单提交不存在安全问题，ajax提交跨域存在安全问题。</p><h4 id="十一-高频算法-排序算法"><a href="#十一-高频算法-排序算法" class="headerlink" title="十一. 高频算法-排序算法"></a>十一. 高频算法-排序算法</h4><h5 id="1-冒泡排序"><a href="#1-冒泡排序" class="headerlink" title="1. 冒泡排序"></a>1. 冒泡排序</h5><blockquote><p>冒泡排序比较所有相邻的两个项，如果第一个比第二个大，则交换它们。元素项向上移动至 正确的顺序，就好像气泡升至表面一样，冒泡排序因此得名。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">bubbleSort</span>(<span class="params">array</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123;</span><br><span class="line">        length</span><br><span class="line">    &#125; = array;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; length - <span class="number">1</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (array[j] &gt; array[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="title function_">swap</span>(array, j, j + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">swap</span>(<span class="params">array, a, b</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> temp = array[a];</span><br><span class="line">    array[a] = array[b];</span><br><span class="line">    array[b] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-选择排序"><a href="#2-选择排序" class="headerlink" title="2. 选择排序"></a>2. 选择排序</h5><blockquote><p>选择排序算法是一种原址比较排序算法。选择排序大致的思路是找到数据结构中的最小值并 将其放置在第一位，接着找到第二小的值并将其放在第二位，以此类推。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">selectionSort</span>(<span class="params">array</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123;</span><br><span class="line">        length</span><br><span class="line">    &#125; = array;</span><br><span class="line">    <span class="keyword">let</span> indexMin;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        indexMin = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = i; j &lt; length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (array[indexMin] &gt; array[j]) &#123;</span><br><span class="line">                indexMin = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i !== indexMin) &#123;</span><br><span class="line">            <span class="title function_">swap</span>(array, i, indexMin);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="3-插入排序"><a href="#3-插入排序" class="headerlink" title="3. 插入排序"></a>3. 插入排序</h5><blockquote><p>插入排序每次排一个数组项，以此方式构建最后的排序数组。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">insertionSort</span>(<span class="params">array</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123;</span><br><span class="line">        length</span><br><span class="line">    &#125; = array;</span><br><span class="line">    <span class="keyword">let</span> temp;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; length; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> j = i;</span><br><span class="line">        temp = array[i];</span><br><span class="line">        <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; array[j - <span class="number">1</span>] &gt; temp) &#123;</span><br><span class="line">            array[j] = array[j - <span class="number">1</span>];</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        array[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="4-归并排序"><a href="#4-归并排序" class="headerlink" title="4. 归并排序"></a>4. 归并排序</h5><blockquote><p>归并排序是一种分而治之算法。其思想是将原始数组切分成较小的数组，直到每个小数组只 有一个位置，接着将小数组归并成较大的数组，直到最后只有一个排序完毕的大数组。</p></blockquote><p><img src="../../JS3/%25E7%25AC%2594%25E8%25AE%25B0/%25E7%25AC%2594%25E8%25AE%25B0.assets/image-20221209111002284.png" alt="image-20221209111002284" style="zoom:67%;" /></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">mergeSort</span>(<span class="params">array</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (array.<span class="property">length</span> &gt; <span class="number">1</span>) &#123; </span><br><span class="line">        <span class="keyword">const</span> &#123;</span><br><span class="line">            length</span><br><span class="line">        &#125; = array;</span><br><span class="line">        <span class="keyword">const</span> middle = <span class="title class_">Math</span>.<span class="title function_">floor</span>(length / <span class="number">2</span>); </span><br><span class="line">        <span class="keyword">const</span> left = <span class="title function_">mergeSort</span>(array.<span class="title function_">slice</span>(<span class="number">0</span>, middle)); </span><br><span class="line">        <span class="keyword">const</span> right = <span class="title function_">mergeSort</span>(array.<span class="title function_">slice</span>(middle, length)); </span><br><span class="line">        array = <span class="title function_">merge</span>(left, right); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">merge</span>(<span class="params">left, right </span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">let</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> result = [];</span><br><span class="line">    <span class="keyword">while</span> (i &lt; left.<span class="property">length</span> &amp;&amp; j &lt; right.<span class="property">length</span>) &#123; </span><br><span class="line">        result.<span class="title function_">push</span>(</span><br><span class="line">            left[i] &lt; right[j] ? left[i++] : right[j++]</span><br><span class="line">        ); </span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(result)</span><br><span class="line">        <span class="comment">//先push ，再++</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result.<span class="title function_">concat</span>(i &lt; left.<span class="property">length</span> ? left.<span class="title function_">slice</span>(i) : right.<span class="title function_">slice</span>(j)); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="5-快速排序"><a href="#5-快速排序" class="headerlink" title="5. 快速排序"></a>5. 快速排序</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">quickSort</span>(<span class="params">arr</span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> &#123;length&#125; = arr</span><br><span class="line">    <span class="keyword">if</span>(length&lt;<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> arr</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> base = arr[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">let</span> min = arr.<span class="title function_">slice</span>(<span class="number">1</span>).<span class="title function_">filter</span>(<span class="function"><span class="params">item</span>=&gt;</span>item&lt;=base)</span><br><span class="line">    <span class="keyword">let</span> max = arr.<span class="title function_">slice</span>(<span class="number">1</span>).<span class="title function_">filter</span>(<span class="function"><span class="params">item</span>=&gt;</span>item&gt;base)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">quickSort</span>(min).<span class="title function_">concat</span>([base]).<span class="title function_">concat</span>(<span class="title function_">quickSort</span>(max))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="6-计数排序"><a href="#6-计数排序" class="headerlink" title="6. 计数排序"></a>6. 计数排序</h5><blockquote><p>计数排序使用一个用来存储每个元素在原始 数组中出现次数的临时数组。在所有元素都计数完成后，临时数组已排好序并可迭代以构建排序 后的结果数组。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">countingSort</span>(<span class="params">array</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (array.<span class="property">length</span> &lt; <span class="number">2</span>) &#123; </span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> maxValue = <span class="title function_">findMaxValue</span>(array);</span><br><span class="line">    <span class="keyword">const</span> counts = <span class="keyword">new</span> <span class="title class_">Array</span>(maxValue + <span class="number">1</span>); </span><br><span class="line">    array.<span class="title function_">forEach</span>(<span class="function"><span class="params">element</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!counts[element]) &#123; </span><br><span class="line">            counts[element] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        counts[element]++; </span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">let</span> sortedIndex = <span class="number">0</span>;</span><br><span class="line">    counts.<span class="title function_">forEach</span>(<span class="function">(<span class="params">count, i</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (count &gt; <span class="number">0</span>) &#123; </span><br><span class="line">            array[sortedIndex++] = i; </span><br><span class="line">            count--; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">findMaxValue</span>(<span class="params">array</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> max = array[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; array.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (array[i] &gt; max) &#123;</span><br><span class="line">            max = array[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">countingSort</span>([<span class="number">5</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">1</span>])</span><br></pre></td></tr></table></figure><h5 id="7-桶排序"><a href="#7-桶排序" class="headerlink" title="7.  桶排序"></a>7.  桶排序</h5><blockquote><p>桶排序（也被称为箱排序）也是分布式排序算法，它将元素分为不同的桶（较小的数组）， 再使用一个简单的排序算法，例如插入排序（用来排序小数组的不错的算法），来对每个桶进行 排序。然后，它将所有的桶合并为结果数组。</p></blockquote><p><img src="%E7%AC%94%E8%AE%B0.assets/image-20221213091612715.png" alt="image-20221213091612715"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">insertSort</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123;</span><br><span class="line">        length</span><br><span class="line">    &#125; = arr</span><br><span class="line">    <span class="keyword">let</span> temp; <span class="comment">//存 当前这一轮对应索引的元素值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; length; i++) &#123;</span><br><span class="line">        temp = arr[i]</span><br><span class="line">        <span class="keyword">let</span> j = i;</span><br><span class="line">        <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; arr[j - <span class="number">1</span>] &gt; temp) &#123;</span><br><span class="line">            arr[j] = arr[j - <span class="number">1</span>]</span><br><span class="line">            j--</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        arr[j] = temp</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(arr)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">bucketSort</span>(<span class="params">array, bucketSize = <span class="number">3</span></span>) &#123; </span><br><span class="line">    <span class="keyword">if</span> (array.<span class="property">length</span> &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> buckets = <span class="title function_">createBuckets</span>(array, bucketSize); </span><br><span class="line">    <span class="comment">//分桶装</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">sortBuckets</span>(buckets); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createBuckets</span>(<span class="params">array, bucketSize</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> minValue = array[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">let</span> maxValue = array[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; array.<span class="property">length</span>; i++) &#123; </span><br><span class="line">        <span class="keyword">if</span> (array[i] &lt; minValue) &#123;</span><br><span class="line">            minValue = array[i];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (array[i] &gt; maxValue) &#123;</span><br><span class="line">            maxValue = array[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="comment">//一次循环找到最小最大值</span></span><br><span class="line">    <span class="keyword">const</span> bucketCount = <span class="title class_">Math</span>.<span class="title function_">floor</span>((maxValue - minValue) / bucketSize) + <span class="number">1</span>; <span class="comment">// 最后一个索引+1</span></span><br><span class="line">    <span class="keyword">const</span> buckets = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; bucketCount; i++) &#123;</span><br><span class="line">        buckets[i] = [];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; array.<span class="property">length</span>; i++) &#123; </span><br><span class="line">        <span class="keyword">const</span> bucketIndex = <span class="title class_">Math</span>.<span class="title function_">floor</span>((array[i] - minValue) / bucketSize); </span><br><span class="line">        buckets[bucketIndex].<span class="title function_">push</span>(array[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> buckets;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sortBuckets</span>(<span class="params">buckets</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> sortedArray = []; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; buckets.<span class="property">length</span>; i++) &#123; </span><br><span class="line">        <span class="keyword">if</span> (buckets[i] != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="title function_">insertSort</span>(buckets[i]); </span><br><span class="line">            sortedArray.<span class="title function_">push</span>(...buckets[i]); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sortedArray;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">bucketSort</span>([<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">7</span>,<span class="number">10</span>,<span class="number">9</span>,<span class="number">8</span>])</span><br></pre></td></tr></table></figure><h5 id="8-基数排序"><a href="#8-基数排序" class="headerlink" title="8. 基数排序"></a>8. 基数排序</h5><blockquote><p>基数排序也是一个分布式排序算法，它根据数字的有效位或基数（这也是它为什么叫基数排 序）将整数分布到桶中。基数是基于数组中值的记数制的。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">35</span>, <span class="number">2</span>, <span class="number">26</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">34</span>, <span class="number">1</span>, <span class="number">56</span>, <span class="number">99</span>, <span class="number">33</span>];</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">radixSort</span> = (<span class="params">arr = []</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> base = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">let</span> divider = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> maxVal = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (divider === <span class="number">1</span> || divider &lt;= maxVal) &#123;</span><br><span class="line">        <span class="keyword">const</span> buckets = [...<span class="title class_">Array</span>(<span class="number">10</span>)].<span class="title function_">map</span>(<span class="function">() =&gt;</span> []);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> val <span class="keyword">of</span> arr) &#123;</span><br><span class="line">            buckets[<span class="title class_">Math</span>.<span class="title function_">floor</span>((val / divider) % base)].<span class="title function_">push</span>(val);</span><br><span class="line">            maxVal = val &gt; maxVal ? val : maxVal;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        arr = [].<span class="title function_">concat</span>(...buckets);</span><br><span class="line"></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(arr)</span><br><span class="line">        divider *= base;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="十二-高频算法-搜索算法"><a href="#十二-高频算法-搜索算法" class="headerlink" title="十二. 高频算法-搜索算法"></a>十二. 高频算法-搜索算法</h4><h5 id="1-顺序搜索"><a href="#1-顺序搜索" class="headerlink" title="1. 顺序搜索"></a>1. 顺序搜索</h5><blockquote><p>顺序或线性搜索是最基本的搜索算法。它的机制是，将每一个数据结构中的元素和我们要找 的元素做比较。顺序搜索是最低效的一种搜索算法。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sequentialSearch</span>(<span class="params">array, value</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; array.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (value===array[i]) &#123; </span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">sequentialSearch</span>([<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>],<span class="number">2</span>)</span><br></pre></td></tr></table></figure><h5 id="2-二分搜索"><a href="#2-二分搜索" class="headerlink" title="2.二分搜索"></a>2.二分搜索</h5><p><img src="../../JS3/%25E7%25AC%2594%25E8%25AE%25B0/%25E7%25AC%2594%25E8%25AE%25B0.assets/image-20221214083405056.png" alt="image-20221214083405056" style="zoom:80%;float:left;" /></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">Arr</span> = [<span class="number">5</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">9</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">binarySearch</span>(<span class="params">find, arr, low, high</span>) &#123;</span><br><span class="line">    arr = <span class="title function_">quickSort</span>(arr);</span><br><span class="line">    <span class="keyword">if</span> (low &lt;= high) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[low] == find) &#123;</span><br><span class="line">            <span class="keyword">return</span> low;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (arr[high] == find) &#123;</span><br><span class="line">            <span class="keyword">return</span> high;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> mid = <span class="title class_">Math</span>.<span class="title function_">ceil</span>((high + low) / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span> (arr[mid] == find) &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[mid] &gt; find) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="title function_">binarySearch</span>(find, arr, low, mid - <span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="title function_">binarySearch</span>(find, arr, mid + <span class="number">1</span>, high);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">binarySearch</span>(<span class="number">9</span>, <span class="title class_">Arr</span>, <span class="number">0</span>, <span class="title class_">Arr</span>.<span class="property">length</span> - <span class="number">1</span>)</span><br></pre></td></tr></table></figure><h5 id="3-内插搜索"><a href="#3-内插搜索" class="headerlink" title="3.内插搜索"></a>3.内插搜索</h5><blockquote><p>内插搜索是改良版的二分搜索。二分搜索总是检查 mid 位置上的值，而内插搜索可能会根 据要搜索的值检查数组中的不同地方。</p></blockquote><p><img src="../../JS3/%25E7%25AC%2594%25E8%25AE%25B0/%25E7%25AC%2594%25E8%25AE%25B0.assets/image-20221214090414035.png" alt="image-20221214090414035" style="zoom:80%;float:left;" /></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">5</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">9</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">InsertionSearch</span>(<span class="params">arr, val, start, end</span>) &#123;</span><br><span class="line">    arr = <span class="title function_">quickSort</span>(arr);</span><br><span class="line">    <span class="keyword">var</span> end = end || arr.<span class="property">length</span> - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">var</span> start = start || <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (start &lt;= end &amp;&amp; val&gt;=arr[start] &amp;&amp; val&lt;=arr[end]) &#123;</span><br><span class="line">        <span class="keyword">var</span> mid = start + <span class="title class_">Math</span>.<span class="title function_">floor</span>((val - arr[start]) / (arr[end] - arr[start]) * (end - start))</span><br><span class="line">        <span class="keyword">if</span> (arr[mid] == val) &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (arr[mid] &gt; val) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="title class_">InsertionSearch</span>(arr, val, start, mid - <span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="title class_">InsertionSearch</span>(arr, val, mid + <span class="number">1</span>, end);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">InsertionSearch</span>(arr, <span class="number">2</span>)</span><br></pre></td></tr></table></figure><h4 id="十三-高频算法-随机算法"><a href="#十三-高频算法-随机算法" class="headerlink" title="十三. 高频算法-随机算法"></a>十三. 高频算法-随机算法</h4><blockquote><p>迭代数组，从最后一位开始并将当前位置和一个随机位置进行交换。这个随机位 置比当前位置小。这样，这个算法可以保证随机过的位置不会再被随机一次</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">shuffle</span>(<span class="params">array</span>) &#123;</span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">let</span> i = array.<span class="property">length</span> - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line"> <span class="keyword">const</span> randomIndex = <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * (i + <span class="number">1</span>));</span><br><span class="line"> <span class="title function_">swap</span>(array, i, randomIndex);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> array;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h4 id="十四-高频算法-算法设计"><a href="#十四-高频算法-算法设计" class="headerlink" title="十四. 高频算法-算法设计"></a>十四. 高频算法-算法设计</h4><h5 id="1-分而治之"><a href="#1-分而治之" class="headerlink" title="1.分而治之"></a>1.分而治之</h5><blockquote><p>分而 治之是算法设计中的一种方法。它将一个问题分成多个和原问题相似的小问题，递归解决小问题， 再将解决方式合并以解决原来的问题。</p></blockquote><p>分而治之算法可以分成三个部分。</p><p> (1) 分解原问题为多个子问题（原问题的多个小实例）。 </p><p> (2) 解决子问题，用返回解决子问题的方式的递归算法。递归算法的基本情形可以用来解决子 问题。</p><p> (3) 组合这些子问题的解决方式，得到原问题的解。</p><h5 id="2-动态规划"><a href="#2-动态规划" class="headerlink" title="2.动态规划"></a>2.动态规划</h5><blockquote><p>动态规划（dynamic programming，DP）是一种将复杂问题分解成更小的子问题来解决的优 化技术。</p></blockquote><p>用动态规划解决问题时，要遵循三个重要步骤：</p><p> (1) 定义子问题；</p><p> (2) 实现要反复执行来解决子问题的部分； </p><p>(3) 识别并求解出基线条件。</p><h6 id="2-1-背包问题"><a href="#2-1-背包问题" class="headerlink" title="2-1 背包问题"></a>2-1 背包问题</h6><blockquote><p>背包问题是一个组合优化问题。它可以描述如下：给定一个固定大小、能够携重量 W 的背 包，以及一组有价值和重量的物品，找出一个最佳解决方案，使得装入背包的物品总重量不超过 W，且总价值最大。</p></blockquote><p><img src="../../JS3/%25E7%25AC%2594%25E8%25AE%25B0/%25E7%25AC%2594%25E8%25AE%25B0.assets/image-20221220150040895.png" alt="image-20221220150040895" style="zoom:67%;float:left;" /></p><p><img src="../../JS3/%25E7%25AC%2594%25E8%25AE%25B0/%25E7%25AC%2594%25E8%25AE%25B0.assets/image-20221220154547224.png" alt="image-20221220154547224" style="zoom:67%;float:left;" /></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">knapSack</span>(<span class="params">weights, values, W</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> n = weights.<span class="property">length</span>;</span><br><span class="line">    <span class="keyword">var</span> f = <span class="keyword">new</span> <span class="title class_">Array</span>(n)</span><br><span class="line">    f[-<span class="number">1</span>] = <span class="keyword">new</span> <span class="title class_">Array</span>(W + <span class="number">1</span>).<span class="title function_">fill</span>(<span class="number">0</span>)<span class="comment">//第-1个物品，</span></span><br><span class="line">    <span class="comment">//负一行的出现可以大大减少了在双层循环的分支判定。</span></span><br><span class="line">    <span class="comment">// console.log(f)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; n; i++) &#123; </span><br><span class="line">        f[i] = <span class="keyword">new</span> <span class="title class_">Array</span>(W).<span class="title function_">fill</span>(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt;= W; j++) &#123; </span><br><span class="line">            <span class="keyword">if</span> (j &lt; weights[i]) &#123; </span><br><span class="line">                f[i][j] = f[i - <span class="number">1</span>][j]</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                f[i][j] = <span class="title class_">Math</span>.<span class="title function_">max</span>(f[i - <span class="number">1</span>][j], f[i - <span class="number">1</span>][j - weights[i]] + values[i]); <span class="comment">//case 3</span></span><br><span class="line">            &#125;<span class="comment">//即使i = 0 也不怕，i-1 为-1 有-1行不怕</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f[n - <span class="number">1</span>][W]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="2-2-最长公共子序列"><a href="#2-2-最长公共子序列" class="headerlink" title="2-2 最长公共子序列"></a>2-2 最长公共子序列</h6><blockquote><p>找出两个字符 串序列的最长子序列的长度。最长子序列是指，在两个字符串序列中以相同顺序出现，但不要求 连续（非字符串子串）的字符串序列。</p></blockquote><p><img src="../../JS3/%25E7%25AC%2594%25E8%25AE%25B0/%25E7%25AC%2594%25E8%25AE%25B0.assets/image-20221221131801017.png" alt="image-20221221131801017" style="zoom:67%;float:left" /></p><p><img src="../../JS3/%25E7%25AC%2594%25E8%25AE%25B0/%25E7%25AC%2594%25E8%25AE%25B0.assets/image-20221221131809239.png" alt="image-20221221131809239" style="zoom:67%;float:left" /></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">LCS</span>(<span class="params">str1, str2</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> m = str1.<span class="property">length</span></span><br><span class="line">    <span class="keyword">var</span> n = str2.<span class="property">length</span></span><br><span class="line">    <span class="keyword">var</span> dp = [<span class="keyword">new</span> <span class="title class_">Array</span>(n + <span class="number">1</span>).<span class="title function_">fill</span>(<span class="number">0</span>)] <span class="comment">//第一行全是0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123; <span class="comment">//一共有m+1行</span></span><br><span class="line">        dp[i] = [<span class="number">0</span>] <span class="comment">//第一列全是0</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123; <span class="comment">//一共有n+1列</span></span><br><span class="line">            <span class="keyword">if</span> (str1[i - <span class="number">1</span>] === str2[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="comment">//注意这里，str1的第一个字符是在第二列中，因此要减1，str2同理</span></span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span> <span class="comment">//对角＋1</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j] = <span class="title class_">Math</span>.<span class="title function_">max</span>(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>])</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[m][n];</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">LCS</span>(<span class="string">&quot;abcadf&quot;</span>, <span class="string">&quot;acbaed&quot;</span>))</span><br></pre></td></tr></table></figure><h5 id="3-贪心算法"><a href="#3-贪心算法" class="headerlink" title="3. 贪心算法"></a>3. 贪心算法</h5><blockquote><p>在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，他所做出的仅是在某种意义上的局部最优解。贪心算法不是对所有问题都能得到整体最优解，但对范围相当广泛的许多问题他能产生整体最优解或者是整体最优解的近似解。</p></blockquote><p><img src="../../JS3/%25E7%25AC%2594%25E8%25AE%25B0/%25E7%25AC%2594%25E8%25AE%25B0.assets/image-20221226122030597.png" alt="image-20221226122030597" style="zoom:50%;float:left" /></p><p><img src="../../JS3/%25E7%25AC%2594%25E8%25AE%25B0/%25E7%25AC%2594%25E8%25AE%25B0.assets/image-20221226122115470.png" alt="image-20221226122115470" style="zoom: 50%;float:left;" /></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">tanx</span>(<span class="params">capacity, weights, values</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> list = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len = weights.<span class="property">length</span>; i &lt; len; i++) &#123;</span><br><span class="line">        list.<span class="title function_">push</span>(&#123;</span><br><span class="line">            <span class="attr">num</span>: i + <span class="number">1</span>, <span class="comment">//第几件商品</span></span><br><span class="line">            <span class="attr">w</span>: weights[i], <span class="comment">//重量</span></span><br><span class="line">            <span class="attr">v</span>: values[i],</span><br><span class="line">            <span class="attr">rate</span>: values[i] / weights[i]</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    list.<span class="title function_">sort</span>(<span class="keyword">function</span> (<span class="params">a, b</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> b.<span class="property">rate</span>-a.<span class="property">rate</span></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// console.log(list)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> selects = [];</span><br><span class="line">    <span class="keyword">var</span> total = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len = list.<span class="property">length</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">var</span> item = list[i];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (item[<span class="string">&#x27;w&#x27;</span>] &lt;= capacity) &#123;</span><br><span class="line">            selects.<span class="title function_">push</span>(&#123;</span><br><span class="line">                <span class="attr">num</span>: item.<span class="property">num</span>,</span><br><span class="line">                <span class="attr">rate</span>: <span class="number">1</span>, <span class="comment">//完整的商品记录为1</span></span><br><span class="line">                <span class="attr">v</span>: item.<span class="property">v</span>,</span><br><span class="line">                <span class="attr">w</span>: item.<span class="property">w</span></span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            total = total + item.<span class="property">v</span>;</span><br><span class="line">            capacity = capacity - item.<span class="property">w</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (capacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//选取不完整的商品</span></span><br><span class="line">            <span class="keyword">var</span> rate = capacity / item[<span class="string">&#x27;w&#x27;</span>];</span><br><span class="line">            <span class="keyword">var</span> v = item.<span class="property">v</span> * rate;</span><br><span class="line">            selects.<span class="title function_">push</span>(&#123;</span><br><span class="line">                <span class="attr">num</span>: item.<span class="property">num</span>,</span><br><span class="line">                <span class="attr">rate</span>: rate,</span><br><span class="line">                <span class="attr">v</span>: item.<span class="property">v</span> * rate,</span><br><span class="line">                <span class="attr">w</span>: item.<span class="property">w</span> * rate</span><br><span class="line">            &#125;);</span><br><span class="line">            total = total + v;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        selects,</span><br><span class="line">        total</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="十五-手写代码-amp-场景题"><a href="#十五-手写代码-amp-场景题" class="headerlink" title="十五. 手写代码&amp;场景题"></a>十五. 手写代码&amp;场景题</h4><h5 id="1-手写Promise"><a href="#1-手写Promise" class="headerlink" title="1.手写Promise"></a>1.手写Promise</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @作者: kerwin</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">KerwinPromise</span>(<span class="params">executor</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">status</span> = <span class="string">&quot;pending&quot;</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">result</span> = <span class="literal">undefined</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">cb</span> = []</span><br><span class="line">    <span class="keyword">var</span> _this = <span class="variable language_">this</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">resolve</span>(<span class="params">res</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (_this.<span class="property">status</span> !== <span class="string">&quot;pending&quot;</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// console.log(_this)</span></span><br><span class="line">        _this.<span class="property">status</span> = <span class="string">&quot;fulfilled&quot;</span></span><br><span class="line">        _this.<span class="property">result</span> = res;</span><br><span class="line"></span><br><span class="line">        _this.<span class="property">cb</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">            item.<span class="property">successCB</span> &amp;&amp; item.<span class="title function_">successCB</span>(_this.<span class="property">result</span>)</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">reject</span>(<span class="params">res</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (_this.<span class="property">status</span> !== <span class="string">&quot;pending&quot;</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// console.log(&quot;reject&quot;)</span></span><br><span class="line">        _this.<span class="property">status</span> = <span class="string">&quot;rejected&quot;</span></span><br><span class="line">        _this.<span class="property">result</span> = res;</span><br><span class="line">        _this.<span class="property">cb</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">            item.<span class="property">failCB</span> &amp;&amp; item.<span class="title function_">failCB</span>(_this.<span class="property">result</span>)</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">executor</span>(resolve, reject)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">KerwinPromise</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">then</span> = <span class="keyword">function</span> (<span class="params">successCB, failCB</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!successCB)&#123;</span><br><span class="line">        successCB = <span class="function"><span class="params">value</span>=&gt;</span>value</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!failCB)&#123;</span><br><span class="line">        failCB = <span class="function"><span class="params">error</span>=&gt;</span>error</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// successCB()</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">KerwinPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="string">&quot;fulfilled&quot;</span>) &#123;</span><br><span class="line">            <span class="keyword">var</span> result = successCB &amp;&amp; <span class="title function_">successCB</span>(<span class="variable language_">this</span>.<span class="property">result</span>)</span><br><span class="line">            <span class="comment">// console.log(result);</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (result <span class="keyword">instanceof</span> <span class="title class_">KerwinPromise</span>) &#123;</span><br><span class="line">                result.<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">                    <span class="comment">// console.log(res)</span></span><br><span class="line">                    <span class="title function_">resolve</span>(res);</span><br><span class="line">                &#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">                    <span class="comment">// console.log(err)</span></span><br><span class="line">                    <span class="title function_">reject</span>(err)</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="title function_">resolve</span>(result);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="string">&quot;rejected&quot;</span>) &#123;</span><br><span class="line">            <span class="keyword">var</span> result = failCB &amp;&amp; <span class="title function_">failCB</span>(<span class="variable language_">this</span>.<span class="property">result</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (result <span class="keyword">instanceof</span> <span class="title class_">KerwinPromise</span>) &#123;</span><br><span class="line">                result.<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">                    <span class="comment">// console.log(res)</span></span><br><span class="line">                    <span class="title function_">resolve</span>(res);</span><br><span class="line">                &#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">                    <span class="comment">// console.log(err)</span></span><br><span class="line">                    <span class="title function_">reject</span>(err)</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="title function_">reject</span>(result);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="string">&quot;pending&quot;</span>) &#123;</span><br><span class="line">            <span class="comment">//收集回调</span></span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">cb</span>.<span class="title function_">push</span>(&#123;</span><br><span class="line">                <span class="attr">successCB</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">                    <span class="keyword">var</span> result = successCB &amp;&amp; <span class="title function_">successCB</span>(<span class="variable language_">this</span>.<span class="property">result</span>)</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (result <span class="keyword">instanceof</span> <span class="title class_">KerwinPromise</span>) &#123;</span><br><span class="line">                        result.<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">                            <span class="comment">// console.log(res)</span></span><br><span class="line">                            <span class="title function_">resolve</span>(res);</span><br><span class="line">                        &#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">                            <span class="comment">// console.log(err)</span></span><br><span class="line">                            <span class="title function_">reject</span>(err)</span><br><span class="line">                        &#125;)</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="title function_">resolve</span>(result);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="attr">failCB</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">                    <span class="keyword">var</span> result = failCB &amp;&amp; <span class="title function_">failCB</span>(<span class="variable language_">this</span>.<span class="property">result</span>)</span><br><span class="line">                    <span class="keyword">if</span> (result <span class="keyword">instanceof</span> <span class="title class_">KerwinPromise</span>) &#123;</span><br><span class="line">                        result.<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">                            <span class="comment">// console.log(res)</span></span><br><span class="line">                            <span class="title function_">resolve</span>(res);</span><br><span class="line">                        &#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">                            <span class="comment">// console.log(err)</span></span><br><span class="line">                            <span class="title function_">reject</span>(err)</span><br><span class="line">                        &#125;)</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="title function_">reject</span>(result);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">KerwinPromise</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">catch</span>= <span class="keyword">function</span>(<span class="params">failCB</span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">then</span>(<span class="literal">undefined</span>,failCB)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-手写实现发布-订阅模式"><a href="#2-手写实现发布-订阅模式" class="headerlink" title="2.手写实现发布/订阅模式"></a>2.手写实现发布/订阅模式</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Subject</span> &#123; <span class="comment">//定义被观察者</span></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">observers</span> = []</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">addObserver</span>(<span class="params">observer</span>) &#123; <span class="comment">//订阅</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">observers</span>.<span class="title function_">push</span>(observer)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">removerObserver</span>(<span class="params">observer</span>) &#123;<span class="comment">//取消订阅</span></span><br><span class="line">    <span class="keyword">let</span> index = <span class="variable language_">this</span>.<span class="property">observers</span>.<span class="title function_">indexOf</span>(observer)</span><br><span class="line">    <span class="keyword">if</span> (index !== -<span class="number">1</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">observers</span>.<span class="title function_">splice</span>(index, <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">notify</span>(<span class="params"></span>) &#123;  <span class="comment">//通知</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">observers</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">observer</span> =&gt;</span> &#123;</span><br><span class="line">      observer.<span class="title function_">update</span>()</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Observer</span> &#123; <span class="comment">// 定义观察者</span></span><br><span class="line">  <span class="title function_">update</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;subject更新了&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">subscribeTo</span>(<span class="params">subject</span>) &#123;</span><br><span class="line">    subject.<span class="title function_">addObserver</span>(<span class="variable language_">this</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> subject = <span class="keyword">new</span> <span class="title class_">Subject</span>() <span class="comment">//被观察者</span></span><br><span class="line"><span class="keyword">let</span> observer1 = <span class="keyword">new</span> <span class="title class_">Observer</span>()  <span class="comment">//观察者</span></span><br><span class="line">observer1.<span class="title function_">subscribeTo</span>(subject) <span class="comment">//观察者进行订阅</span></span><br><span class="line"><span class="keyword">let</span> observer2 = <span class="keyword">new</span> <span class="title class_">Observer</span>()  <span class="comment">//观察者</span></span><br><span class="line">observer2.<span class="title function_">subscribeTo</span>(subject) <span class="comment">//观察者进行订阅</span></span><br><span class="line">subject.<span class="title function_">notify</span>()</span><br></pre></td></tr></table></figure><h5 id="3-手写代码，监测数组变化，并返回数组长度"><a href="#3-手写代码，监测数组变化，并返回数组长度" class="headerlink" title="3. 手写代码，监测数组变化，并返回数组长度"></a>3. 手写代码，监测数组变化，并返回数组长度</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//手写代码，监测数组变化，并返回数组长度</span></span><br><span class="line"><span class="comment">// 获取Array的原型，并创建一个新的对象指向这个原型</span></span><br><span class="line">    <span class="comment">// const arrayMethods = Object.create(Array.prototype)</span></span><br><span class="line">    <span class="comment">// 创建一个新的原型，这就是改造之后的数组原型</span></span><br><span class="line">    <span class="keyword">const</span> <span class="title class_">ArrayProto</span> = []</span><br><span class="line">    <span class="comment">// 重新构建Array原型里面的虽有方法</span></span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">getOwnPropertyNames</span>(<span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>).<span class="title function_">forEach</span>(<span class="function"><span class="params">method</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>[method] === <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">        <span class="title class_">ArrayProto</span>[method] = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">          <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;我已经监听到数组触发了&quot;</span> + method + <span class="string">&quot;事件&quot;</span>)</span><br><span class="line">          <span class="keyword">let</span> len = <span class="variable language_">this</span>.<span class="property">length</span></span><br><span class="line">          <span class="keyword">let</span> result = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>[method].<span class="title function_">apply</span>(<span class="variable language_">this</span>, <span class="variable language_">arguments</span>)</span><br><span class="line">          <span class="variable language_">console</span>.<span class="title function_">log</span>(len, <span class="variable language_">this</span>.<span class="property">length</span>);</span><br><span class="line">          <span class="keyword">if</span> (len !== <span class="variable language_">this</span>.<span class="property">length</span>) <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">length</span></span><br><span class="line">          <span class="keyword">return</span> result</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">let</span> list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">    <span class="comment">// 将数组的原型链指向新构造的原型</span></span><br><span class="line">    list.<span class="property">__proto__</span> = <span class="title class_">ArrayProto</span></span><br><span class="line">    <span class="comment">// 执行push事件</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(list.<span class="title function_">push</span>(<span class="number">2</span>), list.<span class="title function_">pop</span>(<span class="number">2</span>), list.<span class="title function_">slice</span>(<span class="number">2</span>), list.<span class="title function_">unshift</span>(<span class="number">2</span>));</span><br></pre></td></tr></table></figure><h5 id="4-手写ajax"><a href="#4-手写ajax" class="headerlink" title="4. 手写ajax"></a>4. 手写ajax</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.创建对象</span></span><br><span class="line"><span class="keyword">let</span>  xhq = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>()</span><br><span class="line"><span class="comment">//2.初始话http请求参数</span></span><br><span class="line">xhq.<span class="title function_">open</span>(methode, url, <span class="literal">true</span>)</span><br><span class="line"><span class="comment">//3.发送请求</span></span><br><span class="line">xhq.<span class="title function_">send</span>(&#123;</span><br><span class="line">    <span class="attr">username</span>:<span class="string">&#x27;wzx&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//4.监听请求状态,执行对应的回调函数</span></span><br><span class="line">xhq.<span class="property">onreadystatechange</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> ( xhq.<span class="property">readystate</span> == <span class="number">4</span> &amp;&amp; xhq.<span class="property">status</span> == <span class="number">200</span> ) &#123;</span><br><span class="line">        <span class="comment">// success 回调</span></span><br><span class="line">        <span class="title function_">success</span>(xhq.<span class="property">responseText</span>)</span><br><span class="line">    &#125;  <span class="keyword">else</span> <span class="keyword">if</span> (xhq.<span class="property">readyState</span> == <span class="number">4</span> &amp;&amp; xhq.<span class="property">status</span> !== <span class="number">200</span>) &#123;</span><br><span class="line">        <span class="comment">// error 回调</span></span><br><span class="line">        <span class="title function_">error</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//-----------完整实现-----------</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sendAjax</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">splicStr</span>(<span class="params">data</span>) &#123;<span class="comment">// get方式传入时，将内容进行data内容进行拼接</span></span><br><span class="line">        <span class="keyword">var</span> str = <span class="string">&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> data) &#123;</span><br><span class="line">            str = i + <span class="string">&#x27;=&#x27;</span> + data[i]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原生ajax实现 步骤分析</span></span><br><span class="line"><span class="comment">// 一、声明XMLHttpRequest, 为了兼容IE5、6需要使用ActiveXObject()</span></span><br><span class="line">    <span class="keyword">let</span> xhq = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>() <span class="comment">// 创建对象</span></span><br><span class="line"><span class="comment">// 二、初始化HTTP请求参数， 只初始化并不会发送</span></span><br><span class="line">    <span class="keyword">if</span> (obj.<span class="property">method</span>.<span class="title function_">toUpperCase</span>() === <span class="string">&#x27;GET&#x27;</span>) &#123; <span class="comment">// get方法</span></span><br><span class="line">        xhq.<span class="title function_">open</span>(obj.<span class="property">method</span>, obj.<span class="property">url</span> + <span class="string">&#x27;?&#x27;</span> + <span class="title function_">splicStr</span>(obj.<span class="property">data</span>),  <span class="keyword">typeof</span> obj.<span class="property">async</span> === <span class="string">&#x27;boolean&#x27;</span>? obj.<span class="property">async</span> : <span class="literal">true</span>) <span class="comment">// 路径拼接</span></span><br><span class="line">        xhq.<span class="title function_">send</span>()<span class="comment">// 三、发送此次请求</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (obj.<span class="property">method</span>.<span class="title function_">toUpperCase</span>() === <span class="string">&#x27;POST&#x27;</span>) &#123; <span class="comment">// post方法</span></span><br><span class="line">        xhq.<span class="title function_">open</span>(obj.<span class="property">method</span>, obj.<span class="property">url</span>, <span class="keyword">typeof</span> obj.<span class="property">async</span> === <span class="string">&#x27;boolean&#x27;</span>? obj.<span class="property">async</span> : <span class="literal">true</span>)</span><br><span class="line">        xhq.<span class="title function_">setRequestHeader</span>(<span class="string">&quot;content-type&quot;</span>,<span class="string">&quot;application/json&quot;</span>) <span class="comment">// 以表单提交</span></span><br><span class="line">        xhq.<span class="title function_">send</span>(obj.<span class="property">data</span>)<span class="comment">// 三、发送此次请求</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//四、监听发送</span></span><br><span class="line">    xhq.<span class="property">onreadystatechange</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ( xhq.<span class="property">readyState</span> == <span class="number">4</span> &amp;&amp; xhq.<span class="property">status</span> == <span class="number">200</span> ) &#123;</span><br><span class="line">            <span class="comment">// success 回调</span></span><br><span class="line">            <span class="title function_">success</span>(xhq.<span class="property">responseText</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (xhq.<span class="property">readyState</span> == <span class="number">4</span> &amp;&amp; xhq.<span class="property">status</span> !== <span class="number">200</span>) &#123;</span><br><span class="line">            <span class="comment">// error 回调</span></span><br><span class="line">            <span class="title function_">error</span>()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">sendAjax</span>(&#123;</span><br><span class="line">    <span class="attr">url</span>: <span class="string">&#x27;your url&#x27;</span>,</span><br><span class="line">    <span class="attr">method</span>: <span class="string">&#x27;post&#x27;</span>,</span><br><span class="line">    <span class="attr">async</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">data</span>: &#123;</span><br><span class="line">        <span class="attr">username</span>: <span class="string">&#x27;xiong&#x27;</span>,</span><br><span class="line">        <span class="attr">pwd</span>: <span class="string">&#x27;123&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">success</span>: <span class="keyword">function</span> (<span class="params">data</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(data)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">error</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;发生了错误&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h5 id="5-手写深拷贝"><a href="#5-手写深拷贝" class="headerlink" title="5.手写深拷贝"></a>5.手写深拷贝</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">deepCopy</span>(<span class="params">obj</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(obj))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">deepCopy</span>(<span class="params">obj</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> obj ==<span class="string">&#x27;object&#x27;</span>)&#123;<span class="comment">//判断是否为复杂数据源类型</span></span><br><span class="line">        <span class="keyword">var</span> result = obj.<span class="property">constructor</span> == <span class="title class_">Array</span>?[]:&#123;&#125;  <span class="comment">//数组还是对象</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">in</span> obj)&#123;</span><br><span class="line">            result[i]= <span class="keyword">typeof</span> obj[i] ==<span class="string">&#x27;object&#x27;</span>? <span class="title function_">deepCopy</span>(obj[i]):obj[i]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//简单数据类型 </span></span><br><span class="line">        <span class="keyword">var</span> result = obj;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="6-Antd-树组件-点击变成输入框-输入完还能保存"><a href="#6-Antd-树组件-点击变成输入框-输入完还能保存" class="headerlink" title="6. Antd-树组件-点击变成输入框-输入完还能保存"></a>6. Antd-树组件-点击变成输入框-输入完还能保存</h5><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useState &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Tree</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;antd&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;./DemoTree.css&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">Demo</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> [valueobj,setValObj]=<span class="title function_">useState</span>(&#123;&#125;)</span><br><span class="line">  <span class="keyword">const</span> [id,setId]=<span class="title function_">useState</span>(&#123;&#125;)</span><br><span class="line">  <span class="keyword">const</span> treeData = [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">title</span>:<span class="string">&#x27;0-0&#x27;</span>,</span><br><span class="line">      <span class="attr">key</span>: <span class="string">&#x27;0-0&#x27;</span>,</span><br><span class="line">      <span class="attr">children</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">title</span>: <span class="string">&#x27;0-0-0&#x27;</span>,</span><br><span class="line">          <span class="attr">key</span>: <span class="string">&#x27;0-0-0&#x27;</span>,</span><br><span class="line">          <span class="attr">children</span>: [</span><br><span class="line">            &#123; <span class="attr">title</span>: <span class="string">&#x27;0-0-0-0&#x27;</span>, <span class="attr">key</span>: <span class="string">&#x27;0-0-0-0&#x27;</span> &#125;,</span><br><span class="line">            &#123; <span class="attr">title</span>: <span class="string">&#x27;0-0-0-1&#x27;</span>, <span class="attr">key</span>: <span class="string">&#x27;0-0-0-1&#x27;</span> &#125;,</span><br><span class="line">            &#123; <span class="attr">title</span>: <span class="string">&#x27;0-0-0-2&#x27;</span>, <span class="attr">key</span>: <span class="string">&#x27;0-0-0-2&#x27;</span> &#125;,</span><br><span class="line">          ],</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">title</span>: <span class="string">&#x27;0-0-1&#x27;</span>,</span><br><span class="line">          <span class="attr">key</span>: <span class="string">&#x27;0-0-1&#x27;</span>,</span><br><span class="line">          <span class="attr">children</span>: [</span><br><span class="line">            &#123; <span class="attr">title</span>: <span class="string">&#x27;0-0-1-0&#x27;</span>, <span class="attr">key</span>: <span class="string">&#x27;0-0-1-0&#x27;</span> &#125;,</span><br><span class="line">            &#123; <span class="attr">title</span>: <span class="string">&#x27;0-0-1-1&#x27;</span>, <span class="attr">key</span>: <span class="string">&#x27;0-0-1-1&#x27;</span> &#125;,</span><br><span class="line">            &#123; <span class="attr">title</span>: <span class="string">&#x27;0-0-1-2&#x27;</span>, <span class="attr">key</span>: <span class="string">&#x27;0-0-1-2&#x27;</span> &#125;,</span><br><span class="line">          ],</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">title</span>: <span class="string">&#x27;0-0-2&#x27;</span>,</span><br><span class="line">          <span class="attr">key</span>: <span class="string">&#x27;0-0-2&#x27;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">      ],</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">title</span>: <span class="string">&#x27;0-1&#x27;</span>,</span><br><span class="line">      <span class="attr">key</span>: <span class="string">&#x27;0-1&#x27;</span>,</span><br><span class="line">      <span class="attr">children</span>: [</span><br><span class="line">        &#123; <span class="attr">title</span>: <span class="string">&#x27;0-1-0-0&#x27;</span>, <span class="attr">key</span>: <span class="string">&#x27;0-1-0-0&#x27;</span> &#125;,</span><br><span class="line">        &#123; <span class="attr">title</span>: <span class="string">&#x27;0-1-0-1&#x27;</span>, <span class="attr">key</span>: <span class="string">&#x27;0-1-0-1&#x27;</span> &#125;,</span><br><span class="line">        &#123; <span class="attr">title</span>: <span class="string">&#x27;0-1-0-2&#x27;</span>, <span class="attr">key</span>: <span class="string">&#x27;0-1-0-2&#x27;</span> &#125;,</span><br><span class="line">      ],</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">title</span>: <span class="string">&#x27;0-2&#x27;</span>,</span><br><span class="line">      <span class="attr">key</span>: <span class="string">&#x27;0-2&#x27;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">  ];</span><br><span class="line">  <span class="keyword">const</span> [checkedKeys, setCheckedKeys] = <span class="title function_">useState</span>([<span class="string">&#x27;0-0-0&#x27;</span>]);</span><br><span class="line">  <span class="keyword">const</span> [selectedKeys, setSelectedKeys] = <span class="title function_">useState</span>([]);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">onCheck</span> = (<span class="params">checkedKeysValue</span>) =&gt; &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;onCheck&#x27;</span>, checkedKeysValue);</span><br><span class="line">    <span class="title function_">setCheckedKeys</span>(checkedKeysValue);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">onSelect</span> = (<span class="params">selectedKeysValue, info</span>) =&gt; &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;onSelect&#x27;</span>, info.<span class="property">node</span>.<span class="property">key</span>,info.<span class="property">node</span>);</span><br><span class="line">    <span class="title function_">setSelectedKeys</span>(selectedKeysValue);</span><br><span class="line">    <span class="title function_">setId</span>(info.<span class="property">node</span>)</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">recursionTreeData</span> = (<span class="params">treeData</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> nodeData = [];</span><br><span class="line">    treeData.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(item.<span class="property">children</span>)&#123;</span><br><span class="line">            item.<span class="property">children</span> = <span class="title function_">recursionTreeData</span>(item.<span class="property">children</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(id.<span class="property">key</span>===item.<span class="property">key</span>)&#123;</span><br><span class="line">          item.<span class="property">isStop</span>=!item.<span class="property">isStop</span></span><br><span class="line">          item.<span class="property">title</span>=valueobj[item.<span class="property">key</span>]</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">          <span class="comment">// console.log(item.title)</span></span><br><span class="line">          item.<span class="property">title</span>=valueobj[item.<span class="property">key</span>]?valueobj[item.<span class="property">key</span>]:item.<span class="property">key</span></span><br><span class="line">        &#125;</span><br><span class="line">        item.<span class="property">title</span> = (</span><br><span class="line">                <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                    <span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;item.title&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&#x27;text&#x27;</span> <span class="attr">style</span>=<span class="string">&#123;item.isStop?&#123;display:</span>&#x27;<span class="attr">block</span>&#x27;&#125;<span class="attr">:</span>&#123;<span class="attr">display:</span>&#x27;<span class="attr">none</span>&#x27;&#125;&#125;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                     <span class="attr">onBlur</span>=<span class="string">&#123;(ev)</span>=&gt;</span>&#123;</span></span><br><span class="line"><span class="language-xml">                      valueobj[item.key] = ev.target.value</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">                      console.log(valueobj)</span></span><br><span class="line"><span class="language-xml">                      setValObj(&#123;...valueobj&#125;)</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">                       ev.target.style.display=&quot;none&quot;</span></span><br><span class="line"><span class="language-xml">                     &#125;&#125;/&gt; </span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">        );</span><br><span class="line">        nodeData.<span class="title function_">push</span>(item);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> nodeData;</span><br><span class="line">&#125;;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">Tree</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">      <span class="attr">checkable</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">      <span class="attr">checkedKeys</span>=<span class="string">&#123;checkedKeys&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">      <span class="attr">onCheck</span>=<span class="string">&#123;onCheck&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">      <span class="attr">onSelect</span>=<span class="string">&#123;onSelect&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">      <span class="attr">select7edKeys</span>=<span class="string">&#123;selectedKeys&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">      <span class="attr">treeData</span>=<span class="string">&#123;recursionTreeData(treeData)&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    /&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">Demo</span></span><br></pre></td></tr></table></figure><h5 id="7-场景"><a href="#7-场景" class="headerlink" title="7. 场景"></a>7. 场景</h5><p><strong>经过两个月“选课系统“开发，测试，上线，”选课系统“服务于学校教学的第一站，参与选课学校的学生上午8点集中开测。市场反馈有如下情况：</strong></p><p><strong>1）打开网站出现502</strong></p><p><strong>2）登录进不去系统</strong></p><p><strong>3）提交数据一致反复</strong></p><p><strong>4）有时出现白屏现象</strong></p><p><strong>对于市场反馈情况谈谈你的认识？</strong></p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">首先，502错误，意思是worker进程忙不过来，参与选课的学生上午8点集中开测，在短时间内访问人数过多导致积累了大量的请求，后台服务器忙不过来。解决方法贵公司可以看看CPU和内存满没满，没满就多开一些worker，满了就多加一些机子。也可能是数据库响应缓慢，然后人多了数据库是否能撑住也是一个考虑，多用一些缓存吧。</span><br><span class="line"></span><br><span class="line">第二个问题，结合502报错来看，登录不进系统的原因估计也是短时间内访问人数过多导致服务器崩了。</span><br><span class="line"></span><br><span class="line">提交数据一直反复就相对复杂了，可能出现的使用场景也有很多。</span><br><span class="line">比如说我们在提交表单的时候，有可能是网络延迟或内存不足，导致点击一次提交按钮，页面没有反应，结果强迫症就犯了，就疯狂的点提交恨不得把手机屏幕点烂来。也有可能是有些毛孩子，点完提交按钮立马点击刷新页面，或直接返回上层页面想卡bug</span><br><span class="line">对于这种情况，我以前工作的做法就是设置蒙版层，不管你怎么点，只要你点提交，我就给你弹出蒙版层。其实这个问题最根本的原因是程序没有进行重复判断，导致数据库重复写入。前端后端都可以添加一个重复判断逻辑，判断后台数据库中是否已经存在当前提交的数据，避免重复添加。但是这种判断只解决了两次表单依次提交的问题，如果不同用户同时提交表单，数据就不一定会正确了。这种问题就是我们常说的并发问题，并发问题的解决方案也有很多，比如：加锁排队处理等。</span><br><span class="line"></span><br><span class="line">最后提到解决白屏问题，我个人在白屏优化实践上尝试过SSR、路由懒加载、还有骨架屏等一些方案，每个方案都个有自己的优劣，需要根据实际的业务场景进行取舍。</span><br><span class="line">SSR服务端渲染，这个方案可以让页面直接在服务端渲染，但是不利于前后端分离，开发的效率也比客户端渲染低，同时也加大了服务器的压力。</span><br><span class="line">当打包构建应用时，JavaScript 包会变得非常大，影响页面加载。如果我们能把不同路由对应的组件分割成不同的代码块，然后当路由被访问的时候才加载对应组件，这样就会更加高效。</span><br><span class="line">使用骨架屏的话，存在与业务深度耦合，页面复杂度变高的问题。当应对需求变更时，骨架屏结构成本，工具实现成本，配置成本，项目的维护成本，都比较高。</span><br></pre></td></tr></table></figure><h4 id="十六-综合题目"><a href="#十六-综合题目" class="headerlink" title="十六. 综合题目"></a>十六. 综合题目</h4><h5 id="1-项目研发流程中作为前端开发一般扮演的啥角色？"><a href="#1-项目研发流程中作为前端开发一般扮演的啥角色？" class="headerlink" title="1. 项目研发流程中作为前端开发一般扮演的啥角色？"></a>1. 项目研发流程中作为前端开发一般扮演的啥角色？</h5><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">前端开发一般扮演着一个“团队核心废物”的角色。为什么这么说，首先在项目的研发中，UI小姐姐总感觉前端开发的页面满足不了她们的设计理念，说你没品味；后端小哥哥觉得前端开发就像只会写写样式的js交互工程师，像极了一个破美工的；测试小哥哥拿着测试报告说：这锅谁他娘的来背一下。还记得当年那个请你根据手机壳的颜色，来实现APP启动的颜色的产品经理嘛？这些对前端开发的误会难道不能折射出前端是团队里最应该学会沟通的人嘛？</span><br><span class="line">界面有问题需要和UI沟通,数据有问题需要和后台沟通,功能有问题需要和产品沟通,测试的时候给你提bug你还需要和测试沟通……毕竟前端是最接近用户的人,用户对一个网站,软件最直观的感受是反映到前端；交互体验更是前端项目的核心点。</span><br><span class="line">和UI的沟通,在工作中我们不应该是被动的实现UI的设计,而是应该合理化的提出自己的想法,不然日后返工浪费的是双方的时间。比如通用组件的设计，每次页面的提示弹窗设计，再比如你需要做一个图表,用到了echarts,你完全可以让UI基于echarts去设计样式,而不是让她在那里自由发挥，因为你永远不知道设计师的脑子里装了多少创意,这样节省的是两个人的时间,不会出现他做好样式而你实现不了的尴尬。</span><br><span class="line">和后端联调接口前，先要对业务需求了解透彻，需要哪些数据，有时候明明后台来处理某个事件很简单,后台非要你来做,这就需要我们对一个需求,一个任务的要有清晰认识了,如果对任务含糊不清,自己都没搞明白,你只能受后台摆布了.最后可能也会因为任务没有完成而备受责难了。有理有据,后台开发人员是不会说什么的,否则,后台会很不耐烦的,甚至骂你的可能都有,本身做后台比较难,尤其在查询数据,取数据,封装数据方面都比较难处理。</span><br><span class="line">面对产品经理的需求，前端应该深刻理解需求，毕竟工作性质影响了一个人的思维逻辑，前端能站在一个产品经理的角度去思考每一个需求，便显得尤其重要。不放过每一个细节也很重要。产品经理在设计一个产品的时候，都是从大方向去想问题的，大方向没有错就行了，细节脱离不了大方向。这是他们想的。但是对于程序来说，却万万不能。因为一个细节的逻辑往往决定了整个大方向。</span><br><span class="line">举个例子：有一个需求，用户的作品需要提交审核，经过审核才可以让所有人看到。当产品经理交这个需求给你的时候，你能察觉到什么问题了吗？这里面有几个细节：1.用户提交审核后，用户可以不可以再编辑作品；2.作品是否会多次审核；3.需不需要记录审核历史；4.用户作品是否需要有版本的控制，如要产生版本，版本又是如何产生的；5.审核通过后，用户可以不可以再修改作品，若不可以，那么是不是其他人就看不见用户作品等等。</span><br><span class="line">我认为前端开发是团队里最应该学会沟通的人，一个好的前端开发模式可以推动整个项目的进步的，尽管有时可能会被误解成废物，但是这何尝不是大家公认的核心呢？</span><br></pre></td></tr></table></figure><h5 id="2-项目中让你印象深刻的问题"><a href="#2-项目中让你印象深刻的问题" class="headerlink" title="2. 项目中让你印象深刻的问题"></a>2. 项目中让你印象深刻的问题</h5><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">之前用vue做了一个动态官网项目，后期客户要求seo，百度上之前搜索不到官网地址，后来在项目的入口文件index.html页面加上了，固定的meta标签，加上name名为keywords、description的meta标签。以上做了个简单的seo优化，这个项目有几个官网，但是其中只有一个官网要求seo，也就是在百度能够搜索到，当时为了应急，就写死了，但是，其它的网站也就会受到干扰了，也就是对于一个项目对应几个官网，写死的meta标签做seo是不科学的。</span><br><span class="line">如果这个项目要解决seo优化，可以用服务端渲染（ssr），如果项目刚开始就考虑到seo，采用服务端渲染，那么就用服务端渲染就得了。但是一般来讲，项目做到后期才会考虑到seo的问题，这时再去搞服务端渲染，相当于重头写项目，非常耗费人力物力。</span><br><span class="line">所以先只考虑在首页加入 meta 标签提供一些元数据，使用简单、具有表意性的 title 以及使用 h5 提供的具有语义化的标签（不要一堆 div），生成对 search engine 友好的 sitemap，使用合理的 html 结构（比如按标题、内容、页脚这样的顺序、或者将重要的内容放在 html 前，其他放在后）</span><br></pre></td></tr></table></figure><h5 id="3-项目开发中有遇到什么挑战没？"><a href="#3-项目开发中有遇到什么挑战没？" class="headerlink" title="3. 项目开发中有遇到什么挑战没？"></a>3. 项目开发中有遇到什么挑战没？</h5><blockquote><p>1.问题描述：1）简单介绍这个项目规模、背景2）什么情况下遇到什么样的问题</p><p>2.你处理这个问题的过程及结果：1）遇到问题你如何思考；2）你如何执行的；3）处理结果如何</p><p>3.通过处理这个问题，你学到了什么或者说通过这个问题，你看到了你们什么不足，后续动作（采用什么样的方式，在以后的项目中避免再出现这类问题）</p></blockquote><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1.（使用缓存处理）</span><br><span class="line">    在做Vue开发移动端APP时，有个页面比较常见，左边是对所有菜谱品类的展示，右边是对对应菜谱的展示，一开始在开发的时候没注意，就直接在mounted()前面使用async,里面使用await调了两边接口后，又通过watch监听了品类索引变化，调了一遍接口。后面发现每次切换品类时，页面都有一闪而过的感觉，发现每次都调了一遍接口，这对性能消耗挺大。所以就尝试的走了Vuex做缓存处理。当时解决这个缓存问题用了一些巧妙的方法，首先缓存的数据，采用的是对象形式，不是数组。这样写起来更快，因为用品类的下标直接做缓存数据的key值，非常好写。不过后面又有点坑，就是我监听的是引用数据类型，不管是vue还是react，引用数据类型发生变化时，页面可能不会更新。后面又在mutation中对vuex中的数据更新时，做了一下深复制，就做好了缓存处理。因为我是根据判断这个对象中有没有数据去调接口的，如果存在，就不调接口。现在做了缓存没错，那如果以后后台的数据发生了变化的话，那我这里也不调接口了，后台数据就没有在页面上实现更新，所以在跳出这个页面的时候还要清下缓存。清缓存要在生命周期结束的时候清，如果碰到了动态组件把APP页面下的 Tap 栏包住的时候， Keep-alive。就不能用 destroyed 生命周期清除，要用 deactivated 生命周期去清除。这样才有始有终，完成缓存处理。</span><br><span class="line"></span><br><span class="line">2.（解决关键词高亮问题----&gt;原理和字符串敏感词替换一样，但是用在关键词高亮上算是一个技术亮点吧）</span><br><span class="line">    用户配置一堆关键词，在页面上将这些关键词高亮，也许你会觉得这有什么难度？用正则匹配一下出来高亮不就行了吗？但是，一开始，用户的词不多，我确实使用的是遍历，时间复杂度为n2。后来用户会配置100w量级的词，使用遍历就会使页面卡死崩溃。解决的方法就是：优化性能，高亮分三步，生成字典树，遍历页面文字，取出文字进行匹配。使用字典树代替遍历，整个页面100w量级的词绘制可以实现在1秒以内。</span><br><span class="line"></span><br><span class="line">3.（封装自定义组件）</span><br><span class="line">    在一个小程序项目需求中，要求页面头部tab栏切换的同时，对应tab栏品类的页面也要展示出来。你可能会觉得这个需求用个taroUI组件库中的tabs标签页组件不就可以完成吗？但是这个需求想满足用户的沉浸式体验，切换页面时需要有独特丝滑的专场特效。所以当时面临的问题就是，使用的UI库的组件默认样式生硬，满足不了需求。我当时是对小程序原生swiper组件进行了二次封装，主要实现了几点自定义需求：头部Tab栏品类样式使用flex动态布局，实现品类数量可变；使用 slot 插槽来动态渲染 Tab区块中的内容，配合原生swiper组件使用定义插槽；小程序原生组件&lt;swiper&gt;是有默认高度的，必须手动设置其高度，这里使用wx.getSystemInfo来动态获取屏幕尺寸。自己封装组件，踩了不少坑，但从中我学习到了：使用小程序的原生组件，并修改其默认的样式；学会使用 slot 插槽，实现组件内容的差异化；学会了使用小程序原生 api 获取手机信息，用 js 改变组件样式等等</span><br><span class="line"></span><br><span class="line">4.（遇到了难用的轮子）</span><br><span class="line">    在写XXX小程序项目中需要实现音频播放的功能，官方已经推荐使用新的API了，然而这个小程序官方文档文档写得并不好，很多时候我们会遇到一些需求，或者改变而这些需求文档里又写得非常模糊，这就比较头疼了。小程序官方文档更新十分频繁，坑非常多。所以很多时候，我就要去不断地从文档的字里行间猜测，并结合源码一步一步地去跟踪，去尝试解决这个音频播放问题。但有时候确实超出了我的能力范围，那么我就会把我的问题提炼成一个小demo，到知乎、segmentfault思否去问，或者提问一些同样用这个轮子的作者，最终找到了新API的使用规范。</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：这个时候你就要说你最擅长的，一定是你最擅长的点，告诉他这个问题怎么解决，一定是你最懂的，而且经得起推敲的解决方案。<strong>你要准备的不仅仅是你的项目中有哪些难点，更重要的是和这个难点相关的知识都要准备充分。</strong>所以，<strong>你的答案并不是这个项目中最难的点，而是一个最能让你回答好整套相关问题的难点</strong>。</p><h5 id="4-谈谈对前后端分离的理解。"><a href="#4-谈谈对前后端分离的理解。" class="headerlink" title="4. 谈谈对前后端分离的理解。"></a>4. 谈谈对前后端分离的理解。</h5><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">在我看来，前后端分离给开发工作带来了很多好处，在以前，没有这个概念的时候，一种经典的设计模式MVC模式。前端开发很不盛行，几乎很多后端程序员就兼顾了前端开发工作，前后端耦合性极强，在jsp时代，前端写好的页面最后要和后端实现交互，需要程序员手动的更改代码，这是很大的一个工作量，这种事情交给前端还是后端？谁都不愿意做吧！</span><br><span class="line">前后端分离过后，通过预先定义好接口规范，前端后端独立部署独立开发，后端只需要提供接口供调用即可，解耦效果是真的强，这对工作效率的提升是巨大的，对于后期的维护只需要前后端单独完成即可！</span><br><span class="line">   </span><br></pre></td></tr></table></figure><h5 id="5-项目负责什么"><a href="#5-项目负责什么" class="headerlink" title="5. 项目负责什么"></a>5. 项目负责什么</h5><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. 这个项目的列表展示与详情页是我负责的。我对于后端传递的数据进行了怎样的处理，在异步请求中选择了一定的异步分割处理数据，拆分一次性阻塞主线程的时间，可以减少用户的等待，页面滚动时选择节流，减少无效的axios请求等等，对自己模块所负责的内容，进行梳理。</span><br><span class="line"></span><br><span class="line">2. 这个项目的登录，注册，模块是我负责的。我对不同角色的鉴权是怎么实现的。。。</span><br><span class="line"></span><br><span class="line">3. 这个项目的表单提交页是我负责的。。。。用了什么UI组件。。。</span><br></pre></td></tr></table></figure><h5 id="6-流程-amp-规范"><a href="#6-流程-amp-规范" class="headerlink" title="6. 流程&amp;规范"></a>6. 流程&amp;规范</h5><h6 id="1-对接UI与交互"><a href="#1-对接UI与交互" class="headerlink" title="1) 对接UI与交互"></a>1) 对接UI与交互</h6><blockquote><p><img src="%E7%AC%94%E8%AE%B0.assets/clipboard.png" alt="image"></p></blockquote><p><strong>(1)原型</strong></p><ul><li><p>axure （发音：Ack-sure）<br><code>生成的html代码,页面代码杂乱，代码冗余量较大，不利于后期的优化</code></p></li><li><p>墨刀<br><code>https://free.modao.cc/app/ltnSwMXEFqjon7QtRssBgKkPXZmL3os#screen=s6A4B80F6FE1540952810987</code></p></li><li><p>蓝湖</p><p><code>https://lanhuapp.com/</code></p></li></ul><p><strong>(2)标注图</strong> </p><blockquote><p><img src="%E7%AC%94%E8%AE%B0.assets/clipboard-1586613161283.png" alt="image"></p></blockquote><p><strong>(3)谁来切图</strong></p><p><code>UI? 前端？后端？</code></p><h6 id="2-对接后端"><a href="#2-对接后端" class="headerlink" title="2) 对接后端"></a>2) 对接后端</h6><p><strong>(1) 亲嘴对接</strong></p><p><strong>(2) 接口文档</strong></p><blockquote><p><img src="%E7%AC%94%E8%AE%B0.assets/clipboard-1586613164273.png" alt="image"></p></blockquote><h6 id="3-多环境"><a href="#3-多环境" class="headerlink" title="3)多环境"></a>3)多环境</h6><div class="table-container"><table><thead><tr><th>英文缩写</th><th>英文</th><th>中文</th></tr></thead><tbody><tr><td>DEV</td><td>development</td><td>开发</td></tr><tr><td>SIT</td><td>System Integrate Test</td><td>系统整合测试（内测）</td></tr><tr><td>UAT</td><td>User Acceptance Test</td><td>用户验收测试</td></tr><tr><td>PET</td><td>Performance Evaluation Test</td><td>性能评估测试（压测）</td></tr><tr><td>PROD</td><td>production</td><td>产品/正式/生产</td></tr></tbody></table></div><blockquote><p><img src="%E7%AC%94%E8%AE%B0.assets/clipboard-1586613167025.png" alt="image"><br><img src="%E7%AC%94%E8%AE%B0.assets/clipboard-1586613169073.png" alt="image"><br><strong>保证pre的版本和pro环境的版本一致</strong>，如果pro环境出现bug,我们只需要在pre环境fix bug,从1.0.0 ==&gt;1.0.0.1 ,不会影响开发进度以及测试进度(不用单独创建分支修改)</p></blockquote><h5 id="7-工作中能够持续学习么？"><a href="#7-工作中能够持续学习么？" class="headerlink" title="7. 工作中能够持续学习么？"></a>7. 工作中能够持续学习么？</h5><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">工作中当然可以持续学习，我认为每次对自己的总结就是很好学习机会，可以是工作上的总结，生活上的总结，某一件小事的总结都可以学习。</span><br><span class="line">总结自己掌握的前端知识体系，总结知识体系的过程是一个查缺补漏的过程。遇到没掌握或者了解不深的知识点，务必去了解、搞清楚，否则就不算掌握。还可以，总结自己做过的项目中有哪些难点，或者技术架构。涉及到的所有技术点都可以挖一下，看看有没有某个点是自己描述不清的。</span><br><span class="line">有空闲时间，会去leetcode社区上找点算法题，可以去bestofjs社区看看社区又出了什么比较前沿的技术，框架 。还可以去Github上看看别人写的代码，或者翻翻Vue，React源码研究研究。</span><br></pre></td></tr></table></figure><h5 id="8-为什么辞职"><a href="#8-为什么辞职" class="headerlink" title="8. 为什么辞职"></a>8. 为什么辞职</h5><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在上一家公司，我也想过要早些辞职，但是考虑某个未完成的重要项目、或是继任者短期内还不能胜任角色所以晚了一些。主要离职的原因是在上一家公司待的时间比较长了，公司的各种业务已经非常熟练了，感觉工作成了流水线般的生产工具，技术达到了一定的瓶颈，我觉得我应该跳出舒适圈去接触更多的新技术与新的业务从而扩展自己的技术广度。我觉得贵公司的技术要求与我非常符合，有一些我自己非常熟练或精通的技术，更重要的事有一些我之前只是自己业余时间研究过但一直没有几乎用于实战的技术。我相信贵公司的岗位对我虽然有一定的挑战信但是会给我带来更多的提升机会。同时我上一家公司中用的React加koa框架做的项目也有很多设计上的亮点，我也可以将上一家优秀完整的项目开发流程与管理经验，项目设计思路与贵公司分享。完成互利互惠共同成长。</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;一-HTML5面试题&quot;&gt;&lt;a href=&quot;#一-HTML5面试题&quot; class=&quot;headerlink&quot; title=&quot;一. HTML5面试题&quot;&gt;&lt;/a&gt;一. HTML5面试题&lt;/h4&gt;&lt;h5 id=&quot;1-如何理解HTML5结构语义化？&quot;&gt;&lt;a href=&quot;#1-</summary>
      
    
    
    
    
    <category term="面试题" scheme="https://admin741-cl.github.io/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>微信小程序传参</title>
    <link href="https://admin741-cl.github.io/posts/c79e.html"/>
    <id>https://admin741-cl.github.io/posts/c79e.html</id>
    <published>2022-12-03T10:59:33.000Z</published>
    <updated>2023-06-17T06:18:37.614Z</updated>
    
    <content type="html"><![CDATA[<p>微信小程序有哪些传值(传递数据)方法<br>URL参数传递：可以通过URL参数的方式将数据传递给小程序页面。</p><p>Storage存储：可以通过Storage API将数据存储在本地，然后在小程序页面中读取。</p><p>全局变量：可以将数据存储在小程序的全局变量中，然后在小程序页面中读取。</p><p>数据绑定：可以通过数据绑定的方式将数据传递给小程序页面。</p><p>自定义事件：可以通过自定义事件的方式将数据传递给小程序页面。</p><p>WebSocket：可以通过WebSocket协议将数据传递给小程序页面。</p><p>数据库：可以通过小程序提供的数据库API将数据存储在数据库中，然后在小程序页面中读取。</p><p>1、使用全局变量传递数据</p><p>利用app.js 中的 globalData 将数据存储为全局变量，在需要使用的页面通过getApp().globalData获取数据</p><p>app.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">App</span>(&#123;</span><br><span class="line">        <span class="attr">globalData</span>:&#123;</span><br><span class="line">            <span class="attr">data</span>: &#123; <span class="attr">name</span>: <span class="string">&#x27;demo&#x27;</span> &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure><p>使用组件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> app = <span class="title function_">getApp</span>()</span><br><span class="line">     </span><br><span class="line">app.<span class="property">globalData</span>.<span class="property">data</span></span><br></pre></td></tr></table></figure><p>2、使用本地存储数据传递</p><p>使用小程序提供缓存</p><p>同步缓存：wx.setStorageSync 与 wx.getStorageSync</p><p>异步缓存：wx.setStorage 与 wx.getStorage</p><p>移除本地缓存：wx.removeStorageSync（同步）、wx.removeStorage（异步）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将数据存储在本地缓存中指定的 key 中</span></span><br><span class="line">    wx.<span class="title function_">setStorgaeSync</span>(<span class="string">&#x27;data&#x27;</span>,<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line">     </span><br><span class="line"><span class="comment">// 从本地缓存中同步获取指定 key 的内容</span></span><br><span class="line">    wx.<span class="title function_">getStorageSync</span>(<span class="string">&#x27;data&#x27;</span>)</span><br><span class="line">     </span><br><span class="line"><span class="comment">// 从本地缓存中移除指定 key</span></span><br><span class="line">    wx.<span class="title function_">removeStorgae</span>(<span class="string">&#x27;data&#x27;</span>)</span><br></pre></td></tr></table></figure><p>3、使用路由传递数据</p><p>传递组件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">wx.<span class="title function_">navigateTo</span>(&#123;</span><br><span class="line">      <span class="attr">url</span>: <span class="string">&#x27;test?id=1&#x27;</span>,</span><br><span class="line">      <span class="attr">success</span>: <span class="function">(<span class="params">res</span>)=&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 通过 eventChannel 向被打开页面传送数据</span></span><br><span class="line">        res.<span class="property">eventChannel</span>.<span class="title function_">emit</span>(<span class="string">&#x27;acceptDataFromOpenerPage&#x27;</span>, &#123; <span class="attr">data</span>: <span class="string">&#x27;test&#x27;</span> &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure><p>使用组件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Page</span>(&#123;</span><br><span class="line">      <span class="attr">onLoad</span>: <span class="keyword">function</span>(<span class="params">option</span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(option.<span class="property">query</span>)</span><br><span class="line">        <span class="comment">// 监听 acceptDataFromOpenerPage 事件，获取上一页面通过 eventChannel 传送到当前页面的数据</span></span><br><span class="line">        eventChannel.<span class="title function_">on</span>(<span class="string">&#x27;acceptDataFromOpenerPage&#x27;</span>, <span class="function">(<span class="params">data</span>)=&gt;</span> &#123;</span><br><span class="line">          <span class="variable language_">console</span>.<span class="title function_">log</span>(data)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure><p>4、父子组件使用selectComponent(‘#页面id’)，triggerEvent(‘方法名’，’值’)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;view id=<span class="string">&#x27;demo&#x27;</span> <span class="attr">bind</span>:returnDate=<span class="string">&#x27;handleReturnDate&#x27;</span>&gt;&lt;view&gt;</span><br><span class="line"> </span><br><span class="line">    <span class="title class_">Page</span>(&#123;</span><br><span class="line">          </span><br><span class="line">        <span class="title function_">handleData</span>(<span class="params">data</span>)&#123;</span><br><span class="line">           <span class="variable language_">this</span>.<span class="title function_">selectComponent</span>(<span class="string">&quot;#demo&quot;</span>).<span class="title function_">showModal</span>(data);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 子组件传递过来的值</span></span><br><span class="line">        <span class="title function_">handleReturnDate</span>(<span class="params">data</span>)&#123;</span><br><span class="line">             <span class="variable language_">console</span>.<span class="title function_">log</span>(data)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"> </span><br><span class="line">    <span class="title class_">Component</span>(&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="attr">methods</span>:&#123;</span><br><span class="line">            <span class="comment">// 父组件传递过来的数据</span></span><br><span class="line">            <span class="title function_">showModal</span>(<span class="params">data</span>)&#123;</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(data)</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="title function_">submit</span>(<span class="params"></span>)&#123;</span><br><span class="line">                <span class="comment">// 子组件传递数据给父组件</span></span><br><span class="line">               <span class="variable language_">this</span>.<span class="title function_">triggerEvent</span>(<span class="string">&quot;returnDate&quot;</span>, sportsGuidance);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure><p>5、子组件通过properties接收：</p><p>父组件parent</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">parent.<span class="property">wxml</span></span><br><span class="line"> </span><br><span class="line">    &lt;view&gt;</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">child</span> <span class="attr">:name</span>=<span class="string">&#x27;jack&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">child</span>&gt;</span></span></span><br><span class="line">    &lt;/view&gt;</span><br><span class="line"> </span><br><span class="line">parent.<span class="property">json</span></span><br><span class="line"> </span><br><span class="line">     &#123;</span><br><span class="line">        <span class="string">&quot;usingComponents&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;child&quot;</span>:<span class="string">&quot;/child/child&quot;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;navigationBarTitleText&quot;</span>: <span class="string">&quot;父组件的导航标题&quot;</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>子组件 child</p><p>child.wxml</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;view&gt;</span><br><span class="line">        父组件传递过来的<span class="attr">name</span>:&#123;&#123;name&#125;&#125;</span><br><span class="line">    &lt;/view&gt;</span><br></pre></td></tr></table></figure><p>child.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"> <span class="title class_">Component</span>(&#123;</span><br><span class="line">    <span class="comment">// 接受父组件传递过来的属性</span></span><br><span class="line">    <span class="attr">properties</span>:&#123;</span><br><span class="line">        <span class="attr">name</span>:<span class="title class_">String</span> <span class="comment">//简化的定义方式</span></span><br><span class="line">     </span><br><span class="line">        <span class="comment">//name:&#123;</span></span><br><span class="line">            <span class="comment">//type:String,</span></span><br><span class="line">            <span class="comment">//value:&#x27;&#x27;</span></span><br><span class="line">        <span class="comment">//&#125;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 私有数据，可用于模板渲染</span></span><br><span class="line">    <span class="attr">data</span>:&#123;&#125;,</span><br><span class="line">     </span><br><span class="line">    <span class="comment">// 组件生命周期声明对象</span></span><br><span class="line">    <span class="attr">lifetime</span>:&#123;</span><br><span class="line">     </span><br><span class="line">    &#125;,</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 组件所在页面的生命周期声明对象</span></span><br><span class="line">    <span class="attr">pageLifetimes</span>:&#123;</span><br><span class="line">     </span><br><span class="line">    &#125;,</span><br><span class="line">     </span><br><span class="line">    <span class="comment">// 事件响应函数和任意的自定义方法</span></span><br><span class="line">    <span class="attr">methods</span>:&#123;&#125;</span><br><span class="line">        </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;微信小程序有哪些传值(传递数据)方法&lt;br&gt;URL参数传递：可以通过URL参数的方式将数据传递给小程序页面。&lt;/p&gt;
&lt;p&gt;Storage存储：可以通过Storage API将数据存储在本地，然后在小程序页面中读取。&lt;/p&gt;
&lt;p&gt;全局变量：可以将数据存储在小程序的全局变量</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>为你的夏日带去清凉!</title>
    <link href="https://admin741-cl.github.io/posts/ae65.html"/>
    <id>https://admin741-cl.github.io/posts/ae65.html</id>
    <published>2022-10-20T14:06:17.000Z</published>
    <updated>2023-06-17T02:44:45.958Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>终于为博客安装上了便携小空调</p></blockquote><style>.copyright-box a {  border-bottom: none !important;  padding: 0 !important;}</style><p><div id="air-conditioner-vue"></div></p><script defer data-pjax src='https://npm.elemecdn.com/anzhiyu-air-conditioner@1.0.1/index.3f125bc6.js'></script>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;终于为博客安装上了便携小空调&lt;/p&gt;
&lt;/blockquote&gt;
&lt;style&gt;
.copyright-box a {
  border-bottom: none !important;
  padding: 0 !important;
}
&lt;/s</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>json-server文档</title>
    <link href="https://admin741-cl.github.io/posts/923a.html"/>
    <id>https://admin741-cl.github.io/posts/923a.html</id>
    <published>2022-09-19T10:47:45.000Z</published>
    <updated>2023-06-17T02:32:21.493Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><code>Ajax</code> 是前端必学的一个知识点，但刚接触 <code>Ajax</code> 的同学可能会因为<strong>没接口测试</strong>而烦恼。</p><p>本文 <strong>入门篇</strong> 会花你10分钟解决 <strong>没接口测试</strong> 这个烦恼，而且不需要你具备后端知识。</p><p>如果不想自己在本地搭环境，还可以使用 <a href="https://links.jianshu.com/go?to=https%3A%2F%2Fjuejin.cn%2Fpost%2F7041461420818432030">《前端需要的免费在线api接口》</a> 里推荐的几个线上接口平台，里面包括常用的 <code>json</code> 结构数据和图片。</p><p>虽然有线上的免费接口可以测试，但需要自定义接口和数据的时候，还是本地模拟数据比较适合前端开发者。</p><p>本文分 <strong>入门篇</strong> 和 <strong>进阶篇</strong>。再往下滑一点就能看到全文目录。</p><p><strong>入门篇：</strong> 5分钟内带你实现 <strong>本地环境搭建</strong> 和 <strong>增删改查</strong> 操作，满足入门测试使用。</p><p><strong>进阶篇：</strong> 主要讲解常用的 <strong>查询操作</strong>，除此之外还包括 <strong>常规配置、静态资源配置</strong> 等知识点。这部分有点长，建议<strong>收藏</strong>。</p><p><strong>本文约定</strong></p><ol><li>本文主要面向的读者是 <strong>前端小白</strong>，几乎不会涉及到后端知识，所以并不打算讲解 <code>json-server 中间件</code>  的内容。</li><li>本文讲到的所有知识点都会提供对应的代码展示（会比官方文档详细点）。</li><li>本文使用 <code>postman</code> 测试，希望能照顾到使用不同工具库做数据请求的读者（我知道还有只懂 <code>jQuery</code> 的开发者）。</li><li>特殊情况会使用 <code>axios</code> 配合演示。</li></ol><p><strong>点赞 + 收藏 = 学会了</strong></p><p><strong>目录</strong></p><p><img src="./images/json-server_img/思维导图.png" alt="img"></p><p>思维导图.png</p><h1 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h1><h2 id="json-server简介"><a href="#json-server简介" class="headerlink" title="json-server简介"></a>json-server简介</h2><p><a href="https://links.jianshu.com/go?to=https%3A%2F%2Fwww.npmjs.com%2Fpackage%2Fjson-server">npm地址</a> | <a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Ftypicode%2Fjson-server">github地址</a></p><blockquote><p>Get a full fake REST API with <strong>zero coding</strong> in <strong>less than 30 seconds</strong> (seriously)</p></blockquote><p>引用了官方的一句话，大概意思是30秒就能获得一套完整的模拟 REST API 接口。</p><p>使用 <code>json-server</code> 需要遵守一定的规范。</p><ul><li>数据查询要使用 <code>GET</code>。</li><li>新增数据要使用 <code>POST</code>。</li><li>删除数据要使用 <code>DELETE</code>。</li><li>修改数据使用 <code>PUT</code> 和 <code>PATCH</code>。</li></ul><p>其他啰嗦的介绍可以打开上面提供的<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Ftypicode%2Fjson-server">网址</a>看看。</p><h2 id="30秒起步"><a href="#30秒起步" class="headerlink" title="30秒起步"></a>30秒起步</h2><p>30秒起步分 <strong>4</strong> 步完成：</p><ol><li><code>node</code> 环境安装</li><li>安装 <code>json-server</code></li><li>创建数据库（其实就是一个 <code>json</code> 文件）</li><li>启动服务</li></ol><p><strong>1. node 环境安装</strong></p><p><code>json-server</code> 需要通过 <code>npm</code> 下载，<code>npm</code> 依赖在 <code>node</code> 中。</p><p><code>node</code> 常见的安装方法有2种。第一种是官方下载，第二种是使用 <code>nvm</code> 下载。自己选一种就行。</p><p><a href="https://links.jianshu.com/go?to=https%3A%2F%2Fnodejs.org%2Fen%2F">node 官网，点击进入主页下载</a>，下载完狂按“下一步”和“完成”就行了。</p><p><strong>注意：</strong> <code>node</code> 版本一定要 <code>12</code> 以上。不然会报以下错误：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">json-server <span class="keyword">requires</span> at least version <span class="number">12</span> of Node, please upgrade</span><br></pre></td></tr></table></figure><p><strong>2. 安装 json-server</strong></p><p>可以全局安装，也可以在某项目里安装。这里建议全局安装，因为以后你可能会对 <code>json-server</code> 产生依赖。</p><p>全局安装方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g json-server</span><br></pre></td></tr></table></figure><p><strong>3. 创建数据库</strong></p><p>在你本机创建一个文件夹，然后新建一个 <code>json</code> 文件，再填入数据即可。</p><p>建议文件名不要出现中文。</p><p>例：</p><p>创建 <code>json-server-demo</code> 文件夹，在 <code>json-server-demo</code> 里创建 <code>db.json</code> 文件（这些文件夹和文件名都可以自由命名）。</p><p><code>db.json</code> 文件录入以下数据（数据来自 <code>json-server</code> 官方文档，你也可以使用自己的数据）</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;posts&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;title&quot;</span><span class="punctuation">:</span> <span class="string">&quot;json-server&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;author&quot;</span><span class="punctuation">:</span> <span class="string">&quot;typicode&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;comments&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;body&quot;</span><span class="punctuation">:</span> <span class="string">&quot;some comment&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;postId&quot;</span><span class="punctuation">:</span> <span class="number">1</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;profile&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;typicode&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p><strong>4. 启动服务</strong></p><p>进入 <code>json-server-demo</code> 目录，打开终端输入以下命令即可</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">json-server <span class="attr">--watch</span> db<span class="selector-class">.json</span></span><br></pre></td></tr></table></figure><p><img src="./images/json-server_img/01.png" alt="img"></p><p>首页和三个接口都可以直接在浏览器访问，自己打开试试吧。</p><p>搞掂！</p><h2 id="查（get）"><a href="#查（get）" class="headerlink" title="查（get）"></a>查（get）</h2><p><code>json-server</code> <strong>查询数据</strong>需要使用 <code>GET</code> 方法。</p><p><strong>入门篇</strong> 只写一种查询方法，其他查询操作请往下滑，看 <strong>进阶篇</strong>。</p><p>上一小节创建了3个接口，我们可以直接在浏览器、postman或者自己写JS代码获取数据。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:<span class="comment">//localhost:3000/posts</span></span><br></pre></td></tr></table></figure><p><img src="./images/json-server_img/02.png" alt="img"></p><p><code>http://localhost:3000/comments</code> 和 <code>http://localhost:3000/profile</code> 两个接口可以自己尝试，这里不再啰嗦。</p><h2 id="增（post）"><a href="#增（post）" class="headerlink" title="增（post）"></a>增（post）</h2><p><code>json-server</code> <strong>新增数据</strong>需要使用 <code>POST</code> 方法。</p><blockquote><p>例：给 <code>posts</code> 添加一条新的数据。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:<span class="comment">//localhost:3000/posts</span></span><br></pre></td></tr></table></figure><p><img src="./images/json-server_img/03.png" alt="img"></p><p>03.png</p><p>这里使用 <code>POSt</code> 方法向 <code>/posts</code> 接口传输数据，<code>/posts</code> 原本的数据结构是包含 <code>id、title、author</code> 三个字段，<code>id</code> 默认是自增主键，不传的话会默认增加。</p><p>此时打开 <code>db.json</code> 文件看看，可以发现 <code>posts</code> 里多了一条数据。</p><p><img src="./images/json-server_img/04.png" alt="img"></p><blockquote><p><strong>需要注意的是：</strong><code>json-server</code> 默认情况下并不会限制你上传的数据格式和类型，所以需要你严格遵循自己设计的数据格式来添加和修改。</p></blockquote><h2 id="删（delete）"><a href="#删（delete）" class="headerlink" title="删（delete）"></a>删（delete）</h2><p><code>json-server</code> <strong>删除数据</strong>需要使用 <code>DELETE</code> 方法。</p><p>删除的公式是：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:<span class="comment">//localhost:3000/&#123;接口名&#125;/&#123;id&#125;</span></span><br></pre></td></tr></table></figure><blockquote><p>比如现在要删除刚刚上传的那条数据</p></blockquote><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;title&quot;</span><span class="punctuation">:</span> <span class="string">&quot;leihou&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;author&quot;</span><span class="punctuation">:</span> <span class="string">&quot;雷猴&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">2</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>可以看到刚刚上传的那条数据的 <code>id</code> 为 2</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:<span class="comment">//localhost:3000/posts/2</span></span><br></pre></td></tr></table></figure><p><img src="./images/json-server_img/05.png" alt="img"></p><p>此时打开 <code>db.json</code> 就会发现刚刚删除的那条数据已经没了。</p><p><img src="./images/json-server_img/06.png" alt="img"></p><blockquote><p><strong>需要注意的是：</strong> 删除成功 <code>Status</code> 会返回 <code>200</code>；如果删除的数据不存在会返回 <code>404</code>。</p></blockquote><p>我用 <code>axios</code> 模拟了一下。</p><p>删除<strong>成功</strong>返回的结果：</p><p><img src="./images/json-server_img/07.png" alt="img"></p><p>删除<strong>失败</strong>返回的结果：</p><p><img src="./images/json-server_img/08.png" alt="img"></p><h2 id="改（put-和-patch）"><a href="#改（put-和-patch）" class="headerlink" title="改（put 和 patch）"></a>改（put 和 patch）</h2><p>修改数据分为2个方法：</p><ul><li><code>put</code> ：覆盖</li><li><code>patch</code> ：更新</li></ul><p>公式如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:<span class="comment">//localhost:3000/posts/&#123;id&#125;</span></span><br></pre></td></tr></table></figure><p><strong>覆盖（put）</strong></p><blockquote><p>例：把 <code>id</code> 为 <code>1</code> 的数据改成 <code>&#123; &quot;title&quot;: &quot;leihou&quot;, &quot;author&quot;: &quot;雷猴&quot; &#125;</code></p></blockquote><p><img src="./images/json-server_img/09.png" alt="img"></p><p>此时打开 <code>db.json</code> 就可以看到 <code>id</code> 为 <code>1</code> 的数据已经发生变化。</p><blockquote><p>注意：原本的数据包含 <code>title</code> 和 <code>author</code> ，使用 <code>put</code> 时必须把这两个字段都写上，不然会删掉没传的字段。这就是 <strong>“覆盖”</strong> 的意思。</p></blockquote><p>例如：</p><p><img src="./images/json-server_img/10.png" alt="img"></p><p>此时查看 <code>db.json</code> 会发现数据被覆盖了</p><p><img src="./images/json-server_img/11.png" alt="img"></p><p><strong>更新（patch）</strong></p><p>先还原一下数据，改成如下图所示：</p><p><img src="./images/json-server_img/12.png" alt="img"></p><p>此时有 <code>title</code> 和 <code>author</code> 字段。</p><p>例：使用 <code>patch</code> 方法把 <code>id</code> 为 <code>1</code> 的数据 <code>title</code> 字段的值更改成 <code>hello</code> 。</p><p><img src="./images/json-server_img/13.png" alt="img"></p><p>13.png</p><p>打开 <code>db.json</code> 文件查看一下，会发现只改了 <code>id</code> 为 <code>1</code> 的 <code>title</code> 值，并没有删掉 <code>author</code> 这个字段的数据。</p><p><img src="./images/json-server_img/14.png" alt="img"></p><h1 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h1><h2 id="启动参数"><a href="#启动参数" class="headerlink" title="启动参数"></a>启动参数</h2><p>我们之前使用 <code>json-server --watch db.json</code> 这条命令启动了接口项目，其中 <code>json-server</code> 是服务启动的命令，<code>--watch</code> 是参数，<code>db.json</code> 是目标文件。</p><p>使用下面这条命令可以 <strong>查看配置项：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">json-server --<span class="built_in">help</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 或使用简写方式</span></span><br><span class="line">json-server -h</span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th>参数</th><th>简写</th><th>说明</th></tr></thead><tbody><tr><td>—config</td><td>-c</td><td>指定配置文件</td></tr><tr><td>—port</td><td>-p</td><td>端口号</td></tr><tr><td>—host</td><td>-H</td><td>主机地址</td></tr><tr><td>—watch</td><td>-w</td><td>监听文件</td></tr><tr><td>—routes</td><td>-r</td><td>指定路由文件</td></tr><tr><td>—middlewares</td><td>-m</td><td>指定中间件</td></tr><tr><td>—static</td><td>-s</td><td>设置静态文件</td></tr><tr><td>—read-only</td><td>—ro</td><td>只读</td></tr><tr><td>—no-cors</td><td>—nc</td><td>禁用跨源资源共享</td></tr><tr><td>—no-gzip</td><td>—ng</td><td>禁止GZIP</td></tr><tr><td>—snapshots</td><td>-S</td><td>设置快照目录</td></tr><tr><td>—delay</td><td>-d</td><td>设置反馈延时（ms）</td></tr><tr><td>—id</td><td>-i</td><td>设置数据的id属性（e.g. _id）</td></tr><tr><td>—foreignKeySuffix</td><td>—fks</td><td>设置外键后缀（如post_id中的_id）</td></tr><tr><td>—quiet</td><td>-q</td><td>禁止输出日志消息</td></tr><tr><td>—help</td><td>-h</td><td>显示帮助信息</td></tr><tr><td>—version</td><td>-v</td><td>显示版本号</td></tr></tbody></table></div><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>使用 <code>json-server --help</code> 可以查看到所有配置项。接下来我演示几个常见的配置操作。</p><h3 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h3><p>使用 <code>-p</code> 或者 <code>--port</code> 配置端口号，例如配置 <code>6666</code> 端口</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">json-server -<span class="selector-tag">p</span> <span class="number">6666</span> db<span class="selector-class">.json</span></span><br></pre></td></tr></table></figure><p>启动后</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">\&#123;^_^&#125;/ hi!</span><br><span class="line"></span><br><span class="line">Loading db.json</span><br><span class="line">Done</span><br><span class="line"></span><br><span class="line">Resources</span><br><span class="line">http:<span class="comment">//localhost:6666/posts</span></span><br><span class="line">http:<span class="comment">//localhost:6666/comments</span></span><br><span class="line">http:<span class="comment">//localhost:6666/profile</span></span><br><span class="line"></span><br><span class="line">Home</span><br><span class="line">http:<span class="comment">//localhost:6666</span></span><br></pre></td></tr></table></figure><h3 id="主机地址"><a href="#主机地址" class="headerlink" title="主机地址"></a>主机地址</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">json-server <span class="attr">--host</span> <span class="number">0.0</span>.<span class="number">0.0</span> db<span class="selector-class">.json</span></span><br></pre></td></tr></table></figure><p>这里设置了 <code>0.0.0.0</code> ，之后通过本机 <code>IP</code> 来访问即可。同一个局域网内的其他设备也可以通过这个地址来访问。</p><h2 id="查询的常用操作"><a href="#查询的常用操作" class="headerlink" title="查询的常用操作"></a>查询的常用操作</h2><p>查询是日常项目中接触最多的操作，所以查询是重点。</p><h3 id="普通查询"><a href="#普通查询" class="headerlink" title="普通查询"></a>普通查询</h3><p>用 <strong>30秒起步</strong> 的那份数据。</p><blockquote><p>查询 <code>/posts</code> 所有数据</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:<span class="comment">//0.0.0.0:3000/posts</span></span><br></pre></td></tr></table></figure><blockquote><p>查询 <code>/comments</code> 所有数据</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:<span class="comment">//localhost:3000/comments</span></span><br></pre></td></tr></table></figure><blockquote><p>查询 <code>/profile</code> 所有数据</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:<span class="comment">//localhost:3000/profile</span></span><br></pre></td></tr></table></figure><h3 id="id查询"><a href="#id查询" class="headerlink" title="id查询"></a>id查询</h3><p>将 <code>db.json</code> 的内容修改一下。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;posts&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;title&quot;</span><span class="punctuation">:</span> <span class="string">&quot;文章111&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;author&quot;</span><span class="punctuation">:</span> <span class="string">&quot;张三&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;title&quot;</span><span class="punctuation">:</span> <span class="string">&quot;文章222&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;author&quot;</span><span class="punctuation">:</span> <span class="string">&quot;李四&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>此时只有 <code>posts</code> 接口，里面有2条数据，<code>id</code> 分别为 <code>1</code> 和 <code>2</code>。</p><p>查询的公式是：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:<span class="comment">//localhost:3000/posts/&#123;id&#125;</span></span><br></pre></td></tr></table></figure><blockquote><p>查询 <code>id</code> 为 <code>2</code> 的数据</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:<span class="comment">//localhost:3000/posts/2</span></span><br></pre></td></tr></table></figure><p><img src="./images/json-server_img/15.png" alt="img"></p><h3 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h3><p>准备以下数据。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;posts&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;title&quot;</span><span class="punctuation">:</span> <span class="string">&quot;文章111&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;author&quot;</span><span class="punctuation">:</span> <span class="string">&quot;张三&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;title&quot;</span><span class="punctuation">:</span> <span class="string">&quot;文章222&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;author&quot;</span><span class="punctuation">:</span> <span class="string">&quot;李四&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">3</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;title&quot;</span><span class="punctuation">:</span> <span class="string">&quot;文章333&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;author&quot;</span><span class="punctuation">:</span> <span class="string">&quot;张三&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>可以看到里面有 <code>2条张三</code> 的数据，<code>1条李四</code> 的数据。</p><h4 id="单一条件查询"><a href="#单一条件查询" class="headerlink" title="单一条件查询"></a>单一条件查询</h4><p>查找 <code>author</code> 为 <code>张三</code> 的所有数据。</p><blockquote><p>查询 <code>author</code> 是 <code>张三</code> 的数据</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:<span class="comment">//localhost:3000/posts?author=张三</span></span><br></pre></td></tr></table></figure><p><img src="./images/json-server_img/16.png" alt="img"></p><p>16.png</p><p>在 <code>http://localhost:3000/posts</code> 后面加一个 <code>?</code> ，然后写上筛选条件即可。</p><h4 id="多条件查询（且）"><a href="#多条件查询（且）" class="headerlink" title="多条件查询（且）"></a>多条件查询（且）</h4><p>上面的数据，有2条张三的。</p><blockquote><p>这次要筛选的是 <code>author = 张三</code> 且 <code>title = 文章333</code> 的数据</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:<span class="comment">//localhost:3000/posts?author=张三&amp;title=文章333</span></span><br></pre></td></tr></table></figure><p><img src="./images/json-server_img/17.png" alt="img"></p><p>符合条件赛选的时候，使用 <code>&amp;</code> 号添加条件。</p><h4 id="多条件查询（或）"><a href="#多条件查询（或）" class="headerlink" title="多条件查询（或）"></a>多条件查询（或）</h4><blockquote><p>这次要筛选的是 <code>title = 222</code> 和 <code>title = 333</code> 这两条数据出来。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:<span class="comment">//localhost:3000/posts?title=文章222&amp;title=文章333</span></span><br></pre></td></tr></table></figure><p><img src="./images/json-server_img/18.png" alt="img"></p><p>重复使用 <code>title</code> ，会把符合条件的都筛查出来。</p><p>当然，我们还可以使用 <strong>模糊查询</strong> 来达到类似的效果，稍后会讲到。</p><h4 id="深度属性查询"><a href="#深度属性查询" class="headerlink" title="深度属性查询"></a>深度属性查询</h4><p>这里需要准备另一份数据才能展示这个知识点。</p><p>数据内容如下</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;posts&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;title&quot;</span><span class="punctuation">:</span> <span class="string">&quot;文章111&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;authorInfo&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;张三&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;age&quot;</span><span class="punctuation">:</span> <span class="number">20</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;title&quot;</span><span class="punctuation">:</span> <span class="string">&quot;文章222&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;authorInfo&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;李四&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;age&quot;</span><span class="punctuation">:</span> <span class="number">24</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>可以看到 <code>authorInfo</code> 里面还有子属性。</p><blockquote><p>查询 <code>authorInfo.name = 张三</code> 的数据。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:<span class="comment">//localhost:3000/posts?authorInfo.name=张三</span></span><br></pre></td></tr></table></figure><p><img src="./images/json-server_img/19.png" alt="img"></p><p>这里需要使用 <code>.</code> 的方式来访问子级数据，有点像 <code>js</code> 用点语法访问对象属性那样。</p><p>工作中我遇到这样的接口不多。</p><h3 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h3><p>使用 <code>_page</code> 和 <code>_limit</code>(可选) 对数据进行分页。需要注意，<code>_page</code> 和 <code>_limit</code> 前面都要有<strong>下划线</strong>。</p><ul><li><code>_page</code>：页码</li><li><code>_limit</code>：每页的数据量</li></ul><p>修改 <code>db.json</code> 里的数据方便测试分页功能，如下所示</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;comments&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span> <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span> <span class="attr">&quot;body&quot;</span><span class="punctuation">:</span> <span class="string">&quot;some comment 1&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;postId&quot;</span><span class="punctuation">:</span> <span class="number">1</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span> <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span> <span class="attr">&quot;body&quot;</span><span class="punctuation">:</span> <span class="string">&quot;some comment 2&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;postId&quot;</span><span class="punctuation">:</span> <span class="number">1</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span> <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">3</span><span class="punctuation">,</span> <span class="attr">&quot;body&quot;</span><span class="punctuation">:</span> <span class="string">&quot;some comment 3&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;postId&quot;</span><span class="punctuation">:</span> <span class="number">2</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span> <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">4</span><span class="punctuation">,</span> <span class="attr">&quot;body&quot;</span><span class="punctuation">:</span> <span class="string">&quot;some comment 4&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;postId&quot;</span><span class="punctuation">:</span> <span class="number">3</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span> <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">5</span><span class="punctuation">,</span> <span class="attr">&quot;body&quot;</span><span class="punctuation">:</span> <span class="string">&quot;some comment 5&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;postId&quot;</span><span class="punctuation">:</span> <span class="number">1</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span> <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">6</span><span class="punctuation">,</span> <span class="attr">&quot;body&quot;</span><span class="punctuation">:</span> <span class="string">&quot;some comment 6&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;postId&quot;</span><span class="punctuation">:</span> <span class="number">3</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span> <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">7</span><span class="punctuation">,</span> <span class="attr">&quot;body&quot;</span><span class="punctuation">:</span> <span class="string">&quot;some comment 7&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;postId&quot;</span><span class="punctuation">:</span> <span class="number">3</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span> <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">8</span><span class="punctuation">,</span> <span class="attr">&quot;body&quot;</span><span class="punctuation">:</span> <span class="string">&quot;some comment 8&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;postId&quot;</span><span class="punctuation">:</span> <span class="number">1</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span> <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">9</span><span class="punctuation">,</span> <span class="attr">&quot;body&quot;</span><span class="punctuation">:</span> <span class="string">&quot;some comment 9&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;postId&quot;</span><span class="punctuation">:</span> <span class="number">2</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span> <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">10</span><span class="punctuation">,</span> <span class="attr">&quot;body&quot;</span><span class="punctuation">:</span> <span class="string">&quot;some comment 10&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;postId&quot;</span><span class="punctuation">:</span> <span class="number">2</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span> <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">11</span><span class="punctuation">,</span> <span class="attr">&quot;body&quot;</span><span class="punctuation">:</span> <span class="string">&quot;some comment 11&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;postId&quot;</span><span class="punctuation">:</span> <span class="number">3</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span> <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">12</span><span class="punctuation">,</span> <span class="attr">&quot;body&quot;</span><span class="punctuation">:</span> <span class="string">&quot;some comment 11&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;postId&quot;</span><span class="punctuation">:</span> <span class="number">1</span> <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>准备了12条数据。</p><blockquote><p>需要获取第2页的数据，每页3条：</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:<span class="comment">//localhost:3000/comments?_page=2&amp;_limit=3</span></span><br></pre></td></tr></table></figure><p><img src="./images/json-server_img/20.png" alt="img"></p><p>除了要返回的数据外，还会在 <code>Headers</code> 里返回 <strong>总数；第一个、前一个、下一个、最后一个的链接</strong>。我用 <code>axios</code> 发个请求演示一下。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">axios.<span class="title function_">get</span>(<span class="string">&#x27;http://localhost:3000/comments&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">params</span>: &#123;</span><br><span class="line">   <span class="attr">_page</span>: <span class="number">2</span>,</span><br><span class="line">   <span class="attr">_limit</span>: <span class="number">3</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(res)</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(err)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><p>返回结果如下所示</p><p><img src="./images/json-server_img/21.png" alt="img"></p><p><code>x-total-count</code> 存放<strong>总数</strong>。</p><p><code>link</code> 字段里存放的是 <strong>第一个、前一个、下一个、最后一个</strong> 的链接地址</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;</span><br><span class="line">&lt;http://localhost:3000/comments?_page=1&amp;_limit=3&gt;; rel=\&quot;first\&quot;, &lt;http://localhost:3000/comments?_page=1&amp;_limit=3&gt;; rel=\&quot;prev\&quot;, &lt;http://localhost:3000/comments?_page=3&amp;_limit=3&gt;; rel=\&quot;next\&quot;, &lt;http://localhost:3000/comments?_page=4&amp;_limit=3&gt;; rel=\&quot;last\&quot;</span><br><span class="line">&quot;</span><br></pre></td></tr></table></figure><h3 id="排序查询"><a href="#排序查询" class="headerlink" title="排序查询"></a>排序查询</h3><p>需要添加 <strong>排序的标记 ( <code>_sort</code> )</strong>，然后设置 <strong>排序规则 ( <code>_order</code> )</strong>。</p><p>其中，排序规则有 <strong>升序 ( <code>asc</code> )</strong> 和 <strong>降序 ( <code>desc</code> )</strong> 。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:<span class="comment">//localhost:3000/&#123;接口名&#125;?_sort=要排序的字段名&amp;_order=排序规则</span></span><br></pre></td></tr></table></figure><p>以这份数据为例：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;comments&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span> <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">11</span><span class="punctuation">,</span> <span class="attr">&quot;body&quot;</span><span class="punctuation">:</span> <span class="string">&quot;some comment 1&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;postId&quot;</span><span class="punctuation">:</span> <span class="number">1</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span> <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span> <span class="attr">&quot;body&quot;</span><span class="punctuation">:</span> <span class="string">&quot;some comment 2&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;postId&quot;</span><span class="punctuation">:</span> <span class="number">1</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span> <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">3</span><span class="punctuation">,</span> <span class="attr">&quot;body&quot;</span><span class="punctuation">:</span> <span class="string">&quot;some comment 3&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;postId&quot;</span><span class="punctuation">:</span> <span class="number">2</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span> <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">10</span><span class="punctuation">,</span> <span class="attr">&quot;body&quot;</span><span class="punctuation">:</span> <span class="string">&quot;some comment 4&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;postId&quot;</span><span class="punctuation">:</span> <span class="number">3</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span> <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">7</span><span class="punctuation">,</span> <span class="attr">&quot;body&quot;</span><span class="punctuation">:</span> <span class="string">&quot;some comment 5&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;postId&quot;</span><span class="punctuation">:</span> <span class="number">1</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span> <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">6</span><span class="punctuation">,</span> <span class="attr">&quot;body&quot;</span><span class="punctuation">:</span> <span class="string">&quot;some comment 6&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;postId&quot;</span><span class="punctuation">:</span> <span class="number">3</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span> <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">5</span><span class="punctuation">,</span> <span class="attr">&quot;body&quot;</span><span class="punctuation">:</span> <span class="string">&quot;some comment 7&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;postId&quot;</span><span class="punctuation">:</span> <span class="number">3</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span> <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">8</span><span class="punctuation">,</span> <span class="attr">&quot;body&quot;</span><span class="punctuation">:</span> <span class="string">&quot;some comment 8&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;postId&quot;</span><span class="punctuation">:</span> <span class="number">1</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span> <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">9</span><span class="punctuation">,</span> <span class="attr">&quot;body&quot;</span><span class="punctuation">:</span> <span class="string">&quot;some comment 9&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;postId&quot;</span><span class="punctuation">:</span> <span class="number">2</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span> <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">4</span><span class="punctuation">,</span> <span class="attr">&quot;body&quot;</span><span class="punctuation">:</span> <span class="string">&quot;some comment 10&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;postId&quot;</span><span class="punctuation">:</span> <span class="number">2</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span> <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span> <span class="attr">&quot;body&quot;</span><span class="punctuation">:</span> <span class="string">&quot;some comment 11&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;postId&quot;</span><span class="punctuation">:</span> <span class="number">3</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span> <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">12</span><span class="punctuation">,</span> <span class="attr">&quot;body&quot;</span><span class="punctuation">:</span> <span class="string">&quot;some comment 11&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;postId&quot;</span><span class="punctuation">:</span> <span class="number">1</span> <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p><code>id</code> 的排序是乱的，如果使用普通的方式请求回来的数据是原模原样返回的。</p><h4 id="升序"><a href="#升序" class="headerlink" title="升序"></a>升序</h4><blockquote><p>以 <code>id</code> 为参考字段进行升序排列返回给客户端。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">http:<span class="comment">//localhost:3000/comments?_sort=id</span></span><br><span class="line"></span><br><span class="line">或</span><br><span class="line">http:<span class="comment">//localhost:3000/comments?_sort=id&amp;_order=asc</span></span><br></pre></td></tr></table></figure><p><img src="./images/json-server_img/22.png" alt="img"></p><p>返回的结果就会以 <code>id</code> 为参考字段升序排好。</p><p>普通升序排列的话，<code>_order=asc</code> 可以不传。只需指定 <strong>参考字段 ( <code>_sort</code> )</strong> 即可。</p><h4 id="降序"><a href="#降序" class="headerlink" title="降序"></a>降序</h4><blockquote><p>降序必须填好 <code>_order=desc</code> 。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:<span class="comment">//localhost:3000/comments?_sort=id&amp;_order=desc</span></span><br></pre></td></tr></table></figure><p><img src="./images/json-server_img/23.png" alt="img"></p><h4 id="多字段排序"><a href="#多字段排序" class="headerlink" title="多字段排序"></a>多字段排序</h4><p>这次的需求是：</p><ol><li>首先按 <code>postId</code> 升序排列</li><li>在 <code>1</code> 的基础上再对 <code>id</code> 进行倒序排列</li></ol><blockquote><p>多个字段用 <code>,</code> 分格。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:<span class="comment">//localhost:3000/comments?_sort=postId,id&amp;_order=asc,desc</span></span><br></pre></td></tr></table></figure><p>返回结果：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;comments&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span> <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">12</span><span class="punctuation">,</span> <span class="attr">&quot;body&quot;</span><span class="punctuation">:</span> <span class="string">&quot;some comment 11&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;postId&quot;</span><span class="punctuation">:</span> <span class="number">1</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span> <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">11</span><span class="punctuation">,</span> <span class="attr">&quot;body&quot;</span><span class="punctuation">:</span> <span class="string">&quot;some comment 1&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;postId&quot;</span><span class="punctuation">:</span> <span class="number">1</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span> <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">8</span><span class="punctuation">,</span> <span class="attr">&quot;body&quot;</span><span class="punctuation">:</span> <span class="string">&quot;some comment 8&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;postId&quot;</span><span class="punctuation">:</span> <span class="number">1</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span> <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">7</span><span class="punctuation">,</span> <span class="attr">&quot;body&quot;</span><span class="punctuation">:</span> <span class="string">&quot;some comment 5&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;postId&quot;</span><span class="punctuation">:</span> <span class="number">1</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span> <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span> <span class="attr">&quot;body&quot;</span><span class="punctuation">:</span> <span class="string">&quot;some comment 2&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;postId&quot;</span><span class="punctuation">:</span> <span class="number">1</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span> <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">9</span><span class="punctuation">,</span> <span class="attr">&quot;body&quot;</span><span class="punctuation">:</span> <span class="string">&quot;some comment 9&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;postId&quot;</span><span class="punctuation">:</span> <span class="number">2</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span> <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">4</span><span class="punctuation">,</span> <span class="attr">&quot;body&quot;</span><span class="punctuation">:</span> <span class="string">&quot;some comment 10&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;postId&quot;</span><span class="punctuation">:</span> <span class="number">2</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span> <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">3</span><span class="punctuation">,</span> <span class="attr">&quot;body&quot;</span><span class="punctuation">:</span> <span class="string">&quot;some comment 3&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;postId&quot;</span><span class="punctuation">:</span> <span class="number">2</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span> <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">10</span><span class="punctuation">,</span> <span class="attr">&quot;body&quot;</span><span class="punctuation">:</span> <span class="string">&quot;some comment 4&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;postId&quot;</span><span class="punctuation">:</span> <span class="number">3</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span> <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">6</span><span class="punctuation">,</span> <span class="attr">&quot;body&quot;</span><span class="punctuation">:</span> <span class="string">&quot;some comment 6&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;postId&quot;</span><span class="punctuation">:</span> <span class="number">3</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span> <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">5</span><span class="punctuation">,</span> <span class="attr">&quot;body&quot;</span><span class="punctuation">:</span> <span class="string">&quot;some comment 7&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;postId&quot;</span><span class="punctuation">:</span> <span class="number">3</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span> <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span> <span class="attr">&quot;body&quot;</span><span class="punctuation">:</span> <span class="string">&quot;some comment 11&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;postId&quot;</span><span class="punctuation">:</span> <span class="number">3</span> <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>符合需求。</p><h3 id="切片查询"><a href="#切片查询" class="headerlink" title="切片查询"></a>切片查询</h3><p>切片的意思是指定 <strong>头</strong> 和 <strong>尾</strong> ；也可以指定 <strong>头</strong> 和 <strong>片段长度</strong> 。</p><p>用到的关键字有：</p><ul><li><code>_start</code>：开始位置（下标，从0开始）</li><li><code>_end</code>：结束位置</li><li><code>_limit</code>：片段长度</li></ul><p><strong>总数</strong> 会放在 <code>headers</code> 里。</p><p>以这份数据为例</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;comments&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span> <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span> <span class="attr">&quot;body&quot;</span><span class="punctuation">:</span> <span class="string">&quot;some comment 1&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;postId&quot;</span><span class="punctuation">:</span> <span class="number">1</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span> <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span> <span class="attr">&quot;body&quot;</span><span class="punctuation">:</span> <span class="string">&quot;some comment 2&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;postId&quot;</span><span class="punctuation">:</span> <span class="number">1</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span> <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">3</span><span class="punctuation">,</span> <span class="attr">&quot;body&quot;</span><span class="punctuation">:</span> <span class="string">&quot;some comment 3&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;postId&quot;</span><span class="punctuation">:</span> <span class="number">2</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span> <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">4</span><span class="punctuation">,</span> <span class="attr">&quot;body&quot;</span><span class="punctuation">:</span> <span class="string">&quot;some comment 4&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;postId&quot;</span><span class="punctuation">:</span> <span class="number">3</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span> <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">5</span><span class="punctuation">,</span> <span class="attr">&quot;body&quot;</span><span class="punctuation">:</span> <span class="string">&quot;some comment 5&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;postId&quot;</span><span class="punctuation">:</span> <span class="number">1</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span> <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">6</span><span class="punctuation">,</span> <span class="attr">&quot;body&quot;</span><span class="punctuation">:</span> <span class="string">&quot;some comment 6&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;postId&quot;</span><span class="punctuation">:</span> <span class="number">3</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span> <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">7</span><span class="punctuation">,</span> <span class="attr">&quot;body&quot;</span><span class="punctuation">:</span> <span class="string">&quot;some comment 7&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;postId&quot;</span><span class="punctuation">:</span> <span class="number">3</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span> <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">8</span><span class="punctuation">,</span> <span class="attr">&quot;body&quot;</span><span class="punctuation">:</span> <span class="string">&quot;some comment 8&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;postId&quot;</span><span class="punctuation">:</span> <span class="number">1</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span> <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">9</span><span class="punctuation">,</span> <span class="attr">&quot;body&quot;</span><span class="punctuation">:</span> <span class="string">&quot;some comment 9&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;postId&quot;</span><span class="punctuation">:</span> <span class="number">2</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span> <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">10</span><span class="punctuation">,</span> <span class="attr">&quot;body&quot;</span><span class="punctuation">:</span> <span class="string">&quot;some comment 10&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;postId&quot;</span><span class="punctuation">:</span> <span class="number">2</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span> <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">11</span><span class="punctuation">,</span> <span class="attr">&quot;body&quot;</span><span class="punctuation">:</span> <span class="string">&quot;some comment 11&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;postId&quot;</span><span class="punctuation">:</span> <span class="number">3</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span> <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">12</span><span class="punctuation">,</span> <span class="attr">&quot;body&quot;</span><span class="punctuation">:</span> <span class="string">&quot;some comment 11&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;postId&quot;</span><span class="punctuation">:</span> <span class="number">1</span> <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><blockquote><p>需求：返回下标从 <code>2-6</code> 的数据</p></blockquote><p>使用 <code>_start</code> 和 <code>_end</code> 的方式</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:<span class="comment">//localhost:3000/comments?_start=2&amp;_end=6</span></span><br></pre></td></tr></table></figure><p>使用 <code>_start</code> 和 <code>_limit</code> 的方式</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:<span class="comment">//localhost:3000/comments?_start=2&amp;_limit=4</span></span><br></pre></td></tr></table></figure><p><img src="./images/json-server_img/24.png" alt="img"></p><h3 id="范围查询"><a href="#范围查询" class="headerlink" title="范围查询"></a>范围查询</h3><p>范围查询包括 <strong>大于等于</strong>、<strong>小于等于</strong>、<strong>不等于</strong> 三种情况。</p><h4 id="大于等于-get"><a href="#大于等于-get" class="headerlink" title="大于等于 _get"></a>大于等于 _get</h4><p><strong>大于等于</strong> 使用的关键字是 <code>_get</code> 。注意，前面有个下划线的。</p><blockquote><p>需求：查询 <code>comments</code> 接口 <code>id</code> 大于等于 <code>4</code> 的数据</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:<span class="comment">//localhost:3000/comments?id_gte=4</span></span><br></pre></td></tr></table></figure><p><img src="./images/json-server_img/25.png" alt="img"></p><h4 id="小于等于-lte"><a href="#小于等于-lte" class="headerlink" title="小于等于 _lte"></a>小于等于 _lte</h4><blockquote><p>需求：查询 <code>comments</code> 接口 <code>id</code> 小于等于 <code>4</code> 的数据</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:<span class="comment">//localhost:3000/comments?id_lte=4</span></span><br></pre></td></tr></table></figure><p><img src="./images/json-server_img/26.png" alt="img"></p><p>联合一起使用</p><blockquote><p>需求：查询 <code>comments</code> 接口 <code>id</code> 大于等于 <code>4</code> 且 小于等于 <code>6</code> 的数据</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:<span class="comment">//localhost:3000/comments?id_gte=4&amp;id_lte=6</span></span><br></pre></td></tr></table></figure><p><img src="./images/json-server_img/27.png" alt="img"></p><h4 id="不等于-ne"><a href="#不等于-ne" class="headerlink" title="不等于 _ne"></a>不等于 _ne</h4><blockquote><p>需求：查询 <code>comments</code> 接口 <code>id</code> 不等于 <code>2</code> 的数据</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:<span class="comment">//localhost:3000/comments?id_ne=2</span></span><br></pre></td></tr></table></figure><p><img src="./images/json-server_img/28.png" alt="img"></p><h3 id="模糊查询"><a href="#模糊查询" class="headerlink" title="模糊查询"></a>模糊查询</h3><p>模糊查询的关键字是 <code>_like</code>。</p><blockquote><p>需求：查询 <code>comments</code> 接口 <code>body</code> 包含 <code>1</code> 的数据</p></blockquote><p><img src="./images/json-server_img/29.png" alt="img"></p><h3 id="全文查询"><a href="#全文查询" class="headerlink" title="全文查询"></a>全文查询</h3><p>全文查询的关键字是 <code>q</code></p><p>准备以下数据比较好演示</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;authors&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span> <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span> <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;zhangsan&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;age&quot;</span><span class="punctuation">:</span> <span class="number">18</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span> <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span> <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;lisi&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;age&quot;</span><span class="punctuation">:</span> <span class="number">21</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span> <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">3</span><span class="punctuation">,</span> <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;wangwu&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;age&quot;</span><span class="punctuation">:</span> <span class="number">24</span><span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><blockquote><p>查询所有字段中包含 <code>2</code> 的数据出来</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:<span class="comment">//localhost:3000/authors?q=2</span></span><br></pre></td></tr></table></figure><p><img src="./images/json-server_img/30.png" alt="img"></p><p>因为 <code>id</code> 为 <code>3</code> 的那条数据里 <code>age</code> 是 <code>24</code> ，也算是包含了 <code>2</code> 。</p><h3 id="外键关联查询"><a href="#外键关联查询" class="headerlink" title="外键关联查询"></a>外键关联查询</h3><p>外键查询需要 <strong>2个接口</strong> 关联查询。</p><p>准备以下数据方便演示</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;posts&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span> <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span> <span class="attr">&quot;title&quot;</span><span class="punctuation">:</span> <span class="string">&quot;文章111&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;author&quot;</span><span class="punctuation">:</span> <span class="string">&quot;张三&quot;</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span> <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span> <span class="attr">&quot;title&quot;</span><span class="punctuation">:</span> <span class="string">&quot;文章222&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;author&quot;</span><span class="punctuation">:</span> <span class="string">&quot;李四&quot;</span> <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;comments&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span> <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span> <span class="attr">&quot;body&quot;</span><span class="punctuation">:</span> <span class="string">&quot;some comment 1&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;postId&quot;</span><span class="punctuation">:</span> <span class="number">1</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span> <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span> <span class="attr">&quot;body&quot;</span><span class="punctuation">:</span> <span class="string">&quot;some comment 2&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;postId&quot;</span><span class="punctuation">:</span> <span class="number">1</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span> <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">3</span><span class="punctuation">,</span> <span class="attr">&quot;body&quot;</span><span class="punctuation">:</span> <span class="string">&quot;some comment 3&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;postId&quot;</span><span class="punctuation">:</span> <span class="number">2</span> <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p><code>posts</code> 里有2条数据。</p><p><code>comments</code> 里有3条数据，其中每条数据都有一个 <code>postId</code>，是对应 <code>posts</code> 每条数据的 <code>id</code>。</p><blockquote><p>需求：查询 <code>posts</code> 里 <code>id</code> 为 <code>1</code> 的所有 <code>comments</code> 内容</p></blockquote><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">http:</span>/<span class="regexp">/localhost:3000/posts</span><span class="regexp">/1/comments</span></span><br></pre></td></tr></table></figure><p><img src="./images/json-server_img/31.png" alt="img"></p><h3 id="关系拼装"><a href="#关系拼装" class="headerlink" title="关系拼装"></a>关系拼装</h3><p>关系拼装可以把关联的2个接口的数据拼接起来并返回。</p><p>其中有2种查询关系：</p><ul><li>包含子资源 <code>_embed</code></li><li>包含父资源 <code>_expand</code></li></ul><p>准备以下数据方便演示</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;posts&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span> <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span> <span class="attr">&quot;title&quot;</span><span class="punctuation">:</span> <span class="string">&quot;文章111&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;author&quot;</span><span class="punctuation">:</span> <span class="string">&quot;张三&quot;</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span> <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span> <span class="attr">&quot;title&quot;</span><span class="punctuation">:</span> <span class="string">&quot;文章222&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;author&quot;</span><span class="punctuation">:</span> <span class="string">&quot;李四&quot;</span> <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;comments&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span> <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span> <span class="attr">&quot;body&quot;</span><span class="punctuation">:</span> <span class="string">&quot;some comment 1&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;postId&quot;</span><span class="punctuation">:</span> <span class="number">1</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span> <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span> <span class="attr">&quot;body&quot;</span><span class="punctuation">:</span> <span class="string">&quot;some comment 2&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;postId&quot;</span><span class="punctuation">:</span> <span class="number">1</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span> <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">3</span><span class="punctuation">,</span> <span class="attr">&quot;body&quot;</span><span class="punctuation">:</span> <span class="string">&quot;some comment 3&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;postId&quot;</span><span class="punctuation">:</span> <span class="number">2</span> <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h4 id="包含子资源-embed"><a href="#包含子资源-embed" class="headerlink" title="包含子资源 _embed"></a>包含子资源 _embed</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:<span class="comment">//localhost:3000/posts?_embed=comments</span></span><br></pre></td></tr></table></figure><p><img src="./images/json-server_img/32.png" alt="img"></p><p>还可以拼接多个条件。</p><blockquote><p>需求：在 <code>comments</code> 里，把 <code>posts</code> 里 <code>id</code> 为 <code>2</code> 的数据找出来并拼接起来</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:<span class="comment">//localhost:3000/posts/2?_embed=comments</span></span><br></pre></td></tr></table></figure><p><img src="./images/json-server_img/33.png" alt="img"></p><h4 id="包含父资源-expand"><a href="#包含父资源-expand" class="headerlink" title="包含父资源 _expand"></a>包含父资源 _expand</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:<span class="comment">//localhost:3000/comments?_expand=post</span></span><br></pre></td></tr></table></figure><p><img src="./images/json-server_img/34.png" alt="img"></p><h3 id="配置路由"><a href="#配置路由" class="headerlink" title="配置路由"></a>配置路由</h3><p>有时候我们的 <code>api地址</code> 可能不像上面所有案例中那么简单，此时就可以使用 <strong>自定义路由</strong> 的方法来模拟。</p><p>比如模拟下面这个接口：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">http:</span>/<span class="regexp">/localhost:3000/api</span><span class="regexp">/users/</span><span class="number">1</span></span><br></pre></td></tr></table></figure><p>实现的步骤如下所示：</p><ol><li>创建 <code>routes.json</code> 文件（也可以不叫这个名字）</li><li>启动服务时使用 <code>--routes</code> 参数</li></ol><p>1、创建 <code>routes.json</code> ，并输入以下内容。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;/api/*&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/$1&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>2、启动服务</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">json-server db<span class="selector-class">.json</span> <span class="attr">--routes</span> routes<span class="selector-class">.json</span></span><br></pre></td></tr></table></figure><p>3、访问</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:<span class="comment">//localhost:3000/api/posts</span></span><br></pre></td></tr></table></figure><h2 id="静态资源"><a href="#静态资源" class="headerlink" title="静态资源"></a>静态资源</h2><p>静态资源包含 <code>html</code> 、<code>css</code> 、<code>js</code> 、图片、视频等资源。</p><h3 id="配置-1"><a href="#配置-1" class="headerlink" title="配置"></a>配置</h3><p>配置方式分2种：</p><ul><li>默认配置</li><li>指定资源位置</li></ul><h4 id="默认配置"><a href="#默认配置" class="headerlink" title="默认配置"></a>默认配置</h4><p>需要在根目录下创建 <code>public</code> 文件夹，里面放入 <code>html</code> 等文件。</p><p><img src="./images/json-server_img/35.png" alt="img"></p><p>然后在浏览器访问一下 <code>http://localhost:3000/</code></p><p><img src="./images/json-server_img/36.png" alt="img"></p><p>你也可以加入自己的 <code>css</code> 和 <code>js</code> 进行设计交互。</p><h4 id="指定资源位置"><a href="#指定资源位置" class="headerlink" title="指定资源位置"></a>指定资源位置</h4><p><code>json-server</code> 配资静态资源的默认方式是在根目录下创建 <code>public</code> 文件夹，然后里面放入静态资源。</p><p>但如果你不想使用 <code>public</code> 作为静态资源的文件夹，也可以自己起过另一个名字，然后在启动环境时使用 <code>--static</code> 来指定目标目录就行了。</p><p>比如我创建了一个 <code>some-other-dir</code> 作为静态资源的目录，使用以下命令指定以下即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">json-server db.json --<span class="type">static</span> ./some-other-dir</span><br></pre></td></tr></table></figure><h3 id="多媒体资源"><a href="#多媒体资源" class="headerlink" title="多媒体资源"></a>多媒体资源</h3><p>除了放 <code>html</code> 、<code>css</code> 和 <code>js</code> 资源外，还可以放图片和视频。</p><p>我以图片为例，我在 <code>public</code> 目录下添加一个图片。</p><p><img src="./images/json-server_img/37.png" alt="img"></p><p>直接在 <code>http://localhost:3000/</code> 后面跟着 <code>图片文件名</code> 即可。</p><p><img src="./images/json-server_img/38.png" alt="img"></p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="生成动态数据"><a href="#生成动态数据" class="headerlink" title="生成动态数据"></a>生成动态数据</h3><p>如果我们要模拟100条数据，甚至更多的话，创建 <code>json</code> 文件然后一条一条录入的方式真的很不合时。</p><p>此时我们可以使用 <code>js</code> 通过循环的方式来实现数据创建。</p><p>1、首先在根目录下创建一个 <code>db.js</code> 的文件。</p><p>2、输入一下内容</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> data = &#123; <span class="attr">users</span>: [] &#125;</span><br><span class="line">  <span class="comment">// 创建 100 个 users</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">    data.<span class="property">users</span>.<span class="title function_">push</span>(&#123; <span class="attr">id</span>: i, <span class="attr">name</span>: <span class="string">`user<span class="subst">$&#123;i&#125;</span>`</span> &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> data</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、运行 <code>js</code> 文件</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">json-server db<span class="selector-class">.js</span></span><br></pre></td></tr></table></figure><p>4、查询一下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:<span class="comment">//localhost:3000/users</span></span><br></pre></td></tr></table></figure><p><img src="./images/json-server_img/39.png" alt="img"></p><p>100条数据就直接生成了。</p><p>需要什么字段可以自己在 <code>js</code> 文件里配置。</p><h3 id="查询整个数据库"><a href="#查询整个数据库" class="headerlink" title="查询整个数据库"></a>查询整个数据库</h3><p>访问以下地址可以获得整个数据库的数据。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:<span class="comment">//localhost:3000/db</span></span><br></pre></td></tr></table></figure><h3 id="远程模式"><a href="#远程模式" class="headerlink" title="远程模式"></a>远程模式</h3><p>如果想使用互联网上的数据，也可以直接运行 <code>json-server</code> 然后加上远端的地址即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">json-server http:<span class="comment">//jsonplaceholder.typicode.com/db</span></span><br></pre></td></tr></table></figure><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&lt;code&gt;Ajax&lt;/code&gt; 是前端必学的一个知识点，但刚接触 &lt;code&gt;Ajax&lt;/code&gt; 的同学可能会因为&lt;strong&gt;没</summary>
      
    
    
    
    
    <category term="笔记" scheme="https://admin741-cl.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>常见面试题（开胃菜）</title>
    <link href="https://admin741-cl.github.io/posts/99be.html"/>
    <id>https://admin741-cl.github.io/posts/99be.html</id>
    <published>2022-05-08T04:33:33.000Z</published>
    <updated>2023-06-17T02:36:39.157Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-Vue3-0性能提升主要是体现在哪些方面"><a href="#1-Vue3-0性能提升主要是体现在哪些方面" class="headerlink" title="1.Vue3.0性能提升主要是体现在哪些方面"></a>1.Vue3.0性能提升主要是体现在哪些方面</h1><h2 id="1-响应式系统"><a href="#1-响应式系统" class="headerlink" title="1.响应式系统"></a>1.响应式系统</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">- <span class="title class_">Vue</span>.<span class="property">js</span> <span class="number">2.</span>x 中响应式系统的核心是 <span class="title class_">Object</span>.<span class="property">defineProperty</span>，劫持整个对象，然后进行深度遍历所有属性，给每个属性添加<span class="string">`getter`</span>和<span class="string">`setter`</span>，实现响应式</span><br><span class="line">- <span class="title class_">Vue</span>.<span class="property">js</span> <span class="number">3.</span>x 中使用 <span class="title class_">Proxy</span> 对象重写响应式系统</span><br><span class="line">- 可以监听动态新增的属性</span><br><span class="line">- 可以监听删除的属性</span><br><span class="line">- 可以监听数组的索引和length属性 </span><br><span class="line"></span><br><span class="line">* 实现原理:</span><br><span class="line"></span><br><span class="line">  * 通过<span class="title class_">Proxy</span>（代理）: 拦截对象中任意属性的变化, 包括：属性值的读写、属性的添加、属性的删除等。</span><br><span class="line"></span><br><span class="line">  * 通过<span class="title class_">Reflect</span>（反射）: 对源对象的属性进行操作。</span><br><span class="line"></span><br><span class="line">  * <span class="variable constant_">MDN</span>文档中描述的<span class="title class_">Proxy</span>与<span class="title class_">Reflect</span>：</span><br><span class="line"></span><br><span class="line">    * <span class="title class_">Proxy</span>：[<span class="title class_">Proxy</span> - <span class="title class_">JavaScript</span> | <span class="variable constant_">MDN</span>](<span class="attr">https</span>:<span class="comment">//developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy &quot;Proxy - JavaScript | MDN&quot;)</span></span><br><span class="line"></span><br><span class="line">    * <span class="title class_">Reflect</span>：[<span class="title class_">Reflect</span> - <span class="title class_">JavaScript</span> | <span class="variable constant_">MDN</span>](<span class="attr">https</span>:<span class="comment">//developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect &quot;Reflect - JavaScript | MDN&quot;)</span></span><br><span class="line">                                           </span><br><span class="line">       <span class="keyword">new</span> <span class="title class_">Proxy</span>(data, &#123;</span><br><span class="line">          <span class="comment">// 拦截读取属性值</span></span><br><span class="line">          get (target, prop) &#123;</span><br><span class="line">              <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(target, prop)</span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="comment">// 拦截设置属性值或添加新属性</span></span><br><span class="line">          set (target, prop, value) &#123;</span><br><span class="line">              <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">set</span>(target, prop, value)</span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="comment">// 拦截删除属性</span></span><br><span class="line">          deleteProperty (target, prop) &#123;</span><br><span class="line">              <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">deleteProperty</span>(target, prop)</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">  </span><br><span class="line">      proxy.<span class="property">name</span> = <span class="string">&#x27;tom&#x27;</span>   ![]</span><br></pre></td></tr></table></figure><h2 id="2-编译阶段"><a href="#2-编译阶段" class="headerlink" title="2.编译阶段"></a>2.编译阶段</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> Vue.js 2.x 通过标记静态节点，优化 diff 的过程</span><br><span class="line"><span class="bullet">-</span> Vue.js 3.x </span><br><span class="line"><span class="bullet">  *</span>   vue.js 3.x中标记和提升所有的静态节点，diff的时候只需要对比动态节点内容；</span><br><span class="line"><span class="bullet">  *</span>   Fragments（升级vetur插件): template中不需要唯一根节点，可以直接放文本或者同级标签</span><br><span class="line"><span class="bullet">  *</span>   静态提升(hoistStatic),当使用 hoistStatic 时,所有静态的节点都被提升到 render 方法之外.只会在应用启动的时候被创建一次,之后使用只需要应用提取的静态节点，随着每次的渲染被不停的复用。</span><br><span class="line"><span class="bullet">  *</span>   patch flag, 在动态标签末尾加上相应的标记,只能带 patchFlag 的节点才被认为是动态的元素,会被追踪属性的修改,能快速的找到动态节点,而不用逐个逐层遍历，提高了虚拟dom diff的性能。</span><br><span class="line"><span class="bullet">  *</span>   缓存事件处理函数cacheHandler,避免每次触发都要重新生成全新的function去更新之前的函数</span><br></pre></td></tr></table></figure><h2 id="3-源码体积"><a href="#3-源码体积" class="headerlink" title="3.源码体积"></a>3.源码体积</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> 相比Vue2，Vue3整体体积变小了，除了移出一些不常用的AP</span><br><span class="line"><span class="bullet">-</span> tree shanking</span><br><span class="line"><span class="bullet">  -</span> 任何一个函数，如ref、reavtived、computed等，仅仅在用到的时候才打包</span><br><span class="line"><span class="bullet">  -</span> 通过编译阶段的静态分析，找到没有引入的模块并打上标记,将这些模块都给摇掉</span><br></pre></td></tr></table></figure><h1 id="2-vue3有哪些新的组件"><a href="#2-vue3有哪些新的组件" class="headerlink" title="2.vue3有哪些新的组件"></a>2.vue3有哪些新的组件</h1><h2 id="1-Fragment"><a href="#1-Fragment" class="headerlink" title="1.Fragment"></a>1.Fragment</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">*</span>   在Vue2中: 组件必须有一个根标签</span><br><span class="line"></span><br><span class="line"><span class="bullet">*</span>   在Vue3中: 组件可以没有根标签, 内部会将多个标签包含在一个Fragment虚拟元素中</span><br><span class="line"></span><br><span class="line"><span class="bullet">*</span>   好处: 减少标签层级, 减小内存占用 </span><br></pre></td></tr></table></figure><h2 id="2-Teleport"><a href="#2-Teleport" class="headerlink" title="2.Teleport"></a>2.Teleport</h2><p>什么是Teleport？—— <code>Teleport</code> 是一种能够将我们的<strong>组件html结构</strong>移动到指定位置的技术。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">teleport</span> <span class="attr">to</span>=<span class="string">&quot;移动位置&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-if</span>=<span class="string">&quot;isShow&quot;</span> <span class="attr">class</span>=<span class="string">&quot;mask&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;dialog&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">h3</span>&gt;</span>我是一个弹窗<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;isShow = false&quot;</span>&gt;</span>关闭弹窗<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">teleport</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="3-Suspense"><a href="#3-Suspense" class="headerlink" title="3.Suspense"></a>3.Suspense</h2><ul><li><p>等待异步组件时渲染一些额外内容，让应用有更好的用户体验</p></li><li><p>使用步骤：</p><ul><li><p>异步引入组件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;defineAsyncComponent&#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Child</span> = <span class="title function_">defineAsyncComponent</span>(<span class="function">()=&gt;</span><span class="keyword">import</span>(<span class="string">&#x27;./components/Child.vue&#x27;</span>))</span><br></pre></td></tr></table></figure></li><li><p>使用<code>Suspense</code>包裹组件，并配置好<code>default</code> 与 <code>fallback</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h3</span>&gt;</span>我是App组件<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Suspense</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:default</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">Child</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:fallback</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">h3</span>&gt;</span>加载中.....<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">Suspense</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h1 id="3-Vue2-0-和-Vue3-0-有什么区别"><a href="#3-Vue2-0-和-Vue3-0-有什么区别" class="headerlink" title="3.Vue2.0 和 Vue3.0 有什么区别"></a>3.Vue2.0 和 Vue3.0 有什么区别</h1><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">1.</span> 响应式系统的重新配置，使用proxy替换Object.defineProperty</span><br><span class="line"><span class="bullet">2.</span> typescript支持</span><br><span class="line"><span class="bullet">3.</span> 新增组合API，更好的逻辑重用和代码组织</span><br><span class="line"><span class="bullet">4.</span> v-if和v-for的优先级</span><br><span class="line"><span class="bullet">5.</span> 静态元素提升</span><br><span class="line"><span class="bullet">6.</span> 虚拟节点静态标记</span><br><span class="line"><span class="bullet">7.</span> 生命周期变化</span><br><span class="line"><span class="bullet">8.</span> 打包体积优化</span><br><span class="line"><span class="bullet">9.</span> ssr渲染性能提升</span><br><span class="line"><span class="bullet">10.</span> 支持多个根节点</span><br></pre></td></tr></table></figure><h1 id="4-Vue-生命周期"><a href="#4-Vue-生命周期" class="headerlink" title="4.Vue 生命周期"></a>4.Vue 生命周期</h1><h2 id="1-vue2-x的生命周期"><a href="#1-vue2-x的生命周期" class="headerlink" title="1.vue2.x的生命周期"></a>1.vue2.x的生命周期</h2><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/68bee44057b94174b62cd1350936ec04~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="img"></p><h2 id="2-vue3-0的生命周期"><a href="#2-vue3-0的生命周期" class="headerlink" title="2.vue3.0的生命周期"></a>2.vue3.0的生命周期</h2><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/93eb8366f638409b9035610c3e9adefc~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="img"></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">*</span>   Vue3.0中可以继续使用Vue2.x中的生命周期钩子，但有有两个被更名：</span><br><span class="line"></span><br><span class="line"><span class="bullet">    *</span>   <span class="code">`beforeDestroy`</span>改名为 <span class="code">`beforeUnmount`</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">    *</span>   <span class="code">`destroyed`</span>改名为 <span class="code">`unmounted`</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">*</span>   Vue3.0也提供了 Composition API 形式的生命周期钩子，与Vue2.x中钩子对应关系如下：</span><br><span class="line"></span><br><span class="line"><span class="bullet">    *</span>   <span class="code">`beforeCreate`</span>===&gt;<span class="code">`setup()`</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">    *</span>   <span class="code">`created`</span>=======&gt;<span class="code">`setup()`</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">    *</span>   <span class="code">`beforeMount`</span> ===&gt;<span class="code">`onBeforeMount`</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">    *</span>   <span class="code">`mounted`</span>=======&gt;<span class="code">`onMounted`</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">    *</span>   <span class="code">`beforeUpdate`</span>===&gt;<span class="code">`onBeforeUpdate`</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">    *</span>   <span class="code">`updated`</span> =======&gt;<span class="code">`onUpdated`</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">    *</span>   <span class="code">`beforeUnmount`</span> ==&gt;<span class="code">`onBeforeUnmount`</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">    *</span>   <span class="code">`unmounted`</span> =====&gt;<span class="code">`onUnmounted`</span></span><br><span class="line"><span class="code">    </span></span><br><span class="line"><span class="code">    </span></span><br><span class="line"><span class="code">    </span></span><br><span class="line"><span class="code">Vue 实例有⼀个完整的⽣命周期，也就是从开始创建、初始化数据、编译模版、挂载Dom -&gt; 渲染、更新 -&gt; 渲染、卸载 等⼀系列过程，称这是Vue的⽣命周期。 </span></span><br><span class="line"><span class="code">1、beforeCreate（创建前） ：数据观测和初始化事件还未开始，此时 data 的响应式追踪、event/watcher 都还没有被设置，也就是说不能访问到data、computed、watch、methods上的方法和数据。 </span></span><br><span class="line"><span class="code">2、created（创建后） ：实例创建完成，实例上配置的 options 包括 data、computed、watch、methods 等都配置完成，但是此时渲染得节点还未挂载到 DOM，所以不能访问到 `$el` 属性。 </span></span><br><span class="line"><span class="code">3、beforeMount（挂载前） ：在挂载开始之前被调用，相关的render函数首次被调用。实例已完成以下的配置：编译模板，把data里面的数据和模板生成html。此时还没有挂载html到页面上。 </span></span><br><span class="line"><span class="code">4、mounted（挂载后） ：在el被新创建的 vm.$el 替换，并挂载到实例上去之后调用。实例已完成以下的配置：用上面编译好的html内容替换el属性指向的DOM对象。完成模板中的html渲染到html 页面中。此过程中进行ajax交互。 </span></span><br><span class="line"><span class="code">5、beforeUpdate（更新前） ：响应式数据更新时调用，此时虽然响应式数据更新了，但是对应的真实 DOM 还没有被渲染。 </span></span><br><span class="line"><span class="code">6、updated（更新后）：在由于数据更改导致的虚拟DOM重新渲染和打补丁之后调用。此时 DOM 已经根据响应式数据的变化更新了。调用时，组件 DOM已经更新，所以可以执行依赖于DOM的操作。然而在大多数情况下，应该避免在此期间更改状态，因为这可能会导致更新无限循环。该钩子在服务器端渲染期间不被调用。 </span></span><br><span class="line"><span class="code">7、beforeDestroy（销毁前） ：实例销毁之前调用。这一步，实例仍然完全可用，`this` 仍能获取到实例。</span></span><br><span class="line"><span class="code">8、destroyed（销毁后） ：实例销毁后调用，调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。该钩子在服务端渲染期间不被调用。 </span></span><br></pre></td></tr></table></figure><h1 id="5-都说-Composition-API-和-React-Hook-很像，请问他们的区别是什么"><a href="#5-都说-Composition-API-和-React-Hook-很像，请问他们的区别是什么" class="headerlink" title="5.都说 Composition API 和 React Hook 很像，请问他们的区别是什么"></a>5.都说 Composition API 和 React Hook 很像，请问他们的区别是什么</h1><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">从 React Hook 从实现的角度来看，React Hook 是基于 useState 的调用顺序来确定下一个 re 渲染时间状态从哪个 useState 开始，所以有以下几个限制</span><br><span class="line"></span><br><span class="line"><span class="bullet">*</span>   不在循环中、条件、调用嵌套函数 Hook</span><br><span class="line"><span class="bullet">*</span>   你必须确保它总是在你这边 React Top level 调用函数 Hook</span><br><span class="line"><span class="bullet">*</span>   使用效果、使用备忘录 依赖关系必须手动确定</span><br><span class="line"></span><br><span class="line">和 Composition API 是基于 Vue 的响应系统，和 React Hook 相比</span><br><span class="line"></span><br><span class="line"><span class="bullet">*</span>   在设置函数中，一个组件实例只调用一次设置，而 React Hook 每次重新渲染时，都需要调用 Hook，给 React 带来的 GC 比 Vue 更大的压力，性能也相对 Vue 对我来说也比较慢</span><br><span class="line"><span class="bullet">*</span>   Compositon API 你不必担心调用的顺序，它也可以在循环中、条件、在嵌套函数中使用</span><br><span class="line"><span class="bullet">*</span>   响应式系统自动实现依赖关系收集，而且组件的性能优化是由 Vue 内部完成的，而 React Hook 的依赖关系需要手动传递，并且依赖关系的顺序必须得到保证，让路 useEffect、useMemo 等等，否则组件性能会因为依赖关系不正确而下降。</span><br><span class="line"></span><br><span class="line">虽然Compoliton API看起来像React Hook来使用，但它的设计思路也是React Hook的参考。</span><br></pre></td></tr></table></figure><h1 id="6-Composition-Api-与Options-Api-有什么不同"><a href="#6-Composition-Api-与Options-Api-有什么不同" class="headerlink" title="6. Composition Api 与Options Api 有什么不同"></a>6. Composition Api 与Options Api 有什么不同</h1><h2 id="1-Options-Api"><a href="#1-Options-Api" class="headerlink" title="1.Options Api"></a>1.Options Api</h2><p><code>Options API</code>，即大家常说的选项API，即以<code>vue</code>为后缀的文件，通过定义<code>methods</code>，<code>computed</code>，<code>watch</code>，<code>data</code>等属性与方法，共同处理页面逻辑</p><p>如下图：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8d6769c3019e479c88121ed726398703~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="img"></p><p>可以看到<code>Options</code>代码编写方式，如果是组件状态，则写在<code>data</code>属性上，如果是方法，则写在<code>methods</code>属性上…</p><p>用组件的选项 (<code>data</code>、<code>computed</code>、<code>methods</code>、<code>watch</code>) 组织逻辑在大多数情况下都有效</p><p>然而，当组件变得复杂，导致对应属性的列表也会增长，这可能会导致组件难以阅读和理解</p><h2 id="2-Composition-Api"><a href="#2-Composition-Api" class="headerlink" title="2.Composition Api"></a>2.Composition Api</h2><p>在 Vue3 Composition API 中，组件根据逻辑功能来组织的，一个功能所定义的所有 API 会放在一起（更加的高内聚，低耦合）</p><p>即使项目很大，功能很多，我们都能快速的定位到这个功能所用到的所有 API</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/18337c0974434ae09ae141a116aff75b~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="img"></p><h2 id="3-对比"><a href="#3-对比" class="headerlink" title="3.对比"></a>3.对比</h2><p>下面对<code>Composition Api</code>与<code>Options Api</code>进行两大方面的比较</p><ul><li>逻辑组织</li><li>逻辑复用</li></ul><h3 id="逻辑组织"><a href="#逻辑组织" class="headerlink" title="逻辑组织"></a>逻辑组织</h3><h3 id="Options-API"><a href="#Options-API" class="headerlink" title="Options API"></a>Options API</h3><p>假设一个组件是一个大型组件，其内部有很多处理逻辑关注点（对应下图不用颜色）</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ba80a442eb69455fb3499f1493378a5f~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="img"></p><p>可以看到，这种碎片化使得理解和维护复杂组件变得困难</p><p>选项的分离掩盖了潜在的逻辑问题。此外，在处理单个逻辑关注点时，我们必须不断地“跳转”相关代码的选项块</p><h3 id="Compostion-API"><a href="#Compostion-API" class="headerlink" title="Compostion API"></a>Compostion API</h3><p>而<code>Compositon API</code>正是解决上述问题，将某个逻辑关注点相关的代码全都放在一个函数里，这样当需要修改一个功能时，就不再需要在文件中跳来跳去</p><p>下面举个简单例子，将处理<code>count</code>属性相关的代码放在同一个函数了</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function useCount() &#123;</span><br><span class="line">    let <span class="attr">count</span> = ref(<span class="number">10</span>)<span class="comment">;</span></span><br><span class="line">    let <span class="attr">double</span> = computed(() =&gt; &#123;</span><br><span class="line">        return count.value * 2<span class="comment">;</span></span><br><span class="line">    &#125;)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">    const <span class="attr">handleConut</span> = () =&gt; &#123;</span><br><span class="line">        <span class="attr">count.value</span> = count.value * <span class="number">2</span><span class="comment">;</span></span><br><span class="line">    &#125;<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">    console.log(count)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">    return &#123;</span><br><span class="line">        count,</span><br><span class="line">        double,</span><br><span class="line">        handleConut,</span><br><span class="line">    &#125;<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>组件上中使用<code>count</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineComponent</span>(&#123;</span><br><span class="line">    <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; count, double, handleConut &#125; = <span class="title function_">useCount</span>();</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            count,</span><br><span class="line">            double,</span><br><span class="line">            handleConut</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>再来一张图进行对比，可以很直观地感受到 <code>Composition API</code>在逻辑组织方面的优势，以后修改一个属性功能的时候，只需要跳到控制该属性的方法中即可</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ce453cd816a84cf2b7f295dbc3835314~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="img"></p><h3 id="逻辑复用"><a href="#逻辑复用" class="headerlink" title="逻辑复用"></a>逻辑复用</h3><p>在<code>Vue2</code>中，我们是用过<code>mixin</code>去复用相同的逻辑</p><p>下面举个例子，我们会另起一个<code>mixin.js</code>文件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">MoveMixin</span> = &#123;</span><br><span class="line">  <span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">x</span>: <span class="number">0</span>,</span><br><span class="line">      <span class="attr">y</span>: <span class="number">0</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="attr">methods</span>: &#123;</span><br><span class="line">    <span class="title function_">handleKeyup</span>(<span class="params">e</span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(e.<span class="property">code</span>);</span><br><span class="line">      <span class="comment">// 上下左右 x y</span></span><br><span class="line">      <span class="keyword">switch</span> (e.<span class="property">code</span>) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;ArrowUp&quot;</span>:</span><br><span class="line">          <span class="variable language_">this</span>.<span class="property">y</span>--;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;ArrowDown&quot;</span>:</span><br><span class="line">          <span class="variable language_">this</span>.<span class="property">y</span>++;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;ArrowLeft&quot;</span>:</span><br><span class="line">          <span class="variable language_">this</span>.<span class="property">x</span>--;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;ArrowRight&quot;</span>:</span><br><span class="line">          <span class="variable language_">this</span>.<span class="property">x</span>++;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="title function_">mounted</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;keyup&quot;</span>, <span class="variable language_">this</span>.<span class="property">handleKeyup</span>);</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="title function_">unmounted</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">window</span>.<span class="title function_">removeEventListener</span>(<span class="string">&quot;keyup&quot;</span>, <span class="variable language_">this</span>.<span class="property">handleKeyup</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>然后在组件中使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    Mouse position: x &#123;&#123; x &#125;&#125; / y &#123;&#123; y &#125;&#125;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">import mousePositionMixin from &#x27;./mouse&#x27;</span><br><span class="line">export default &#123;</span><br><span class="line">  mixins: [mousePositionMixin]</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>使用单个<code>mixin</code>似乎问题不大，但是当我们一个组件混入大量不同的 <code>mixins</code> 的时候</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mixins: [mousePositionMixin, fooMixin, barMixin, otherMixin]</span><br></pre></td></tr></table></figure><p>会存在两个非常明显的问题：</p><ul><li>命名冲突</li><li>数据来源不清晰</li></ul><p>现在通过<code>Compositon API</code>这种方式改写上面的代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; onMounted, onUnmounted, reactive &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">useMove</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> position = <span class="title function_">reactive</span>(&#123;</span><br><span class="line">    <span class="attr">x</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">y</span>: <span class="number">0</span>,</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">handleKeyup</span> = (<span class="params">e</span>) =&gt; &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(e.<span class="property">code</span>);</span><br><span class="line">    <span class="comment">// 上下左右 x y</span></span><br><span class="line">    <span class="keyword">switch</span> (e.<span class="property">code</span>) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;ArrowUp&quot;</span>:</span><br><span class="line">        <span class="comment">// y.value--;</span></span><br><span class="line">        position.<span class="property">y</span>--;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;ArrowDown&quot;</span>:</span><br><span class="line">        <span class="comment">// y.value++;</span></span><br><span class="line">        position.<span class="property">y</span>++;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;ArrowLeft&quot;</span>:</span><br><span class="line">        <span class="comment">// x.value--;</span></span><br><span class="line">        position.<span class="property">x</span>--;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;ArrowRight&quot;</span>:</span><br><span class="line">        <span class="comment">// x.value++;</span></span><br><span class="line">        position.<span class="property">x</span>++;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">onMounted</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;keyup&quot;</span>, handleKeyup);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="title function_">onUnmounted</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">window</span>.<span class="title function_">removeEventListener</span>(<span class="string">&quot;keyup&quot;</span>, handleKeyup);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123; position &#125;;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>在组件中使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    Mouse position: x &#123;&#123; x &#125;&#125; / y &#123;&#123; y &#125;&#125;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import &#123; useMove &#125; from &quot;./useMove&quot;;</span><br><span class="line">import &#123; toRefs &#125; from &quot;vue&quot;;</span><br><span class="line">export default &#123;</span><br><span class="line">  setup() &#123;</span><br><span class="line">    const &#123; position &#125; = useMove();</span><br><span class="line">    const &#123; x, y &#125; = toRefs(position);</span><br><span class="line">    return &#123;</span><br><span class="line">      x,</span><br><span class="line">      y,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>可以看到，整个数据来源清晰了，即使去编写更多的 hook 函数，也不会出现命名冲突的问题</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul><li>在逻辑组织和逻辑复用方面，<code>Composition API</code>是优于<code>Options API</code></li><li>因为<code>Composition API</code>几乎是函数，会有更好的类型推断。</li><li><code>Composition API</code>对 <code>tree-shaking</code> 友好，代码也更容易压缩</li><li><code>Composition API</code>中见不到<code>this</code>的使用，减少了<code>this</code>指向不明的情况</li><li>如果是小型组件，可以继续使用<code>Options API</code>，也是十分友好的。</li></ul><h1 id="7-什么是SPA单页面应用，首屏加载你是如何优化的"><a href="#7-什么是SPA单页面应用，首屏加载你是如何优化的" class="headerlink" title="7.什么是SPA单页面应用，首屏加载你是如何优化的"></a>7.什么是SPA单页面应用，首屏加载你是如何优化的</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">单页Web应用（single page web application，SPA），就是只有一张Web页面的应用，是加载单个HTML页面并在用户与应用程序交互时动态更新该页面的Web应用程序。我们开发的<span class="string">`Vue`</span>项目大多是借助个官方的<span class="string">`CLI`</span>脚手架，快速搭建项目，直接通过<span class="string">`new Vue`</span>构建一个实例，并将<span class="string">`el:&#x27;#app&#x27;`</span>挂载参数传入，最后通过<span class="string">`npm run build`</span>的方式打包后生成一个<span class="string">`index.html`</span>，称这种只有一个<span class="string">`HTML`</span>的页面为单页面应用。</span><br><span class="line"></span><br><span class="line">当然，<span class="string">`vue`</span>也可以像<span class="string">`jq`</span>一样引入，作为多页面应用的基础框架。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SPA首屏优化方式</span><br><span class="line"></span><br><span class="line">减小入口文件积</span><br><span class="line">静态资源本地缓存</span><br><span class="line">UI框架按需加载</span><br><span class="line">图片资源的压缩</span><br><span class="line">组件重复打包</span><br><span class="line">开启GZip压缩</span><br><span class="line">使用SSR</span><br></pre></td></tr></table></figure><h1 id="8-对Vue项目你做过哪些性能优化"><a href="#8-对Vue项目你做过哪些性能优化" class="headerlink" title="8.对Vue项目你做过哪些性能优化"></a>8.对Vue项目你做过哪些性能优化</h1><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">1、<span class="code">`v-if`</span>和<span class="code">`v-show`</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">*</span>   频繁切换时使用<span class="code">`v-show`</span>，利用其缓存特性</span><br><span class="line"><span class="bullet">*</span>   首屏渲染时使用<span class="code">`v-if`</span>，如果为<span class="code">`false`</span>则不进行渲染</span><br><span class="line"></span><br><span class="line">2、<span class="code">`v-for`</span>的<span class="code">`key`</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">*</span>   列表变化时，循环时使用唯一不变的<span class="code">`key`</span>，借助其本地复用策略</span><br><span class="line"><span class="bullet">*</span>   列表只进行一次渲染时，<span class="code">`key`</span>可以采用循环的<span class="code">`index`</span></span><br><span class="line"></span><br><span class="line">3、侦听器和计算属性</span><br><span class="line"></span><br><span class="line"><span class="bullet">*</span>   侦听器<span class="code">`watch`</span>用于数据变化时引起其他行为</span><br><span class="line"><span class="bullet">*</span>   多使用<span class="code">`compouter`</span>计算属性顾名思义就是新计算而来的属性，如果依赖的数据未发生变化，不会触发重新计算</span><br><span class="line"></span><br><span class="line">4、合理使用生命周期</span><br><span class="line"></span><br><span class="line"><span class="bullet">*</span>   在<span class="code">`destroyed`</span>阶段进行绑定事件或者定时器的销毁</span><br><span class="line"><span class="bullet">*</span>   使用动态组件的时候通过<span class="code">`keep-alive`</span>包裹进行缓存处理，相关的操作可以在<span class="code">`actived`</span>阶段激活</span><br><span class="line"></span><br><span class="line">5、数据响应式处理</span><br><span class="line"></span><br><span class="line"><span class="bullet">*</span>   不需要响应式处理的数据可以通过<span class="code">`Object.freeze`</span>处理，或者直接通过<span class="code">`this.xxx = xxx`</span>的方式进行定义</span><br><span class="line"><span class="bullet">*</span>   需要响应式处理的属性可以通过<span class="code">`this.$set`</span>的方式处理，而不是<span class="code">`JSON.parse(JSON.stringify(XXX))`</span>的方式</span><br><span class="line"></span><br><span class="line">6、路由加载方式</span><br><span class="line"></span><br><span class="line"><span class="bullet">*</span>   页面组件可以采用异步加载的方式</span><br><span class="line"></span><br><span class="line">7、插件引入</span><br><span class="line"></span><br><span class="line"><span class="bullet">*</span>   第三方插件可以采用按需加载的方式，比如<span class="code">`element-ui`</span>。</span><br><span class="line"></span><br><span class="line">8、减少代码量</span><br><span class="line"></span><br><span class="line"><span class="bullet">*</span>   采用<span class="code">`mixin`</span>的方式抽离公共方法</span><br><span class="line"><span class="bullet">*</span>   抽离公共组件</span><br><span class="line"><span class="bullet">*</span>   定义公共方法至公共<span class="code">`js`</span>中</span><br><span class="line"><span class="bullet">*</span>   抽离公共<span class="code">`css`</span></span><br><span class="line"></span><br><span class="line">9、编译方式</span><br><span class="line"></span><br><span class="line"><span class="bullet">*</span>   如果线上需要<span class="code">`template`</span>的编译，可以采用完成版<span class="code">`vue.esm.js`</span></span><br><span class="line"><span class="bullet">*</span>   如果线上无需<span class="code">`template`</span>的编译，可采用运行时版本<span class="code">`vue.runtime.esm.js`</span>，相比完整版体积要小大约<span class="code">`30%`</span></span><br><span class="line"></span><br><span class="line">10、渲染方式</span><br><span class="line"></span><br><span class="line"><span class="bullet">*</span>   服务端渲染，如果是需要<span class="code">`SEO`</span>的网站可以采用服务端渲染的方式</span><br><span class="line"><span class="bullet">*</span>   前端渲染，一些企业内部使用的后端管理系统可以采用前端渲染的方式</span><br><span class="line"></span><br><span class="line">11、字体图标的使用</span><br><span class="line"></span><br><span class="line"><span class="bullet">*</span>   有些图片图标尽可能使用字体图标</span><br></pre></td></tr></table></figure><h1 id="9-Vue组件通信的方式有哪些"><a href="#9-Vue组件通信的方式有哪些" class="headerlink" title="9.Vue组件通信的方式有哪些"></a>9.Vue组件通信的方式有哪些</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">vue中8种常规的通信方案</span><br><span class="line"></span><br><span class="line">通过 props 传递</span><br><span class="line">通过 $emit 触发自定义事件</span><br><span class="line">使用 ref</span><br><span class="line">EventBus</span><br><span class="line">$parent 或$root</span><br><span class="line">attrs 与 listeners</span><br><span class="line">Provide 与 Inject</span><br><span class="line">Vuex</span><br><span class="line"></span><br><span class="line">组件间通信的分类可以分成以下</span><br><span class="line"></span><br><span class="line">父子关系的组件数据传递选择 props  与 $emit进行传递，也可选择ref</span><br><span class="line">兄弟关系的组件数据传递可选择$bus，其次可以选择$parent进行传递</span><br><span class="line">祖先与后代组件数据传递可选择attrs与listeners或者 Provide与 Inject</span><br><span class="line">复杂关系的组件数据传递可以通过vuex存放共享的变量</span><br></pre></td></tr></table></figure><h1 id="10-Vue常用的修饰符有哪些"><a href="#10-Vue常用的修饰符有哪些" class="headerlink" title="10.Vue常用的修饰符有哪些"></a>10.Vue常用的修饰符有哪些</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"> 1、表单修饰符</span><br><span class="line"></span><br><span class="line">（1）`.lazy`</span><br><span class="line"></span><br><span class="line">在默认情况下，`v-model` 在每次 `input` 事件触发后将输入框的值与数据进行同步 ，可以添加 `lazy` 修饰符，从而转为在 `change` 事件之后进行同步:</span><br><span class="line"></span><br><span class="line">```</span><br><span class="line">&lt;input v-model.lazy=&quot;msg&quot;&gt;</span><br><span class="line"></span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">（2）`.number`</span><br><span class="line"></span><br><span class="line">如果想自动将用户的输入值转为数值类型，可以给 `v-model` 添加 `number` 修饰符：</span><br><span class="line"></span><br><span class="line">```</span><br><span class="line">&lt;input v-model.number=&quot;age&quot; type=&quot;number&quot;&gt;</span><br><span class="line"></span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">（3）`.trim`</span><br><span class="line"></span><br><span class="line">如果要自动过滤用户输入的首尾空白字符，可以给 `v-model` 添加 `trim` 修饰符：</span><br><span class="line"></span><br><span class="line">```</span><br><span class="line">&lt;input v-model.trim=&quot;msg&quot;&gt;</span><br><span class="line"></span><br><span class="line">```</span><br><span class="line"></span><br><span class="line"> 2、事件修饰符</span><br><span class="line"></span><br><span class="line"> （1）`.stop`</span><br><span class="line"></span><br><span class="line">阻止单击事件继续传播。</span><br><span class="line"></span><br><span class="line">```</span><br><span class="line">&lt;!--这里只会触发a--&gt;</span><br><span class="line">&lt;div @click=&quot;divClick&quot;&gt;&lt;a v-on:click.stop=&quot;aClick&quot;&gt;点击&lt;/a&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">（2）`.prevent`</span><br><span class="line"></span><br><span class="line">阻止标签的默认行为。</span><br><span class="line"></span><br><span class="line">```</span><br><span class="line">&lt;a href=&quot;http://www.baidu.com&quot; v-on:click.prevent=&quot;aClick&quot;&gt;点击&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">（3）`.capture`</span><br><span class="line"></span><br><span class="line">事件先在有`.capture`修饰符的节点上触发，然后在其包裹的内部节点中触发。</span><br><span class="line"></span><br><span class="line">```</span><br><span class="line">&lt;!--这里先执行divClick事件，然后再执行aClick事件--&gt;</span><br><span class="line">&lt;div @click=&quot;divClick&quot;&gt;&lt;a v-on:click=&quot;aClick&quot;&gt;点击&lt;/a&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">（4）`.self`</span><br><span class="line"></span><br><span class="line">只当在 event.target 是当前元素自身时触发处理函数，即事件不是从内部元素触发的。</span><br><span class="line"></span><br><span class="line">```</span><br><span class="line">&lt;!--在a标签上点击时只会触发aClick事件，只有点击phrase的时候才会触发divClick事件--&gt;</span><br><span class="line">&lt;div @click.self=&quot;divClick&quot;&gt;phrase&lt;a v-on:click=&quot;aClick&quot;&gt;点击&lt;/a&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">（5）`.once`</span><br><span class="line"></span><br><span class="line">不像其它只能对原生的 DOM 事件起作用的修饰符，`.once` 修饰符还能被用到自定义的组件事件上，表示当前事件只触发一次。</span><br><span class="line"></span><br><span class="line">```</span><br><span class="line">&lt;a v-on:click.once=&quot;aClick&quot;&gt;点击&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">```</span><br><span class="line">（6）`.passive`</span><br><span class="line"></span><br><span class="line">`.passive` 修饰符尤其能够提升移动端的性能</span><br><span class="line"></span><br><span class="line">```</span><br><span class="line">&lt;!-- 滚动事件的默认行为 (即滚动行为) 将会立即触发 --&gt;  </span><br><span class="line">&lt;!-- 而不会等待 `onScroll` 完成 --&gt;  </span><br><span class="line">&lt;!-- 这其中包含 `event.preventDefault()` 的情况 --&gt;  </span><br><span class="line">&lt;div v-on:scroll.passive=&quot;onScroll&quot;&gt;...&lt;/div&gt;</span><br><span class="line">```</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="11-Vue中的-nextTick有什么作用"><a href="#11-Vue中的-nextTick有什么作用" class="headerlink" title="11.Vue中的$nextTick有什么作用"></a>11.Vue中的$nextTick有什么作用</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> callbacks = []</span><br><span class="line"><span class="keyword">let</span> pending = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 完成两件事：</span></span><br><span class="line"><span class="comment"> *   1、用 try catch 包装 flushSchedulerQueue 函数，然后将其放入 callbacks 数组</span></span><br><span class="line"><span class="comment"> *   2、如果 pending 为 false，表示现在浏览器的任务队列中没有 flushCallbacks 函数</span></span><br><span class="line"><span class="comment"> *     如果 pending 为 true，则表示浏览器的任务队列中已经被放入了 flushCallbacks 函数，</span></span><br><span class="line"><span class="comment"> *     待执行 flushCallbacks 函数时，pending 会被再次置为 false，表示下一个 flushCallbacks 函数可以进入</span></span><br><span class="line"><span class="comment"> *     浏览器的任务队列了</span></span><br><span class="line"><span class="comment"> * pending 的作用：保证在同一时刻，浏览器的任务队列中只有一个 flushCallbacks 函数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">*</span>&#125; cb 接收一个回调函数 =&gt; flushSchedulerQueue</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">*</span>&#125; ctx 上下文</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns</span> </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">nextTick</span> (cb?: <span class="title class_">Function</span>, ctx?: <span class="title class_">Object</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> _resolve</span><br><span class="line">  <span class="comment">// 用 callbacks 数组存储经过包装的 cb 函数</span></span><br><span class="line">  callbacks.<span class="title function_">push</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (cb) &#123;</span><br><span class="line">      <span class="comment">// 用 try catch 包装回调函数，便于错误捕获</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        cb.<span class="title function_">call</span>(ctx)</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="title function_">handleError</span>(e, ctx, <span class="string">&#x27;nextTick&#x27;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (_resolve) &#123;</span><br><span class="line">      <span class="title function_">_resolve</span>(ctx)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">if</span> (!pending) &#123;</span><br><span class="line">    pending = <span class="literal">true</span></span><br><span class="line">    <span class="comment">// 执行 timerFunc，在浏览器的任务队列中（首选微任务队列）放入 flushCallbacks 函数</span></span><br><span class="line">    <span class="title function_">timerFunc</span>()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// $flow-disable-line</span></span><br><span class="line">  <span class="keyword">if</span> (!cb &amp;&amp; <span class="keyword">typeof</span> <span class="title class_">Promise</span> !== <span class="string">&#x27;undefined&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">      _resolve = resolve</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">官方对其的定义</span><br><span class="line">​</span><br><span class="line">在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM</span><br><span class="line">​</span><br><span class="line">什么意思呢？</span><br><span class="line">​</span><br><span class="line">我们可以理解成，Vue 在更新 DOM 时是异步执行的。当数据发生变化，Vue将开启一个异步更新队列，视图需要等队列中所有数据变化完成之后，再统一进行更新</span><br><span class="line">​</span><br><span class="line">Vue 的异步更新机制的核心是利用了浏览器的异步任务队列来实现的，首选微任务队列，宏任务队列次之。</span><br><span class="line">​</span><br><span class="line">当响应式数据更新后，会调用 dep.notify 方法，通知 dep 中收集的 watcher 去执行 update 方法，watcher.update 将 watcher 自己放入一个 watcher 队列（全局的 queue 数组）。</span><br><span class="line">​</span><br><span class="line">然后通过 nextTick 方法将一个刷新 watcher 队列的方法（flushSchedulerQueue）放入一个全局的 callbacks 数组中。</span><br><span class="line">​</span><br><span class="line">如果此时浏览器的异步任务队列中没有一个叫 flushCallbacks 的函数，则执行 timerFunc 函数，将 flushCallbacks 函数放入异步任务队列。如果异步任务队列中已经存在 flushCallbacks 函数，等待其执行完成以后再放入下一个 flushCallbacks 函数。</span><br><span class="line">​</span><br><span class="line">flushCallbacks 函数负责执行 callbacks 数组中的所有 flushSchedulerQueue 函数。</span><br><span class="line">​</span><br><span class="line">flushSchedulerQueue 函数负责刷新 watcher 队列，即执行 queue 数组中每一个 watcher 的 run 方法，从而进入更新阶段，比如执行组件更新函数或者执行用户 watch 的回调函数。</span><br></pre></td></tr></table></figure><h1 id="12-如何理解双向数据绑定"><a href="#12-如何理解双向数据绑定" class="headerlink" title="12.如何理解双向数据绑定"></a>12.如何理解双向数据绑定</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">我们都知道 Vue 是数据双向绑定的框架，双向绑定由三个重要部分构成</span><br><span class="line"></span><br><span class="line">数据层（Model）：应用的数据及业务逻辑</span><br><span class="line">视图层（<span class="keyword">View</span>）：应用的展示效果，各类UI组件</span><br><span class="line">业务逻辑层（ViewModel）：框架封装的核心，它负责将数据与视图关联起来</span><br><span class="line">而上面的这个分层的架构方案，可以用一个专业术语进行称呼：MVVM这里的控制层的核心功能便是 “数据双向绑定” 。自然，我们只需弄懂它是什么，便可以进一步了解数据绑定的原理</span><br><span class="line"></span><br><span class="line">理解ViewModel</span><br><span class="line">它的主要职责就是：</span><br><span class="line"></span><br><span class="line">数据变化后更新视图</span><br><span class="line">视图变化后更新数据</span><br><span class="line">当然，它还有两个主要部分组成</span><br><span class="line"></span><br><span class="line">监听器（Observer）：对所有数据的属性进行监听</span><br><span class="line">解析器（Compiler）：对每个元素节点的指令进行扫描跟解析,根据指令模板替换数据,以及绑定相应的更新函数</span><br></pre></td></tr></table></figure><h1 id="13-v-show和v-if有什么区别？你可以讲讲吗"><a href="#13-v-show和v-if有什么区别？你可以讲讲吗" class="headerlink" title="13.v-show和v-if有什么区别？你可以讲讲吗"></a>13.v-show和v-if有什么区别？你可以讲讲吗</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">v<span class="operator">-</span><span class="keyword">show</span> 与 v<span class="operator">-</span>if 的作用效果是相同的(不含v<span class="operator">-</span><span class="keyword">else</span>)，都能控制元素在页面是否显示,在用法上也是相同的</span><br><span class="line"></span><br><span class="line"><span class="operator">-</span> 区别 </span><br><span class="line">控制手段不同</span><br><span class="line">编译过程不同</span><br><span class="line">编译条件不同</span><br><span class="line"></span><br><span class="line">控制手段：v<span class="operator">-</span><span class="keyword">show</span>隐藏则是为该元素添加css<span class="comment">--display:none，dom元素依旧还在。v-if显示隐藏是将dom元素整个添加或删除</span></span><br><span class="line"></span><br><span class="line">编译过程：v<span class="operator">-</span>if切换有一个局部编译<span class="operator">/</span>卸载的过程，切换过程中合适地销毁和重建内部的事件监听和子组件；v<span class="operator">-</span><span class="keyword">show</span>只是简单的基于css切换</span><br><span class="line"></span><br><span class="line">编译条件：v<span class="operator">-</span>if是真正的条件渲染，它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。只有渲染条件为假时，并不做操作，直到为真才渲染</span><br><span class="line"></span><br><span class="line">v<span class="operator">-</span><span class="keyword">show</span> 由<span class="literal">false</span>变为<span class="literal">true</span>的时候不会触发组件的生命周期</span><br><span class="line"></span><br><span class="line">v<span class="operator">-</span>if由<span class="literal">false</span>变为<span class="literal">true</span>的时候，触发组件的beforeCreate、<span class="keyword">create</span>、beforeMount、mounted钩子，由<span class="literal">true</span>变为<span class="literal">false</span>的时候触发组件的beforeDestory、destoryed方法</span><br><span class="line"></span><br><span class="line">性能消耗：v<span class="operator">-</span>if有更高的切换消耗；v<span class="operator">-</span><span class="keyword">show</span>有更高的初始渲染消耗</span><br></pre></td></tr></table></figure><h1 id="14-有用过keep-alive吗？它有什么作用"><a href="#14-有用过keep-alive吗？它有什么作用" class="headerlink" title="14.有用过keep-alive吗？它有什么作用"></a>14.有用过keep-alive吗？它有什么作用</h1><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">`vue`中支持组件化，并且也有用于缓存的内置组件`keep-alive`可直接使用，使用场景为`路由组件`和`动态组件`。</span><br><span class="line"></span><br><span class="line">*   `activated`表示进入组件的生命周期，`deactivated`表示离开组件的生命周期</span><br><span class="line">*   `include`表示匹配到的才缓存，`exclude`表示匹配到的都不缓存</span><br><span class="line">*   `max`表示最多可以缓存多少组件</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">关于keep-alive的基本用法：</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">keep-alive</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">component</span> <span class="attr">:is</span>=<span class="string">&quot;view&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></span><br><span class="line">使用includes和exclude：</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">keep-alive</span> <span class="attr">include</span>=<span class="string">&quot;a,b&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">component</span> <span class="attr">:is</span>=<span class="string">&quot;view&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 正则表达式 (使用 `v-bind`) --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">keep-alive</span> <span class="attr">:include</span>=<span class="string">&quot;/a|b/&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">component</span> <span class="attr">:is</span>=<span class="string">&quot;view&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 数组 (使用 `v-bind`) --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">keep-alive</span> <span class="attr">:include</span>=<span class="string">&quot;[&#x27;a&#x27;, &#x27;b&#x27;]&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">component</span> <span class="attr">:is</span>=<span class="string">&quot;view&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></span><br><span class="line">匹配首先检查组件自身的 name 选项，如果 name 选项不可用，则匹配它的局部注册名称 (父组件 components 选项的键值)，匿名组件不能被匹配</span><br><span class="line"></span><br><span class="line">设置了 keep-alive 缓存的组件，会多出两个生命周期钩子（activated与deactivated）：</span><br><span class="line"></span><br><span class="line">首次进入组件时：beforeRouteEnter &gt; beforeCreate &gt; created&gt; mounted &gt; activated &gt; ... ... &gt; beforeRouteLeave &gt; deactivated</span><br><span class="line"></span><br><span class="line">再次进入组件时：beforeRouteEnter &gt;activated &gt; ... ... &gt; beforeRouteLeave &gt; deactivated</span><br></pre></td></tr></table></figure><h1 id="15-你可以实现一个虚拟DOM吗"><a href="#15-你可以实现一个虚拟DOM吗" class="headerlink" title="15.你可以实现一个虚拟DOM吗"></a>15.你可以实现一个虚拟DOM吗</h1><p><strong>先看浏览器对<code>HTML</code>的理解</strong>：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>My title<span class="tag">&lt;/<span class="name">h1</span>&gt;</span>  </span><br><span class="line">    Some text content  </span><br><span class="line">    <span class="comment">&lt;!-- <span class="doctag">TODO:</span> Add tagline --&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当浏览器读到这些代码时，它会建立一个DOM树来保持追踪所有内容，如同你会画一张家谱树来追踪家庭成员的发展一样。 上述 HTML 对应的 DOM 节点树如下图所示：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7ee0f38a11304a768737a2e7de69e7e9~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="544ef95bdd7c96a19d700ce613ab425a_dom-tree.png"></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">每个元素都是一个节点。每段文字也是一个节点。甚至注释也都是节点。一个节点就是页面的一个部分。就像家谱树一样，每个节点都可以有孩子节点 (也就是说每个部分可以包含其它的一些部分)。</span><br><span class="line"></span><br><span class="line"><span class="strong">**再看`Vue`对`HTML template`的理解**</span></span><br><span class="line"></span><br><span class="line">Vue 通过建立一个<span class="strong">**虚拟 DOM**</span> 来追踪自己要如何改变真实 DOM。因为它所包含的信息会告诉 Vue 页面上需要渲染什么样的节点，包括及其子节点的描述信息。我们把这样的节点描述为“虚拟节点 (virtual node)”，也常简写它为“<span class="strong">**VNode**</span>”。“虚拟 DOM”是我们对由 Vue 组件树建立起来的整个 VNode 树的称呼。</span><br><span class="line"></span><br><span class="line">简言之，浏览器对HTML的理解是DOM树，Vue对<span class="code">`HTML`</span>的理解是虚拟DOM，最后在<span class="code">`patch`</span>阶段通过DOM操作的api将其渲染成真实的DOM节点。</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h2 id="如何实现虚拟DOM"><a href="#如何实现虚拟DOM" class="headerlink" title="如何实现虚拟DOM"></a>如何实现虚拟DOM</h2><p>首先可以看看<code>vue</code>中<code>VNode</code>的结构</p><p>源码位置：src/core/vdom/vnode.js</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">export default <span class="keyword">class</span> <span class="title class_">VNode</span> &#123;</span><br><span class="line">  tag: string | void;</span><br><span class="line">  <span class="keyword">data</span>: VNodeData | void;</span><br><span class="line">  children: ?Array&lt;VNode&gt;;</span><br><span class="line">  text: string | void;</span><br><span class="line">  elm: Node | void;</span><br><span class="line">  ns: string | void;</span><br><span class="line">  context: Component | void; <span class="comment">// rendered in this component&#x27;s scope</span></span><br><span class="line">  functionalContext: Component | void; <span class="comment">// only for functional component root nodes</span></span><br><span class="line">  key: string | number | void;</span><br><span class="line">  componentOptions: VNodeComponentOptions | void;</span><br><span class="line">  componentInstance: Component | void; <span class="comment">// component instance</span></span><br><span class="line">  parent: VNode | void; <span class="comment">// component placeholder node</span></span><br><span class="line">  raw: boolean; <span class="comment">// contains raw HTML? (server only)</span></span><br><span class="line">  isStatic: boolean; <span class="comment">// hoisted static node</span></span><br><span class="line">  isRootInsert: boolean; <span class="comment">// necessary for enter transition check</span></span><br><span class="line">  isComment: boolean; <span class="comment">// empty comment placeholder?</span></span><br><span class="line">  isCloned: boolean; <span class="comment">// is a cloned node?</span></span><br><span class="line">  isOnce: boolean; <span class="comment">// is a v-once node?</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span> (</span><br><span class="line">    tag?: string,</span><br><span class="line">    <span class="keyword">data</span>?: VNodeData,</span><br><span class="line">    children?: ?Array&lt;VNode&gt;,</span><br><span class="line">    text?: string,</span><br><span class="line">    elm?: Node,</span><br><span class="line">    context?: Component,</span><br><span class="line">    componentOptions?: VNodeComponentOptions</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="comment">/*当前节点的标签名*/</span></span><br><span class="line">    <span class="keyword">this</span>.tag = tag</span><br><span class="line">    <span class="comment">/*当前节点对应的对象，包含了具体的一些数据信息，是一个VNodeData类型，可以参考VNodeData类型中的数据信息*/</span></span><br><span class="line">    <span class="keyword">this</span>.<span class="keyword">data</span> = <span class="keyword">data</span></span><br><span class="line">    <span class="comment">/*当前节点的子节点，是一个数组*/</span></span><br><span class="line">    <span class="keyword">this</span>.children = children</span><br><span class="line">    <span class="comment">/*当前节点的文本*/</span></span><br><span class="line">    <span class="keyword">this</span>.text = text</span><br><span class="line">    <span class="comment">/*当前虚拟节点对应的真实dom节点*/</span></span><br><span class="line">    <span class="keyword">this</span>.elm = elm</span><br><span class="line">    <span class="comment">/*当前节点的名字空间*/</span></span><br><span class="line">    <span class="keyword">this</span>.ns = undefined</span><br><span class="line">    <span class="comment">/*编译作用域*/</span></span><br><span class="line">    <span class="keyword">this</span>.context = context</span><br><span class="line">    <span class="comment">/*函数化组件作用域*/</span></span><br><span class="line">    <span class="keyword">this</span>.functionalContext = undefined</span><br><span class="line">    <span class="comment">/*节点的key属性，被当作节点的标志，用以优化*/</span></span><br><span class="line">    <span class="keyword">this</span>.key = <span class="keyword">data</span> &amp;&amp; <span class="keyword">data</span>.key</span><br><span class="line">    <span class="comment">/*组件的option选项*/</span></span><br><span class="line">    <span class="keyword">this</span>.componentOptions = componentOptions</span><br><span class="line">    <span class="comment">/*当前节点对应的组件的实例*/</span></span><br><span class="line">    <span class="keyword">this</span>.componentInstance = undefined</span><br><span class="line">    <span class="comment">/*当前节点的父节点*/</span></span><br><span class="line">    <span class="keyword">this</span>.parent = undefined</span><br><span class="line">    <span class="comment">/*简而言之就是是否为原生HTML或只是普通文本，innerHTML的时候为true，textContent的时候为false*/</span></span><br><span class="line">    <span class="keyword">this</span>.raw = <span class="literal">false</span></span><br><span class="line">    <span class="comment">/*静态节点标志*/</span></span><br><span class="line">    <span class="keyword">this</span>.isStatic = <span class="literal">false</span></span><br><span class="line">    <span class="comment">/*是否作为跟节点插入*/</span></span><br><span class="line">    <span class="keyword">this</span>.isRootInsert = <span class="literal">true</span></span><br><span class="line">    <span class="comment">/*是否为注释节点*/</span></span><br><span class="line">    <span class="keyword">this</span>.isComment = <span class="literal">false</span></span><br><span class="line">    <span class="comment">/*是否为克隆节点*/</span></span><br><span class="line">    <span class="keyword">this</span>.isCloned = <span class="literal">false</span></span><br><span class="line">    <span class="comment">/*是否有v-once指令*/</span></span><br><span class="line">    <span class="keyword">this</span>.isOnce = <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// DEPRECATED: alias for componentInstance for backwards compat.</span></span><br><span class="line">  <span class="comment">/* istanbul ignore next https://github.com/answershuto/learnVue*/</span></span><br><span class="line">  <span class="keyword">get</span> child (): Component | void &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.componentInstance</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>这里对<code>VNode</code>进行稍微的说明：</p><ul><li>所有对象的 <code>context</code> 选项都指向了 <code>Vue</code> 实例</li><li><code>elm</code> 属性则指向了其相对应的真实 <code>DOM</code> 节点</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vue<span class="string">`是通过`</span>createElement<span class="string">`生成`</span>VNode</span><br></pre></td></tr></table></figure><p>源码位置：src/core/vdom/create-element.js</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">createElement</span> (</span><br><span class="line">  <span class="attr">context</span>: <span class="title class_">Component</span>,</span><br><span class="line">  <span class="attr">tag</span>: <span class="built_in">any</span>,</span><br><span class="line">  <span class="attr">data</span>: <span class="built_in">any</span>,</span><br><span class="line">  <span class="attr">children</span>: <span class="built_in">any</span>,</span><br><span class="line">  <span class="attr">normalizationType</span>: <span class="built_in">any</span>,</span><br><span class="line">  <span class="attr">alwaysNormalize</span>: <span class="built_in">boolean</span></span><br><span class="line">): <span class="title class_">VNode</span> | <span class="title class_">Array</span>&lt;<span class="title class_">VNode</span>&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(data) || <span class="title function_">isPrimitive</span>(data)) &#123;</span><br><span class="line">    normalizationType = children</span><br><span class="line">    children = data</span><br><span class="line">    data = <span class="literal">undefined</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">isTrue</span>(alwaysNormalize)) &#123;</span><br><span class="line">    normalizationType = <span class="variable constant_">ALWAYS_NORMALIZE</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">_createElement</span>(context, tag, data, children, normalizationType)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>上面可以看到<code>createElement</code> 方法实际上是对 <code>_createElement</code> 方法的封装，对参数的传入进行了判断</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">export function <span class="built_in">_createElement</span>(</span><br><span class="line">    context: Component,</span><br><span class="line">    tag?: string | Class&lt;Component&gt; | Function | Object,</span><br><span class="line">    data?: VNodeData,</span><br><span class="line">    children?: any,</span><br><span class="line">    normalizationType?: number</span><br><span class="line">): VNode | Array&lt;VNode&gt; &#123;</span><br><span class="line">    if (isDef(data) &amp;&amp; <span class="built_in">isDef</span>((data: any)<span class="selector-class">.__ob__</span>)) &#123;</span><br><span class="line">        process<span class="selector-class">.env</span><span class="selector-class">.NODE_ENV</span> !== &#x27;production&#x27; &amp;&amp; <span class="built_in">warn</span>(</span><br><span class="line">            `Avoid using observed data object as vnode data: $&#123;JSON.stringify(data)&#125;\n` +</span><br><span class="line">            &#x27;Always create fresh vnode data objects in each render!&#x27;,</span><br><span class="line">            context`</span><br><span class="line">        )</span><br><span class="line">        return <span class="built_in">createEmptyVNode</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// object syntax in v-bind</span></span><br><span class="line">    if (isDef(data) &amp;&amp; <span class="built_in">isDef</span>(data.is)) &#123;</span><br><span class="line">        tag = data<span class="selector-class">.is</span></span><br><span class="line">    &#125;</span><br><span class="line">    if (!tag) &#123;</span><br><span class="line">        <span class="comment">// in case of component :is set to falsy value</span></span><br><span class="line">        return <span class="built_in">createEmptyVNode</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    ... </span><br><span class="line">    <span class="comment">// support single function children as default scoped slot</span></span><br><span class="line">    if (Array.isArray(children) &amp;&amp;</span><br><span class="line">        typeof children<span class="selector-attr">[0]</span> === &#x27;function&#x27;</span><br><span class="line">    ) &#123;</span><br><span class="line">        data = data || &#123;&#125;</span><br><span class="line">        data<span class="selector-class">.scopedSlots</span> = &#123; default: children[<span class="number">0</span>] &#125;</span><br><span class="line">        children<span class="selector-class">.length</span> = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    if (normalizationType === ALWAYS_NORMALIZE) &#123;</span><br><span class="line">        children = <span class="built_in">normalizeChildren</span>(children)</span><br><span class="line">    &#125; else if ( === SIMPLE_NORMALIZE) &#123;</span><br><span class="line">        children = <span class="built_in">simpleNormalizeChildren</span>(children)</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// 创建VNode</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>可以看到<code>_createElement</code>接收5个参数：</p><ul><li><code>context</code> 表示 <code>VNode</code> 的上下文环境，是 <code>Component</code> 类型</li><li>tag 表示标签，它可以是一个字符串，也可以是一个 <code>Component</code></li><li><code>data</code> 表示 <code>VNode</code> 的数据，它是一个 <code>VNodeData</code> 类型</li><li><code>children</code> 表示当前 <code>VNode</code>的子节点，它是任意类型的</li><li><code>normalizationType</code> 表示子节点规范的类型，类型不同规范的方法也就不一样，主要是参考 <code>render</code> 函数是编译生成的还是用户手写的</li></ul><p>根据<code>normalizationType</code> 的类型，<code>children</code>会有不同的定义</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if (<span class="attr">normalizationType</span> === ALWAYS_NORMALIZE) &#123;</span><br><span class="line">    <span class="attr">children</span> = normalizeChildren(children)</span><br><span class="line">&#125; else if ( === SIMPLE_NORMALIZE) &#123;</span><br><span class="line">    <span class="attr">children</span> = simpleNormalizeChildren(children)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p><code>simpleNormalizeChildren</code>方法调用场景是 <code>render</code> 函数是编译生成的</p><p><code>normalizeChildren</code>方法调用场景分为下面两种：</p><ul><li><code>render</code> 函数是用户手写的</li><li>编译 <code>slot</code>、<code>v-for</code> 的时候会产生嵌套数组</li></ul><p>无论是<code>simpleNormalizeChildren</code>还是<code>normalizeChildren</code>都是对<code>children</code>进行规范（使<code>children</code> 变成了一个类型为 <code>VNode</code> 的 <code>Array</code>），这里就不展开说了</p><p>规范化<code>children</code>的源码位置在：src/core/vdom/helpers/normalzie-children.js</p><p>在规范化<code>children</code>后，就去创建<code>VNode</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> vnode, ns</span><br><span class="line"><span class="comment">// 对tag进行判断</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> tag === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="title class_">Ctor</span></span><br><span class="line">  ns = (context.<span class="property">$vnode</span> &amp;&amp; context.<span class="property">$vnode</span>.<span class="property">ns</span>) || config.<span class="title function_">getTagNamespace</span>(tag)</span><br><span class="line">  <span class="keyword">if</span> (config.<span class="title function_">isReservedTag</span>(tag)) &#123;</span><br><span class="line">    <span class="comment">// 如果是内置的节点，则直接创建一个普通VNode</span></span><br><span class="line">    vnode = <span class="keyword">new</span> <span class="title class_">VNode</span>(</span><br><span class="line">      config.<span class="title function_">parsePlatformTagName</span>(tag), data, children,</span><br><span class="line">      <span class="literal">undefined</span>, <span class="literal">undefined</span>, context</span><br><span class="line">    )</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_">isDef</span>(<span class="title class_">Ctor</span> = <span class="title function_">resolveAsset</span>(context.<span class="property">$options</span>, <span class="string">&#x27;components&#x27;</span>, tag))) &#123;</span><br><span class="line">    <span class="comment">// component</span></span><br><span class="line">    <span class="comment">// 如果是component类型，则会通过createComponent创建VNode节点</span></span><br><span class="line">    vnode = <span class="title function_">createComponent</span>(<span class="title class_">Ctor</span>, data, context, children, tag)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    vnode = <span class="keyword">new</span> <span class="title class_">VNode</span>(</span><br><span class="line">      tag, data, children,</span><br><span class="line">      <span class="literal">undefined</span>, <span class="literal">undefined</span>, context</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// direct component options / constructor</span></span><br><span class="line">  vnode = <span class="title function_">createComponent</span>(tag, data, context, children)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">createComponent<span class="string">`同样是创建`</span><span class="title class_">VNode</span></span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>源码位置：src/core/vdom/create-component.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">createComponent</span> (</span><br><span class="line">  <span class="title class_">Ctor</span>: <span class="title class_">Class</span>&lt;<span class="title class_">Component</span>&gt; | <span class="title class_">Function</span> | <span class="title class_">Object</span> | <span class="keyword">void</span>,</span><br><span class="line">  <span class="attr">data</span>: ?<span class="title class_">VNodeData</span>,</span><br><span class="line">  <span class="attr">context</span>: <span class="title class_">Component</span>,</span><br><span class="line">  <span class="attr">children</span>: ?<span class="title class_">Array</span>&lt;<span class="title class_">VNode</span>&gt;,</span><br><span class="line">  tag?: string</span><br><span class="line">): <span class="title class_">VNode</span> | <span class="title class_">Array</span>&lt;<span class="title class_">VNode</span>&gt; | <span class="keyword">void</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">isUndef</span>(<span class="title class_">Ctor</span>)) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line"> <span class="comment">// 构建子类构造函数 </span></span><br><span class="line">  <span class="keyword">const</span> baseCtor = context.<span class="property">$options</span>.<span class="property">_base</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// plain options object: turn it into a constructor</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">isObject</span>(<span class="title class_">Ctor</span>)) &#123;</span><br><span class="line">    <span class="title class_">Ctor</span> = baseCtor.<span class="title function_">extend</span>(<span class="title class_">Ctor</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// if at this stage it&#x27;s not a constructor or an async component factory,</span></span><br><span class="line">  <span class="comment">// reject.</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="title class_">Ctor</span> !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span>) &#123;</span><br><span class="line">      <span class="title function_">warn</span>(<span class="string">`Invalid Component definition: <span class="subst">$&#123;<span class="built_in">String</span>(Ctor)&#125;</span>`</span>, context)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// async component</span></span><br><span class="line">  <span class="keyword">let</span> asyncFactory</span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">isUndef</span>(<span class="title class_">Ctor</span>.<span class="property">cid</span>)) &#123;</span><br><span class="line">    asyncFactory = <span class="title class_">Ctor</span></span><br><span class="line">    <span class="title class_">Ctor</span> = <span class="title function_">resolveAsyncComponent</span>(asyncFactory, baseCtor, context)</span><br><span class="line">    <span class="keyword">if</span> (<span class="title class_">Ctor</span> === <span class="literal">undefined</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">createAsyncPlaceholder</span>(</span><br><span class="line">        asyncFactory,</span><br><span class="line">        data,</span><br><span class="line">        context,</span><br><span class="line">        children,</span><br><span class="line">        tag</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  data = data || &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// resolve constructor options in case global mixins are applied after</span></span><br><span class="line">  <span class="comment">// component constructor creation</span></span><br><span class="line">  <span class="title function_">resolveConstructorOptions</span>(<span class="title class_">Ctor</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// transform component v-model data into props &amp; events</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">isDef</span>(data.<span class="property">model</span>)) &#123;</span><br><span class="line">    <span class="title function_">transformModel</span>(<span class="title class_">Ctor</span>.<span class="property">options</span>, data)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// extract props</span></span><br><span class="line">  <span class="keyword">const</span> propsData = <span class="title function_">extractPropsFromVNodeData</span>(data, <span class="title class_">Ctor</span>, tag)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// functional component</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">isTrue</span>(<span class="title class_">Ctor</span>.<span class="property">options</span>.<span class="property">functional</span>)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">createFunctionalComponent</span>(<span class="title class_">Ctor</span>, propsData, data, context, children)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// extract listeners, since these needs to be treated as</span></span><br><span class="line">  <span class="comment">// child component listeners instead of DOM listeners</span></span><br><span class="line">  <span class="keyword">const</span> listeners = data.<span class="property">on</span></span><br><span class="line">  <span class="comment">// replace with listeners with .native modifier</span></span><br><span class="line">  <span class="comment">// so it gets processed during parent component patch.</span></span><br><span class="line">  data.<span class="property">on</span> = data.<span class="property">nativeOn</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">isTrue</span>(<span class="title class_">Ctor</span>.<span class="property">options</span>.<span class="property">abstract</span>)) &#123;</span><br><span class="line">    <span class="keyword">const</span> slot = data.<span class="property">slot</span></span><br><span class="line">    data = &#123;&#125;</span><br><span class="line">    <span class="keyword">if</span> (slot) &#123;</span><br><span class="line">      data.<span class="property">slot</span> = slot</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 安装组件钩子函数，把钩子函数合并到data.hook中</span></span><br><span class="line">  <span class="title function_">installComponentHooks</span>(data)</span><br><span class="line"></span><br><span class="line">  <span class="comment">//实例化一个VNode返回。组件的VNode是没有children的</span></span><br><span class="line">  <span class="keyword">const</span> name = <span class="title class_">Ctor</span>.<span class="property">options</span>.<span class="property">name</span> || tag</span><br><span class="line">  <span class="keyword">const</span> vnode = <span class="keyword">new</span> <span class="title class_">VNode</span>(</span><br><span class="line">    <span class="string">`vue-component-<span class="subst">$&#123;Ctor.cid&#125;</span><span class="subst">$&#123;name ? <span class="string">`-<span class="subst">$&#123;name&#125;</span>`</span> : <span class="string">&#x27;&#x27;</span>&#125;</span>`</span>,</span><br><span class="line">    data, <span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="literal">undefined</span>, context,</span><br><span class="line">    &#123; <span class="title class_">Ctor</span>, propsData, listeners, tag, children &#125;,</span><br><span class="line">    asyncFactory</span><br><span class="line">  )</span><br><span class="line">  <span class="keyword">if</span> (__WEEX__ &amp;&amp; <span class="title function_">isRecyclableComponent</span>(vnode)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">renderRecyclableComponentTemplate</span>(vnode)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> vnode</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>稍微提下<code>createComponent</code>生成<code>VNode</code>的三个关键流程：</p><ul><li>构造子类构造函数<code>Ctor</code></li><li><code>installComponentHooks</code>安装组件钩子函数</li><li>实例化 <code>vnode</code></li></ul><h2 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h2><p><code>createElement</code> 创建 <code>VNode</code> 的过程，每个 <code>VNode</code> 有 <code>children</code>，<code>children</code> 每个元素也是一个<code>VNode</code>，这样就形成了一个虚拟树结构，用于描述真实的<code>DOM</code>树结构</p><h1 id="16-为什么data属性是一个函数而不是一个对象，具体原因是什么"><a href="#16-为什么data属性是一个函数而不是一个对象，具体原因是什么" class="headerlink" title="16.为什么data属性是一个函数而不是一个对象，具体原因是什么"></a>16.为什么data属性是一个函数而不是一个对象，具体原因是什么</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">是不是一定是函数，得看场景。并且，也无需担心什么时候该将<span class="string">`data`</span>写为函数还是对象，因为<span class="string">`vue`</span>内部已经做了处理，并在控制台输出错误信息。</span><br><span class="line"></span><br><span class="line">**场景一**：<span class="string">`new Vue(&#123;data: ...&#125;)`</span>  </span><br><span class="line">这种场景主要为项目入口或者多个<span class="string">`html`</span>页面各实例化一个<span class="string">`Vue`</span>时，这里的<span class="string">`data`</span>即可用对象的形式，也可用工厂函数返回对象的形式。因为，这里的<span class="string">`data`</span>只会出现一次，不存在重复引用而引起的数据污染问题。</span><br><span class="line"></span><br><span class="line">**场景二**：组件场景中的选项  </span><br><span class="line">在生成组件<span class="string">`vnode`</span>的过程中，组件会在生成构造函数的过程中执行合并策略：</span><br><span class="line"></span><br><span class="line"><span class="string">``</span><span class="string">`</span></span><br><span class="line"><span class="string">// data合并策略</span></span><br><span class="line"><span class="string">strats.data = function (</span></span><br><span class="line"><span class="string">  parentVal,</span></span><br><span class="line"><span class="string">  childVal,</span></span><br><span class="line"><span class="string">  vm</span></span><br><span class="line"><span class="string">) &#123;</span></span><br><span class="line"><span class="string">  if (!vm) &#123;</span></span><br><span class="line"><span class="string">    if (childVal &amp;&amp; typeof childVal !== &#x27;function&#x27;) &#123;</span></span><br><span class="line"><span class="string">      process.env.NODE_ENV !== &#x27;production&#x27; &amp;&amp; warn(</span></span><br><span class="line"><span class="string">        &#x27;The &quot;data&quot; option should be a function &#x27; +</span></span><br><span class="line"><span class="string">        &#x27;that returns a per-instance value in component &#x27; +</span></span><br><span class="line"><span class="string">        &#x27;definitions.&#x27;,</span></span><br><span class="line"><span class="string">        vm</span></span><br><span class="line"><span class="string">      );</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">      return parentVal</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    return mergeDataOrFn(parentVal, childVal)</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  return mergeDataOrFn(parentVal, childVal, vm)</span></span><br><span class="line"><span class="string">&#125;;</span></span><br><span class="line"><span class="string">`</span><span class="string">``</span></span><br><span class="line"></span><br><span class="line">如果合并过程中发现子组件的数据不是函数，即<span class="string">`typeof childVal !== &#x27;function&#x27;`</span>成立，进而在开发环境会在控制台输出警告并且直接返回<span class="string">`parentVal`</span>，说明这里压根就没有把<span class="string">`childVal`</span>中的任何<span class="string">`data`</span>信息合并到<span class="string">`options`</span>中去。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">上面讲到组件data必须是一个函数，不知道大家有没有思考过这是为什么呢？</span><br><span class="line"></span><br><span class="line">在我们定义好一个组件的时候，vue最终都会通过<span class="title class_">Vue</span>.<span class="title function_">extend</span>()构成组件实例</span><br><span class="line"></span><br><span class="line">这里我们模仿组件构造函数，定义data属性，采用对象的形式</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Component</span>(<span class="params"></span>)&#123;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Component</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">data</span> = &#123;</span><br><span class="line">  count : <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line">创建两个组件实例</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> componentA = <span class="keyword">new</span> <span class="title class_">Component</span>()</span><br><span class="line"><span class="keyword">const</span> componentB = <span class="keyword">new</span> <span class="title class_">Component</span>()</span><br><span class="line">修改componentA组件data属性的值，componentB中的值也发生了改变</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(componentB.<span class="property">data</span>.<span class="property">count</span>)  <span class="comment">// 0</span></span><br><span class="line">componentA.<span class="property">data</span>.<span class="property">count</span> = <span class="number">1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(componentB.<span class="property">data</span>.<span class="property">count</span>)  <span class="comment">// 1</span></span><br><span class="line">产生这样的原因这是两者共用了同一个内存地址，componentA修改的内容，同样对componentB产生了影响</span><br><span class="line"></span><br><span class="line">如果我们采用函数的形式，则不会出现这种情况（函数返回的对象内存地址并不相同）</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Component</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">data</span> = <span class="variable language_">this</span>.<span class="title function_">data</span>()</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Component</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">data</span> = <span class="keyword">function</span> (<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      count : <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">修改componentA组件data属性的值，componentB中的值不受影响</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(componentB.<span class="property">data</span>.<span class="property">count</span>)  <span class="comment">// 0</span></span><br><span class="line">componentA.<span class="property">data</span>.<span class="property">count</span> = <span class="number">1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(componentB.<span class="property">data</span>.<span class="property">count</span>)  <span class="comment">// 0</span></span><br><span class="line">vue组件可能会有很多个实例，采用函数返回一个全新data形式，使每个实例对象的数据不会受到其他实例对象数据的污染</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h1 id="17-Vue2的初始化过程你有过了解吗，做了哪些事情"><a href="#17-Vue2的初始化过程你有过了解吗，做了哪些事情" class="headerlink" title="17.Vue2的初始化过程你有过了解吗，做了哪些事情"></a>17.Vue2的初始化过程你有过了解吗，做了哪些事情</h1><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">new Vue走到了vue的构造函数中：`<span class="attribute">src</span>\core\instance\index<span class="selector-class">.js</span>`文件。</span><br><span class="line"></span><br><span class="line">this<span class="selector-class">._init</span>(options)</span><br><span class="line"></span><br><span class="line">然后从Mixin增加的原型方法看，<span class="built_in">initMixin</span>(Vue)，调用的是为Vue增加的原型方法_init</span><br><span class="line"></span><br><span class="line"><span class="comment">// src/core/instance/init.js</span></span><br><span class="line"></span><br><span class="line">function initMixin (Vue) &#123;</span><br><span class="line">  Vue<span class="selector-class">.prototype</span><span class="selector-class">._init</span> = function (options) &#123;</span><br><span class="line">     <span class="selector-tag">var</span> vm = this; 创建vm, </span><br><span class="line">     ...</span><br><span class="line">     <span class="comment">// 合并options 到 vm.$options</span></span><br><span class="line">     vm.<span class="variable">$options</span> = <span class="built_in">mergeOptions</span>(  </span><br><span class="line">       resolveConstructorOptions(vm.constructor), </span><br><span class="line">       options || &#123;&#125;,  </span><br><span class="line">       vm </span><br><span class="line">     );</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">   <span class="built_in">initLifecycle</span>(vm); <span class="comment">//初始生命周期</span></span><br><span class="line">   <span class="built_in">initEvents</span>(vm); <span class="comment">//初始化事件</span></span><br><span class="line">   <span class="built_in">initRender</span>(vm); <span class="comment">//初始render函数</span></span><br><span class="line">   <span class="built_in">callHook</span>(vm, &#x27;beforeCreate&#x27;); <span class="comment">//执行 beforeCreate生命周期钩子</span></span><br><span class="line">   ...</span><br><span class="line">   <span class="built_in">initState</span>(vm);  <span class="comment">//初始化data，props，methods computed，watch </span></span><br><span class="line">   ...</span><br><span class="line">   <span class="built_in">callHook</span>(vm, &#x27;created&#x27;);  <span class="comment">//执行 created 生命周期钩子</span></span><br><span class="line">   </span><br><span class="line">   if (vm.$options.el) &#123;</span><br><span class="line">      vm.<span class="variable">$mount</span>(vm.$options.el); <span class="comment">//这里也是重点，下面需要用到</span></span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">总结</span><br><span class="line"></span><br><span class="line">所以，从上面的函数看来，new vue所做的事情，就像一个流程图一样展开了，分别是</span><br><span class="line"></span><br><span class="line">-   合并配置</span><br><span class="line">-   初始化生命周期</span><br><span class="line">-   初始化事件</span><br><span class="line">-   初始化渲染</span><br><span class="line">-   调用 `beforeCreate` 钩子函数</span><br><span class="line">-   init injections and reactivity（这个阶段属性都已注入绑定，而且被 `<span class="variable">$watch</span>` 变成reactivity，但是 `<span class="variable">$el</span>` 还是没有生成，也就是DOM没有生成）</span><br><span class="line">-   初始化state状态（初始化了data、props、computed、watcher）</span><br><span class="line">-   调用created钩子函数。</span><br><span class="line"></span><br><span class="line">在初始化的最后，检测到如果有 el 属性，则调用 vm.<span class="variable">$mount</span> 方法挂载 vm，挂载的目标就是把模板渲染成最终的 DOM。</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h1 id="18-Vue3初始化的一个大概流程"><a href="#18-Vue3初始化的一个大概流程" class="headerlink" title="18.Vue3初始化的一个大概流程"></a>18.Vue3初始化的一个大概流程</h1><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line">- 初始化的一个大概流程</span><br><span class="line"></span><br><span class="line"><span class="built_in">createApp</span>() =&gt; <span class="built_in">mount</span>() =&gt; <span class="built_in">render</span>() =&gt; <span class="built_in">patch</span>() =&gt; <span class="built_in">processComponent</span>() =&gt; <span class="built_in">mountComponent</span>()</span><br><span class="line"></span><br><span class="line">- 简易版流程编写</span><br><span class="line"></span><br><span class="line"><span class="number">1</span><span class="selector-class">.Vue</span><span class="selector-class">.createApp</span>() 实际执行的是renderer的<span class="built_in">createApp</span>()</span><br><span class="line"></span><br><span class="line"><span class="number">2</span><span class="selector-class">.renderer</span>是createRenderer这个方法创建</span><br><span class="line"></span><br><span class="line"><span class="number">3</span><span class="selector-class">.renderer</span>的<span class="built_in">createApp</span>()是<span class="built_in">createAppAPI</span>()返回的</span><br><span class="line"></span><br><span class="line"><span class="number">4</span><span class="selector-class">.createAppApi</span>接受到render之后，创建一个app实例，定义mount方法</span><br><span class="line"></span><br><span class="line"><span class="number">5</span><span class="selector-class">.mount</span>会调用render函数。将vnode转换为真实dom</span><br><span class="line"></span><br><span class="line"><span class="built_in">createRenderer</span>() =&gt; renderer =&gt; renderer<span class="selector-class">.createApp</span>() &lt;= <span class="built_in">createAppApi</span>()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;<span class="selector-tag">div</span> id=&quot;app&quot;&gt;&lt;/<span class="selector-tag">div</span>&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="comment">// 3.createAppAPI</span></span><br><span class="line">    const createAppAPI = render =&gt; &#123;</span><br><span class="line">        return function <span class="built_in">createApp</span>(rootComponent) &#123;</span><br><span class="line">            <span class="comment">// 返回应用程序实例</span></span><br><span class="line">            const app = &#123;</span><br><span class="line">                <span class="built_in">mount</span>(rootContainer) &#123;</span><br><span class="line">                    <span class="comment">// 挂载vnode =&gt; dom</span></span><br><span class="line">                    const vnode = &#123;</span><br><span class="line">                        tag: rootComponent</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 执行渲染</span></span><br><span class="line">                    <span class="built_in">render</span>(vnode, rootContainer)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return app;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 创建createApp</span></span><br><span class="line">    const Vue = &#123;</span><br><span class="line">        <span class="built_in">createApp</span>(options) &#123;</span><br><span class="line">            <span class="comment">//实际执行的为renderer的createApp()</span></span><br><span class="line">            <span class="comment">// 返回app实例</span></span><br><span class="line">            return renderer<span class="selector-class">.createApp</span>(options)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.实现renderer工厂函数</span></span><br><span class="line">    const createRenderer = options =&gt; &#123;</span><br><span class="line">        <span class="comment">// 实现patch</span></span><br><span class="line">        const patch = (n1, n2, container) =&gt; &#123;</span><br><span class="line">            <span class="comment">// 获取根组件配置</span></span><br><span class="line">            const rootComponent = n2<span class="selector-class">.tag</span>;</span><br><span class="line">            const ctx = &#123; ..<span class="selector-class">.rootComponent</span><span class="selector-class">.data</span>()&#125;</span><br><span class="line">            <span class="comment">// 执行render获取vnode</span></span><br><span class="line">            const vnode = rootComponent<span class="selector-class">.render</span><span class="selector-class">.call</span>(ctx);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 转换vnode =&gt; dom</span></span><br><span class="line">            const parent = options<span class="selector-class">.querySelector</span>(container)</span><br><span class="line">            const child = options<span class="selector-class">.createElement</span>(vnode.tag)</span><br><span class="line">            if (typeof vnode.children === &#x27;string&#x27;) &#123;</span><br><span class="line">                child<span class="selector-class">.textContent</span> = vnode<span class="selector-class">.children</span></span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                <span class="comment">//array</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 追加</span></span><br><span class="line">            options<span class="selector-class">.insert</span>(child, parent)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 实现render</span></span><br><span class="line">        const render = (vnode, container) =&gt; &#123;</span><br><span class="line">            <span class="built_in">patch</span>(container._vnode || null, vnode, container)</span><br><span class="line">            container<span class="selector-class">._vnode</span> = vnode;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 该对象就是renderer</span></span><br><span class="line">        return &#123;</span><br><span class="line">            render,</span><br><span class="line">            createApp: <span class="built_in">createAppAPI</span>(render)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    const renderer = <span class="built_in">createRenderer</span>(&#123;</span><br><span class="line">        querySelector(el) &#123;</span><br><span class="line">            return document<span class="selector-class">.querySelector</span>(el)</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="built_in">createElement</span>(tag) &#123;</span><br><span class="line">            return document<span class="selector-class">.createElement</span>(tag)</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="built_in">insert</span>(child, parent) &#123;</span><br><span class="line">            parent<span class="selector-class">.appendChild</span>(child)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    Vue<span class="selector-class">.createApp</span>(&#123;</span><br><span class="line">        data() &#123;</span><br><span class="line">            return &#123;</span><br><span class="line">                bar: <span class="string">&#x27;hello,vue3&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="built_in">render</span>() &#123;</span><br><span class="line">            return &#123;</span><br><span class="line">                tag: <span class="string">&#x27;h1&#x27;</span>,</span><br><span class="line">                children: this.bar</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)<span class="selector-class">.mount</span>(&#x27;#app&#x27;)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h1 id="19-vue3响应式api如何编写"><a href="#19-vue3响应式api如何编写" class="headerlink" title="19.vue3响应式api如何编写"></a>19.vue3响应式api如何编写</h1><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">var</span> activeEffect = null;</span><br><span class="line">function <span class="built_in">effect</span>(fn) &#123;</span><br><span class="line">  activeEffect = fn;</span><br><span class="line">  <span class="built_in">activeEffect</span>();</span><br><span class="line">  activeEffect = null; </span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">var</span> depsMap = new <span class="built_in">WeakMap</span>();</span><br><span class="line">function <span class="built_in">gather</span>(target, key) &#123;</span><br><span class="line">  <span class="comment">// 避免例如console.log(obj1.name)而触发gather</span></span><br><span class="line">  if (!activeEffect) return;</span><br><span class="line">  let depMap = depsMap<span class="selector-class">.get</span>(target);</span><br><span class="line">  if (!depMap) &#123;</span><br><span class="line">    depsMap<span class="selector-class">.set</span>(target, (depMap = new Map()));</span><br><span class="line">  &#125;</span><br><span class="line">  let dep = depMap<span class="selector-class">.get</span>(key);</span><br><span class="line">  if (!dep) &#123;</span><br><span class="line">    depMap<span class="selector-class">.set</span>(key, (dep = new Set()));</span><br><span class="line">  &#125;</span><br><span class="line">  dep<span class="selector-class">.add</span>(activeEffect)</span><br><span class="line">&#125;</span><br><span class="line">function <span class="built_in">trigger</span>(target, key) &#123;</span><br><span class="line">  let depMap = depsMap<span class="selector-class">.get</span>(target);</span><br><span class="line">  if (depMap) &#123;</span><br><span class="line">    const dep = depMap<span class="selector-class">.get</span>(key);</span><br><span class="line">    if (dep) &#123;</span><br><span class="line">      dep<span class="selector-class">.forEach</span>((effect) =&gt; <span class="built_in">effect</span>());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">function <span class="built_in">reactive</span>(target) &#123;</span><br><span class="line">  const handle = &#123;</span><br><span class="line">    <span class="built_in">set</span>(target, key, value, receiver) &#123;</span><br><span class="line">      Reflect<span class="selector-class">.set</span>(target, key, value, receiver);</span><br><span class="line">      <span class="built_in">trigger</span>(receiver, key); <span class="comment">// 设置值时触发自动更新</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="built_in">get</span>(target, key, receiver) &#123;</span><br><span class="line">      <span class="built_in">gather</span>(receiver, key); <span class="comment">// 访问时收集依赖</span></span><br><span class="line">      return Reflect<span class="selector-class">.get</span>(target, key, receiver);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">  return new <span class="built_in">Proxy</span>(target, handle);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function <span class="built_in">ref</span>(name)&#123;</span><br><span class="line">    return <span class="built_in">reactive</span>(</span><br><span class="line">        &#123;</span><br><span class="line">            value: name</span><br><span class="line">        &#125;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h1 id="20-在Vue项目中你是如何做的SSR渲染"><a href="#20-在Vue项目中你是如何做的SSR渲染" class="headerlink" title="20.在Vue项目中你是如何做的SSR渲染"></a>20.在Vue项目中你是如何做的SSR渲染</h1><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">与传统 SPA (单页应用程序 (Single-Page Application)) 相比，服务器端渲染 (SSR) 的优势主要在于：</span><br><span class="line"></span><br><span class="line"><span class="bullet">*</span>   更好的 SEO，由于搜索引擎爬虫抓取工具可以直接查看完全渲染的页面。</span><br><span class="line"><span class="bullet">*</span>   更快的内容到达时间 (time-to-content)，特别是对于缓慢的网络情况或运行缓慢的设备。</span><br><span class="line"></span><br><span class="line">Vue.js 是构建客户端应用程序的框架。默认情况下，可以在浏览器中输出 Vue 组件，进行生成 DOM 和操作 DOM。然而，也可以将同一个组件渲染为服务器端的 HTML 字符串，将它们直接发送到浏览器，最后将这些静态标记&quot;激活&quot;为客户端上完全可交互的应用程序</span><br><span class="line"></span><br><span class="line">服务器渲染的 Vue.js 应用程序也可以被认为是&quot;同构&quot;或&quot;通用&quot;，因为应用程序的大部分代码都可以在服务器和客户端上运行</span><br><span class="line"></span><br><span class="line"><span class="bullet">*</span> Vue SSR是一个在SPA上进行改良的服务端渲染</span><br><span class="line"><span class="bullet">*</span> 通过Vue SSR渲染的页面，需要在客户端激活才能实现交互</span><br><span class="line"><span class="bullet">*</span> Vue SSR将包含两部分：服务端渲染的首屏，包含交互的SPA</span><br><span class="line"></span><br><span class="line">使用ssr不存在单例模式，每次用户请求都会创建一个新的vue实例</span><br><span class="line">实现ssr需要实现服务端首屏渲染和客户端激活</span><br><span class="line">服务端异步获取数据asyncData可以分为首屏异步获取和切换组件获取</span><br><span class="line">首屏异步获取数据，在服务端预渲染的时候就应该已经完成</span><br><span class="line">切换组件通过mixin混入，在beforeMount钩子完成数据获取</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h1 id="21-怎么看Vue的diff算法"><a href="#21-怎么看Vue的diff算法" class="headerlink" title="21.怎么看Vue的diff算法"></a>21.怎么看Vue的diff算法</h1><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">diff 算法是一种通过同层的树节点进行比较的高效算法</span><br><span class="line"></span><br><span class="line">diff整体策略为：深度优先，同层比较</span><br><span class="line">比较只会在同层级进行, 不会跨层级比较</span><br><span class="line">比较的过程中，循环从两边向中间收拢</span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> 当数据发生改变时，订阅者watcher就会调用patch给真实的DOM打补丁</span><br><span class="line"><span class="bullet">-</span> 通过isSameVnode进行判断，相同则调用patchVnode方法</span><br><span class="line"><span class="bullet">-</span> patchVnode做了以下操作：</span><br><span class="line"><span class="bullet">  -</span> 找到对应的真实dom，称为el</span><br><span class="line"><span class="bullet">  -</span> 如果都有都有文本节点且不相等，将el文本节点设置为Vnode的文本节点</span><br><span class="line"><span class="bullet">  -</span> 如果oldVnode有子节点而VNode没有，则删除el子节点</span><br><span class="line"><span class="bullet">  -</span> 如果oldVnode没有子节点而VNode有，则将VNode的子节点真实化后添加到el</span><br><span class="line"><span class="bullet">  -</span> 如果两者都有子节点，则执行updateChildren函数比较子节点</span><br><span class="line"><span class="bullet">-</span> updateChildren主要做了以下操作：</span><br><span class="line"><span class="bullet">  -</span> 设置新旧VNode的头尾指针</span><br><span class="line"><span class="bullet">  -</span> 新旧头尾指针进行比较，循环向中间靠拢，根据情况调用patchVnode进行patch重复流程、调用createElem创建一个新节点，从哈希表寻找 key一致的VNode 节点再分情况操作</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h1 id="22-从0到1构建一个Vue项目你需要做哪些内容"><a href="#22-从0到1构建一个Vue项目你需要做哪些内容" class="headerlink" title="22.从0到1构建一个Vue项目你需要做哪些内容"></a>22.从<code>0</code>到<code>1</code>构建一个<code>Vue</code>项目你需要做哪些内容</h1><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">*</span>   架子：选用合适的初始化脚手架(<span class="code">`vue-cli2.0`</span>或者<span class="code">`vue-cli3.0`</span>)</span><br><span class="line"><span class="bullet">*</span>   请求：数据<span class="code">`axios`</span>请求的配置</span><br><span class="line"><span class="bullet">*</span>   登录：登录注册系统</span><br><span class="line"><span class="bullet">*</span>   路由：路由管理页面</span><br><span class="line"><span class="bullet">*</span>   数据：<span class="code">`vuex`</span>全局数据管理</span><br><span class="line"><span class="bullet">*</span>   权限：权限管理系统</span><br><span class="line"><span class="bullet">*</span>   埋点：埋点系统</span><br><span class="line"><span class="bullet">*</span>   插件：第三方插件的选取以及引入方式</span><br><span class="line"><span class="bullet">*</span>   错误：错误页面</span><br><span class="line"><span class="bullet">*</span>   入口：前端资源直接当静态资源，或者服务端模板拉取</span><br><span class="line"><span class="bullet">*</span>   <span class="code">`SEO`</span>：如果考虑<span class="code">`SEO`</span>建议采用<span class="code">`SSR`</span>方案</span><br><span class="line"><span class="bullet">*</span>   组件：基础组件/业务组件</span><br><span class="line"><span class="bullet">*</span>   样式：样式预处理起，公共样式抽取</span><br><span class="line"><span class="bullet">*</span>   方法：公共方法抽离</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h1 id="23-介绍一下-js-的数据类型有哪些，值是如何存储的"><a href="#23-介绍一下-js-的数据类型有哪些，值是如何存储的" class="headerlink" title="23. 介绍一下 js 的数据类型有哪些，值是如何存储的"></a>23. 介绍一下 js 的数据类型有哪些，值是如何存储的</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">JavaScript</span> 一共有 <span class="number">8</span> 种数据类型，其中有 <span class="number">7</span> 种基本数据类型：<span class="title class_">Undefined</span>、<span class="title class_">Null</span>、<span class="title class_">Boolean</span>、<span class="title class_">Number</span>、<span class="title class_">String</span>、<span class="title class_">Symbol</span>（es6 新增，表示独一无二的值）和 <span class="title class_">BigInt</span>（es10 新增）；</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> 种引用数据类型——<span class="title class_">Object</span>（<span class="title class_">Object</span> 本质上是由一组无序的名值对组成的）。里面包含 <span class="keyword">function</span>、<span class="title class_">Array</span>、<span class="title class_">Date</span> 等。<span class="title class_">JavaScript</span> 不支持任何创建自定义类型的机制，而所有值最终都将是上述 <span class="number">8</span> 种数据类型之一。</span><br><span class="line"></span><br><span class="line">原始数据类型：直接存储在**栈**（stack）中，占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储。</span><br><span class="line"></span><br><span class="line">引用数据类型：同时存储在**栈**（stack）和**堆**（heap）中，占据空间大、大小不固定。引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体。</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h1 id="24-JS-中Object-prototype-toString-call-判断数据类型"><a href="#24-JS-中Object-prototype-toString-call-判断数据类型" class="headerlink" title="24. JS 中Object.prototype.toString.call()判断数据类型"></a>24. JS 中Object.prototype.toString.call()判断数据类型</h1><figure class="highlight vbscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var a = Object.prototype.toString;</span><br><span class="line">console.<span class="built_in">log</span>(a.<span class="keyword">call</span>(<span class="number">2</span>));</span><br><span class="line">console.<span class="built_in">log</span>(a.<span class="keyword">call</span>(<span class="literal">true</span>));</span><br><span class="line">console.<span class="built_in">log</span>(a.<span class="keyword">call</span>(<span class="comment">&#x27;str&#x27;));</span></span><br><span class="line">console.<span class="built_in">log</span>(a.<span class="keyword">call</span>([]));</span><br><span class="line">console.<span class="built_in">log</span>(a.<span class="keyword">call</span>(<span class="keyword">function</span>()&#123;&#125;));</span><br><span class="line">console.<span class="built_in">log</span>(a.<span class="keyword">call</span>(&#123;&#125;));</span><br><span class="line">console.<span class="built_in">log</span>(a.<span class="keyword">call</span>(undefined));</span><br><span class="line">console.<span class="built_in">log</span>(a.<span class="keyword">call</span>(<span class="literal">null</span>));https://link.juejin.cn?target=https%<span class="number">3</span>A%<span class="number">2</span>F%<span class="number">2</span>Fsegmentfault.com%<span class="number">2</span>Fa%<span class="number">2</span>F1190000011467723%<span class="number">23</span>articleHeader24 <span class="string">&quot;https://segmentfault.com/a/1190000011467723#articleHeader24&quot;</span>)</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h1 id="25-null-和-undefined-的区别？"><a href="#25-null-和-undefined-的区别？" class="headerlink" title="25. null 和 undefined 的区别？"></a>25. null 和 undefined 的区别？</h1><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">首先 <span class="title class_">Undefined</span> 和 <span class="title class_">Null</span> 都是基本数据类型，这两个基本数据类型分别都只有一个值，就是 <span class="literal">undefined</span> 和 <span class="literal">null</span>。</span><br><span class="line"></span><br><span class="line"><span class="literal">undefined</span> 代表的含义是未定义， <span class="literal">null</span> 代表的含义是空对象（其实不是真的对象，请看下面的**注意**！）。一般变量声明了但还没有定义的时候会返回 <span class="literal">undefined</span>，<span class="literal">null</span> 主要用于赋值给一些可能会返回对象的变量，作为初始化。</span><br><span class="line"></span><br><span class="line">其实 <span class="literal">null</span> 不是对象，虽然 <span class="keyword">typeof</span> <span class="literal">null</span> 会输出 <span class="built_in">object</span>，但是这只是 <span class="variable constant_">JS</span> 存在的一个悠久 <span class="title class_">Bug</span>。在 <span class="variable constant_">JS</span> 的最初版本中使用的是 <span class="number">32</span> 位系统，为了性能考虑使用低位存储变量的类型信息，<span class="number">000</span> 开头代表是对象，然而 <span class="literal">null</span> 表示为全零，所以将它错误的判断为 <span class="built_in">object</span> 。虽然现在的内部类型判断代码已经改变了，但是对于这个 <span class="title class_">Bug</span> 却是一直流传下来。</span><br><span class="line"></span><br><span class="line"><span class="literal">undefined</span> 在 js 中不是一个保留字，这意味着我们可以使用 <span class="literal">undefined</span> 来作为一个变量名，这样的做法是非常危险的，它 会影响我们对 <span class="literal">undefined</span> 值的判断。但是我们可以通过一些方法获得安全的 <span class="literal">undefined</span> 值，比如说 <span class="built_in">void</span> <span class="number">0</span>。</span><br><span class="line"></span><br><span class="line">当我们对两种类型使用 <span class="keyword">typeof</span> 进行判断的时候，<span class="title class_">Null</span> 类型化会返回 “<span class="built_in">object</span>”，这是一个历史遗留的问题。当我们使用双等 号对两种类型的值进行比较时会返回 <span class="literal">true</span>，使用三个等号时会返回 <span class="literal">false</span>。</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h1 id="26-和-的-valueOf-和-toString-的结果是什么？"><a href="#26-和-的-valueOf-和-toString-的结果是什么？" class="headerlink" title="26. {}和 [] 的 valueOf 和 toString 的结果是什么？"></a>26. {}和 [] 的 valueOf 和 toString 的结果是什么？</h1><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#125; 的 valueOf 结果为 &#123;&#125; ，toString 的结果为 &quot;<span class="selector-attr">[object Object]</span>&quot;</span><br><span class="line"></span><br><span class="line"><span class="selector-attr">[]</span> 的 valueOf 结果为 <span class="selector-attr">[]</span> ，toString 的结果为 &quot;&quot;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h1 id="27-Javascript-的作用域和作用域链"><a href="#27-Javascript-的作用域和作用域链" class="headerlink" title="27. Javascript 的作用域和作用域链"></a>27. Javascript 的作用域和作用域链</h1><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="strong">**作用域：**</span> 作用域是定义变量的区域，它有一套访问变量的规则，这套规则来管理浏览器引擎如何在当前作用域以及嵌套的作用域中根据变量（标识符）进行变量查找。</span><br><span class="line"></span><br><span class="line"><span class="strong">**作用域链：**</span> 作用域链的作用是保证对执行环境有权访问的所有变量和函数的有序访问，通过作用域链，我们可以访问到外层环境的变量和 函数。</span><br><span class="line"></span><br><span class="line">作用域链的本质上是一个指向变量对象的指针列表。变量对象是一个包含了执行环境中所有变量和函数的对象。作用域链的前 端始终都是当前执行上下文的变量对象。全局执行上下文的变量对象（也就是全局对象）始终是作用域链的最后一个对象。</span><br><span class="line"></span><br><span class="line">当我们查找一个变量时，如果当前执行环境中没有找到，我们可以沿着作用域链向后查找。</span><br><span class="line"></span><br><span class="line">作用域链的创建过程跟执行上下文的建立有关</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h1 id="28-谈谈你对-this、call、apply-和-bind-的理解"><a href="#28-谈谈你对-this、call、apply-和-bind-的理解" class="headerlink" title="28. 谈谈你对 this、call、apply 和 bind 的理解"></a>28. 谈谈你对 this、call、apply 和 bind 的理解</h1><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>  在浏览器里，在全局范围内 <span class="keyword">this</span> 指向 window 对象；</span><br><span class="line"><span class="number">2.</span>  在函数中，<span class="keyword">this</span> 永远指向最后调用他的那个对象；</span><br><span class="line"><span class="number">3.</span>  构造函数中，<span class="keyword">this</span> 指向 new 出来的那个新的对象；</span><br><span class="line"><span class="number">4.</span>  call、apply、bind 中的 <span class="keyword">this</span> 被强绑定在指定的那个对象上；</span><br><span class="line"><span class="number">5.</span>  箭头函数中 <span class="keyword">this</span> 比较特殊, 箭头函数 <span class="keyword">this</span> 为父作用域的 <span class="keyword">this</span>，不是调用时的 <span class="keyword">this</span>. 要知道前四种方式, 都是调用时确定, 也就是动态的, 而箭头函数的 <span class="keyword">this</span> 指向是静态的, 声明的时候就确定了下来；</span><br><span class="line"><span class="number">6.</span>  apply、call、bind 都是 js 给函数内置的一些 API，调用他们可以为函数指定 <span class="keyword">this</span> 的执行, 同时也可以传参。</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/86f03b8b3ca14adcaeba3b90fdb7eedb~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="img"></p><h1 id="29-JavaScript-原型，原型链？-有什么特点？"><a href="#29-JavaScript-原型，原型链？-有什么特点？" class="headerlink" title="29. JavaScript 原型，原型链？ 有什么特点？"></a>29. JavaScript 原型，原型链？ 有什么特点？</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">在 js 中我们是使用构造函数来新建一个对象的，每一个构造函数的内部都有一个 prototype 属性值，这个属性值是一个对 象，这个对象包含了可以由该构造函数的所有实例共享的属性和方法。当我们使用构造函数新建一个对象后，在这个对象的内部 将包含一个指针，这个指针指向构造函数的 prototype 属性对应的值，在 <span class="title class_">ES5</span> 中这个指针被称为对象的原型。一般来说我们 是不应该能够获取到这个值的，但是现在浏览器中都实现了 **proto** 属性来让我们访问这个属性，但是我们最好不要使用这 个属性，因为它不是规范中规定的。<span class="title class_">ES5</span> 中新增了一个 <span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>() 方法，我们可以通过这个方法来获取对 象的原型。</span><br><span class="line"></span><br><span class="line">当我们访问一个对象的属性时，如果这个对象内部不存在这个属性，那么它就会去它的原型对象里找这个属性，这个原型对象又 会有自己的原型，于是就这样一直找下去，也就是原型链的概念。原型链的尽头一般来说都是 <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span> 所以这就 是我们新建的对象为什么能够使用 <span class="title function_">toString</span>() 等方法的原因。</span><br><span class="line"></span><br><span class="line">特点：</span><br><span class="line"></span><br><span class="line"><span class="title class_">JavaScript</span> 对象是通过引用来传递的，我们创建的每个新对象实体中并没有一份属于自己的原型副本。当我们修改原型时，与 之相关的对象也会继承这一改变。</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>参考文章： <a href="https://link.juejin.cn?target=http%3A%2F%2Fcavszhouyou.top%2FJavaScript%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E4%B9%8B%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE.html">《JavaScript 深入理解之原型与原型链》</a></p><h1 id="30-什么是闭包，为什么要用它？"><a href="#30-什么是闭包，为什么要用它？" class="headerlink" title="30. 什么是闭包，为什么要用它？"></a>30. 什么是闭包，为什么要用它？</h1><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> 能够访问其它函数内部变量的函数，称为闭包</span><br><span class="line"><span class="bullet">-</span> 能够访问自由变量的函数，称为闭包</span><br><span class="line"></span><br><span class="line">场景</span><br><span class="line">至于闭包的使用场景，其实在日常开发中使用到是非常频繁的</span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> 防抖节流函数</span><br><span class="line"><span class="bullet">-</span> 定时器回调</span><br><span class="line"><span class="bullet">-</span> 等就不一一列举了</span><br><span class="line"></span><br><span class="line">优点</span><br><span class="line">闭包帮我们解决了什么问题呢</span><br><span class="line"><span class="strong">**内部变量是私有的，可以做到隔离作用域，保持数据的不被污染性**</span></span><br><span class="line"></span><br><span class="line">缺点</span><br><span class="line">同时闭包也带来了不小的坏处</span><br><span class="line"><span class="strong">**说到了它的优点`内部变量是私有的,可以做到隔离作用域`,那也就是说垃圾回收机制是无法清理闭包中内部变量的，那最后结果就是内存泄漏**</span></span><br><span class="line"> </span><br></pre></td></tr></table></figure><h1 id="31-三种事件模型是什么？"><a href="#31-三种事件模型是什么？" class="headerlink" title="31. 三种事件模型是什么？"></a>31. 三种事件模型是什么？</h1><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="strong">**事件**</span> 是用户操作网页时发生的交互动作或者网页本身的一些操作，现代浏览器一共有三种事件模型。</span><br><span class="line"></span><br><span class="line"><span class="bullet">1.</span>  <span class="strong">**DOM0 级模型：**</span> ，这种模型不会传播，所以没有事件流的概念，但是现在有的浏览器支持以冒泡的方式实现，它可以在网页中直接定义监听函数，也可以通过 js 属性来指定监听函数。这种方式是所有浏览器都兼容的。</span><br><span class="line"><span class="bullet">2.</span>  <span class="strong">**IE 事件模型：**</span> 在该事件模型中，一次事件共有两个过程，事件处理阶段，和事件冒泡阶段。事件处理阶段会首先执行目标元素绑定的监听事件。然后是事件冒泡阶段，冒泡指的是事件从目标元素冒泡到 document，依次检查经过的节点是否绑定了事件监听函数，如果有则执行。这种模型通过 attachEvent 来添加监听函数，可以添加多个监听函数，会按顺序依次执行。</span><br><span class="line"><span class="bullet">3.</span>  <span class="strong">**DOM2 级事件模型：**</span> 在该事件模型中，一次事件共有三个过程，第一个过程是事件捕获阶段。捕获指的是事件从 document 一直向下传播到目标元素，依次检查经过的节点是否绑定了事件监听函数，如果有则执行。后面两个阶段和 IE 事件模型的两个阶段相同。这种事件模型，事件绑定的函数是 addEventListener，其中第三个参数可以指定事件是否在捕获阶段执行。</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h1 id="32-js-数组和字符串有哪些原生方法-列举一下"><a href="#32-js-数组和字符串有哪些原生方法-列举一下" class="headerlink" title="32. js 数组和字符串有哪些原生方法, 列举一下"></a>32. js 数组和字符串有哪些原生方法, 列举一下</h1><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ab8c5beff9054a23a296c5b738878184~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="img"></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d35b1e307cba458c8b1e73917165be6b~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="img"></p><h1 id="33-js-延迟加载的方式有哪些"><a href="#33-js-延迟加载的方式有哪些" class="headerlink" title="33. js 延迟加载的方式有哪些"></a>33. js 延迟加载的方式有哪些</h1><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">js 的加载、解析和执行会阻塞页面的渲染过程，因此我们希望 js 脚本能够尽可能的延迟加载，提高页面的渲染速度。</span><br><span class="line"></span><br><span class="line"><span class="bullet">1.</span>  将 js 脚本放在文档的底部，来使 js 脚本尽可能的在最后来加载执行。</span><br><span class="line"><span class="bullet">2.</span>  给 js 脚本添加 defer 属性，这个属性会让脚本的加载与文档的解析同步解析，然后在文档解析完成后再执行这个脚本文件，这样的话就能使页面的渲染不被阻塞。多个设置了 defer 属性的脚本按规范来说最后是顺序执行的，但是在一些浏览器中可能不是这样。</span><br><span class="line"><span class="bullet">3.</span>  给 js 脚本添加 async 属性，这个属性会使脚本异步加载，不会阻塞页面的解析过程，但是当脚本加载完成后立即执行 js 脚本，这个时候如果文档没有解析完成的话同样会阻塞。多个 async 属性的脚本的执行顺序是不可预测的，一般不会按照代码的顺序依次执行。</span><br><span class="line"><span class="bullet">4.</span>  动态创建 DOM 标签的方式，我们可以对文档的加载事件进行监听，当文档加载完成后再动态的创建 script 标签来引入 js 脚本。</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h1 id="34-js-的几种模块规范？"><a href="#34-js-的几种模块规范？" class="headerlink" title="34. js 的几种模块规范？"></a>34. js 的几种模块规范？</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">js 中现在比较成熟的有四种模块加载方案：</span><br><span class="line"></span><br><span class="line">*   第一种是 <span class="title class_">CommonJS</span> 方案，它通过 <span class="built_in">require</span> 来引入模块，通过 <span class="variable language_">module</span>.<span class="property">exports</span> 定义模块的输出接口。这种模块加载方案是服务器端的解决方案，它是以同步的方式来引入模块的，因为在服务端文件都存储在本地磁盘，所以读取非常快，所以以同步的方式加载没有问题。但如果是在浏览器端，由于模块的加载是使用网络请求，因此使用异步加载的方式更加合适。</span><br><span class="line">*   第二种是 <span class="variable constant_">AMD</span> 方案，这种方案采用异步加载的方式来加载模块，模块的加载不影响后面语句的执行，所有依赖这个模块的语句都定义在一个回调函数里，等到加载完成后再执行回调函数。<span class="built_in">require</span>.<span class="property">js</span> 实现了 <span class="variable constant_">AMD</span> 规范。</span><br><span class="line">*   第三种是 <span class="variable constant_">CMD</span> 方案，这种方案和 <span class="variable constant_">AMD</span> 方案都是为了解决异步模块加载的问题，sea.<span class="property">js</span> 实现了 <span class="variable constant_">CMD</span> 规范。它和 <span class="built_in">require</span>.<span class="property">js</span> 的区别在于模块定义时对依赖的处理不同和对依赖模块的执行时机的处理不同。</span><br><span class="line">*   第四种方案是 <span class="title class_">ES6</span> 提出的方案，使用 <span class="keyword">import</span> 和 <span class="keyword">export</span> 的形式来导入导出模块。</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h1 id="35-AMD-和-CMD-规范的区别？"><a href="#35-AMD-和-CMD-规范的区别？" class="headerlink" title="35. AMD 和 CMD 规范的区别？"></a>35. AMD 和 CMD 规范的区别？</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">它们之间的主要区别有两个方面。</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span>  第一个方面是在模块定义时对依赖的处理不同。<span class="variable constant_">AMD</span> 推崇依赖前置，在定义模块的时候就要声明其依赖的模块。而 <span class="variable constant_">CMD</span> 推崇就近依赖，只有在用到某个模块的时候再去 <span class="built_in">require</span>。</span><br><span class="line"><span class="number">2.</span>  第二个方面是对依赖模块的执行时机处理不同。首先 <span class="variable constant_">AMD</span> 和 <span class="variable constant_">CMD</span> 对于模块的加载方式都是异步加载，不过它们的区别在于 模块的执行时机，<span class="variable constant_">AMD</span> 在依赖模块加载完成后就直接执行依赖模块，依赖模块的执行顺序和我们书写的顺序不一定一致。而 <span class="variable constant_">CMD</span> 在依赖模块加载完成后并不执行，只是下载而已，等到所有的依赖模块都加载好后，进入回调函数逻辑，遇到 <span class="built_in">require</span> 语句 的时候才执行对应的模块，这样模块的执行顺序就和我们书写的顺序保持一致了。</span><br><span class="line"></span><br><span class="line"><span class="comment">// CMD</span></span><br><span class="line"><span class="title function_">define</span>(<span class="keyword">function</span>(<span class="params"><span class="built_in">require</span>, <span class="built_in">exports</span>, <span class="variable language_">module</span></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">&quot;./a&quot;</span>);</span><br><span class="line">  a.<span class="title function_">doSomething</span>();</span><br><span class="line">  <span class="comment">// 此处略去 100 行</span></span><br><span class="line">  <span class="keyword">var</span> b = <span class="built_in">require</span>(<span class="string">&quot;./b&quot;</span>); <span class="comment">// 依赖可以就近书写</span></span><br><span class="line">  b.<span class="title function_">doSomething</span>();</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// AMD 默认推荐</span></span><br><span class="line"><span class="title function_">define</span>([<span class="string">&quot;./a&quot;</span>, <span class="string">&quot;./b&quot;</span>], <span class="keyword">function</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">  <span class="comment">// 依赖必须一开始就写好</span></span><br><span class="line">  a.<span class="title function_">doSomething</span>();</span><br><span class="line">  <span class="comment">// 此处略去 100 行</span></span><br><span class="line">  b.<span class="title function_">doSomething</span>();</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h1 id="36-ES6-模块与-CommonJS-模块、AMD、CMD-的差异。"><a href="#36-ES6-模块与-CommonJS-模块、AMD、CMD-的差异。" class="headerlink" title="36. ES6 模块与 CommonJS 模块、AMD、CMD 的差异。"></a>36. ES6 模块与 CommonJS 模块、AMD、CMD 的差异。</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、语法上</span><br><span class="line"><span class="title class_">CommonJS</span> 使用的是 <span class="variable language_">module</span>.<span class="property">exports</span> = &#123;&#125; 导出一个模块对象，<span class="built_in">require</span>(‘file_path’) 引入模块对象；</span><br><span class="line"><span class="title class_">ES6</span>使用的是 <span class="keyword">export</span> 导出指定数据， <span class="keyword">import</span> 引入具体数据。</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、<span class="title class_">CommonJS</span> 模块输出的是一个值的拷贝，<span class="title class_">ES6</span> 模块输出的是值的引用</span><br><span class="line"></span><br><span class="line"><span class="title class_">CommonJS</span> 模块输出的是值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。</span><br><span class="line"></span><br><span class="line"><span class="title class_">ES6</span> <span class="title class_">Modules</span> 的运行机制与 <span class="title class_">CommonJS</span> 不一样。<span class="variable constant_">JS</span> 引擎对脚本静态分析的时候，遇到模块加载命令<span class="keyword">import</span>，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。换句话说，<span class="title class_">ES6</span>的<span class="keyword">import</span> 有点像 <span class="title class_">Unix</span> 系统的“符号连接”，原始值变了，<span class="keyword">import</span>加载的值也会跟着变。因此，<span class="title class_">ES6</span>模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块。</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>、<span class="title class_">CommonJS</span> 模块是运行时加载，<span class="title class_">ES6</span> 模块是编译时加载</span><br><span class="line"></span><br><span class="line">运行时加载: <span class="title class_">CommonJS</span> 模块就是对象；即在输入时是先加载整个模块，生成一个对象，然后再从这个对象上面读取方法，这种加载称为“运行时加载”。</span><br><span class="line"></span><br><span class="line">编译时加载: <span class="title class_">ES6</span> 模块不是对象，而是通过 <span class="keyword">export</span> 命令显式指定输出的代码，<span class="keyword">import</span>时采用静态命令的形式。即在<span class="keyword">import</span>时可以指定加载某个输出值，而不是加载整个模块，这种加载称为“编译时加载”</span><br><span class="line"></span><br><span class="line"><span class="variable constant_">PS</span>：<span class="title class_">CommonJS</span> 加载的是一个对象（即<span class="variable language_">module</span>.<span class="property">exports</span>属性），该对象只有在脚本运行完才会生成。而 <span class="title class_">ES6</span> 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h1 id="37-JS-的运行机制"><a href="#37-JS-的运行机制" class="headerlink" title="37. JS 的运行机制"></a>37. JS 的运行机制</h1><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">异步任务分类：宏任务，微任务</span><br><span class="line">同步任务和异步任务分别进入不同的执行&quot;场所&quot;</span><br><span class="line">先执行主线程执行栈中的宏任务</span><br><span class="line">执行过程中如果遇到微任务，进入Event Table并注册函数，完成后移入到微任务的任务队列中</span><br><span class="line">宏任务执行完毕后，立即执行当前微任务队列中的所有微任务（依次执行）</span><br><span class="line">主线程会不断获取任务队列中的任务、执行任务、再获取、再执行任务也就是常说的Event Loop(事件循环)。</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h1 id="38-简单介绍一下-V8-引擎的垃圾回收机制"><a href="#38-简单介绍一下-V8-引擎的垃圾回收机制" class="headerlink" title="38. 简单介绍一下 V8 引擎的垃圾回收机制"></a>38. 简单介绍一下 V8 引擎的垃圾回收机制</h1><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">v8 的垃圾回收机制基于分代回收机制，这个机制又基于世代假说，这个假说有两个特点，一是新生的对象容易早死，另一个是不死的对象会活得更久。基于这个假说，v8 引擎将内存分为了新生代和老生代。</span><br><span class="line"></span><br><span class="line">新创建的对象或者只经历过一次的垃圾回收的对象被称为新生代。经历过多次垃圾回收的对象被称为老生代。</span><br><span class="line"></span><br><span class="line">新生代被分为 <span class="selector-tag">From</span> 和 <span class="selector-tag">To</span> 两个空间，<span class="selector-tag">To</span> 一般是闲置的。当 <span class="selector-tag">From</span> 空间满了的时候会执行 Scavenge 算法进行垃圾回收。当我们执行垃圾回收算法的时候应用逻辑将会停止，等垃圾回收结束后再继续执行。这个算法分为三步：</span><br><span class="line"></span><br><span class="line">（<span class="number">1</span>）首先检查 <span class="selector-tag">From</span> 空间的存活对象，如果对象存活则判断对象是否满足晋升到老生代的条件，如果满足条件则晋升到老生代。如果不满足条件则移动 <span class="selector-tag">To</span> 空间。</span><br><span class="line"></span><br><span class="line">（<span class="number">2</span>）如果对象不存活，则释放对象的空间。</span><br><span class="line"></span><br><span class="line">（<span class="number">3</span>）最后将 <span class="selector-tag">From</span> 空间和 <span class="selector-tag">To</span> 空间角色进行交换。</span><br><span class="line"></span><br><span class="line">新生代对象晋升到老生代有两个条件：</span><br><span class="line"></span><br><span class="line">（<span class="number">1</span>）第一个是判断是对象否已经经过一次 Scavenge 回收。若经历过，则将对象从 <span class="selector-tag">From</span> 空间复制到老生代中；若没有经历，则复制到 <span class="selector-tag">To</span> 空间。</span><br><span class="line"></span><br><span class="line">（<span class="number">2</span>）第二个是 <span class="selector-tag">To</span> 空间的内存使用占比是否超过限制。当对象从 <span class="selector-tag">From</span> 空间复制到 <span class="selector-tag">To</span> 空间时，若 <span class="selector-tag">To</span> 空间使用超过 <span class="number">25%</span>，则对象直接晋升到老生代中。设置 <span class="number">25%</span> 的原因主要是因为算法结束后，两个空间结束后会交换位置，如果 <span class="selector-tag">To</span> 空间的内存太小，会影响后续的内存分配。</span><br><span class="line"></span><br><span class="line">老生代采用了标记清除法和标记压缩法。标记清除法首先会对内存中存活的对象进行标记，标记结束后清除掉那些没有标记的对象。由于标记清除后会造成很多的内存碎片，不便于后面的内存分配。所以了解决内存碎片的问题引入了标记压缩法。</span><br><span class="line"></span><br><span class="line">由于在进行垃圾回收的时候会暂停应用的逻辑，对于新生代方法由于内存小，每次停顿的时间不会太长，但对于老生代来说每次垃圾回收的时间长，停顿会造成很大的影响。 为了解决这个问题 V8 引入了增量标记的方法，将一次停顿进行的过程分为了多步，每次执行完一小步就让运行逻辑执行一会，就这样交替运行。</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>相关资料：</p><p><a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.jianshu.com%2Fp%2Fb8ed21e8a4fb">《深入理解 V8 的垃圾回收原理》</a></p><p><a href="https://link.juejin.cn?target=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F23992332">《JavaScript 中的垃圾回收》</a></p><h1 id="39-哪些操作会造成内存泄漏？"><a href="#39-哪些操作会造成内存泄漏？" class="headerlink" title="39. 哪些操作会造成内存泄漏？"></a>39. 哪些操作会造成内存泄漏？</h1><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">*</span>   1. 意外的全局变量</span><br><span class="line"><span class="bullet">*</span>   2. 被遗忘的计时器或回调函数</span><br><span class="line"><span class="bullet">*</span>   3. 脱离 DOM 的引用</span><br><span class="line"><span class="bullet">*</span>   4. 闭包</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h1 id="40-ES6有哪些新特性？"><a href="#40-ES6有哪些新特性？" class="headerlink" title="40.ES6有哪些新特性？"></a>40.ES6有哪些新特性？</h1><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">*</span>   块作用域</span><br><span class="line"><span class="bullet">*</span>   类</span><br><span class="line"><span class="bullet">*</span>   箭头函数</span><br><span class="line"><span class="bullet">*</span>   模板字符串</span><br><span class="line"><span class="bullet">*</span>   加强的对象字面</span><br><span class="line"><span class="bullet">*</span>   对象解构</span><br><span class="line"><span class="bullet">*</span>   Promise</span><br><span class="line"><span class="bullet">*</span>   模块</span><br><span class="line"><span class="bullet">*</span>   Symbol</span><br><span class="line"><span class="bullet">*</span>   代理（proxy）Set</span><br><span class="line"><span class="bullet">*</span>   函数默认参数</span><br><span class="line"><span class="bullet">*</span>   展开</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h1 id="41-什么是箭头函数？"><a href="#41-什么是箭头函数？" class="headerlink" title="41. 什么是箭头函数？"></a>41. 什么是箭头函数？</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ES5 Version</span></span><br><span class="line"><span class="keyword">var</span> getCurrentDate = <span class="keyword">function</span> (<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ES6 Version</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">getCurrentDate</span> = (<span class="params"></span>) =&gt; <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line"></span><br><span class="line">箭头函数表达式的语法比函数表达式更简洁，并且没有自己的<span class="string">`this，arguments，super或new.target`</span>。箭头函数表达式更适用于那些本来需要匿名函数的地方，并且它不能用作构造函数。</span><br><span class="line"></span><br><span class="line">箭头函数没有自己的 <span class="variable language_">this</span> 值。它捕获词法作用域函数的 <span class="variable language_">this</span> 值，如果我们在全局作用域声明箭头函数，则 <span class="variable language_">this</span> 值为 <span class="variable language_">window</span> 对象。</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h1 id="42-什么是高阶函数？"><a href="#42-什么是高阶函数？" class="headerlink" title="42. 什么是高阶函数？"></a>42. 什么是高阶函数？</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">高阶函数只是将函数作为参数或返回值的函数。</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">higherOrderFunction</span>(<span class="params">param,callback</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">callback</span>(param);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h1 id="43-手写-call、apply-及-bind-函数"><a href="#43-手写-call、apply-及-bind-函数" class="headerlink" title="43. 手写 call、apply 及 bind 函数"></a>43. 手写 call、apply 及 bind 函数</h1><h2 id="1-实现call函数"><a href="#1-实现call函数" class="headerlink" title="1.实现call函数"></a>1.实现call函数</h2><p><strong>实现步骤：</strong></p><ul><li>处理边界：<ul><li>对象不存在，this指向window；</li></ul></li><li>将「调用函数」<em>挂载到</em>「this指向的对象」的fn属性上。</li><li>执行「this指向的对象」上的fn函数，并传入参数，返回结果。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">mu_call</span> = <span class="keyword">function</span> (<span class="params">context, ...args</span>) &#123;</span><br><span class="line">    <span class="comment">//obj不存在指向window</span></span><br><span class="line">    <span class="keyword">if</span> (!context || context === <span class="literal">null</span>) &#123;</span><br><span class="line">      context = <span class="variable language_">window</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创造唯一的key值  作为我们构造的context内部方法名</span></span><br><span class="line">    <span class="keyword">let</span> fn = <span class="title class_">Symbol</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//this指向调用call的函数</span></span><br><span class="line">    context[fn] = <span class="variable language_">this</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行函数并返回结果 相当于把自身作为传入的context的方法进行调用了</span></span><br><span class="line">    <span class="keyword">return</span> context[fn](...args);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 测试</span></span><br><span class="line">  <span class="keyword">var</span> value = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">    <span class="attr">value</span>: <span class="number">1</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> myObj = &#123;</span><br><span class="line">      <span class="attr">name</span>: name,</span><br><span class="line">      <span class="attr">age</span>: age,</span><br><span class="line">      <span class="attr">value</span>: <span class="variable language_">this</span>.<span class="property">value</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">value</span>, myObj);</span><br><span class="line">  &#125;</span><br><span class="line">  bar.<span class="title function_">mu_call</span>(<span class="literal">null</span>); <span class="comment">//打印 2 &#123;name: undefined, age: undefined, value: 2&#125;</span></span><br><span class="line">  bar.<span class="title function_">mu_call</span>(obj1, <span class="string">&#x27;tom&#x27;</span>, <span class="string">&#x27;110&#x27;</span>); <span class="comment">// 打印 1 &#123;name: &quot;tom&quot;, age: &quot;110&quot;, value: 1&#125;</span></span><br><span class="line"> </span><br></pre></td></tr></table></figure><h2 id="2-实现apply函数"><a href="#2-实现apply函数" class="headerlink" title="2.实现apply函数"></a>2.实现apply函数</h2><p><strong>实现步骤：</strong></p><ul><li>与call一致</li><li>区别于参数的形式</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">mu_apply</span> = <span class="keyword">function</span> (<span class="params">context, args</span>) &#123;</span><br><span class="line">  <span class="comment">//obj不存在指向window</span></span><br><span class="line">  <span class="keyword">if</span> (!context || context === <span class="literal">null</span>) &#123;</span><br><span class="line">    context = <span class="title class_">Window</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 创造唯一的key值  作为我们构造的context内部方法名</span></span><br><span class="line">  <span class="keyword">let</span> fn = <span class="title class_">Symbol</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">//this指向调用call的函数</span></span><br><span class="line">  context[fn] = <span class="variable language_">this</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 执行函数并返回结果 相当于把自身作为传入的context的方法进行调用了</span></span><br><span class="line">  <span class="keyword">return</span> context[fn](...args);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="keyword">var</span> value = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">  <span class="attr">value</span>: <span class="number">1</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> myObj = &#123;</span><br><span class="line">    <span class="attr">name</span>: name,</span><br><span class="line">    <span class="attr">age</span>: age,</span><br><span class="line">    <span class="attr">value</span>: <span class="variable language_">this</span>.<span class="property">value</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">value</span>, myObj);</span><br><span class="line">&#125;</span><br><span class="line">bar.<span class="title function_">mu_apply</span>(obj1, [<span class="string">&quot;tom&quot;</span>, <span class="string">&quot;110&quot;</span>]); <span class="comment">// 打印 1 &#123;name: &quot;tom&quot;, age: &quot;110&quot;, value: 1&#125;</span></span><br><span class="line"> </span><br></pre></td></tr></table></figure><h2 id="3-实现bind函数"><a href="#3-实现bind函数" class="headerlink" title="3.实现bind函数"></a>3.实现bind函数</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">mu_bind</span> = <span class="keyword">function</span> (<span class="params">context, ...args</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!context || context === <span class="literal">null</span>) &#123;</span><br><span class="line">      context = <span class="variable language_">window</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创造唯一的key值  作为我们构造的context内部方法名</span></span><br><span class="line">    <span class="keyword">let</span> fn = <span class="title class_">Symbol</span>();</span><br><span class="line">    context[fn] = <span class="variable language_">this</span>;</span><br><span class="line">    <span class="keyword">let</span> _this = <span class="variable language_">this</span>;</span><br><span class="line">    <span class="comment">//  bind情况要复杂一点</span></span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">function</span> (<span class="params">...innerArgs</span>) &#123;</span><br><span class="line">      <span class="comment">// 第一种情况 :若是将 bind 绑定之后的函数当作构造函数，通过 new 操作符使用，则不绑定传入的 this，而是将 this 指向实例化出来的对象</span></span><br><span class="line">      <span class="comment">// 此时由于new操作符作用  this指向result实例对象  而result又继承自传入的_this 根据原型链知识可得出以下结论</span></span><br><span class="line">      <span class="comment">// this.__proto__ === result.prototype   //this instanceof result =&gt;true</span></span><br><span class="line">      <span class="comment">// this.__proto__.__proto__ === result.prototype.__proto__ === _this.prototype; //this instanceof _this =&gt;true</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span> <span class="keyword">instanceof</span> _this === <span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">// 此时this指向指向result的实例  这时候不需要改变this指向</span></span><br><span class="line">        <span class="variable language_">this</span>[fn] = _this;</span><br><span class="line">        <span class="variable language_">this</span>[fn](...[...args, ...innerArgs]); <span class="comment">//这里使用es6的方法让bind支持参数合并</span></span><br><span class="line">        <span class="keyword">delete</span> <span class="variable language_">this</span>[fn];</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果只是作为普通函数调用  那就很简单了 直接改变this指向为传入的context</span></span><br><span class="line">        context[fn](...[...args, ...innerArgs]);</span><br><span class="line">        <span class="keyword">delete</span> context[fn];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 如果绑定的是构造函数 那么需要继承构造函数原型属性和方法</span></span><br><span class="line">    <span class="comment">// 实现继承的方式: 使用Object.create</span></span><br><span class="line">    result.<span class="property"><span class="keyword">prototype</span></span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="variable language_">this</span>.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(name); <span class="comment">//&#x27;我是参数传进来的name&#x27;</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(age); <span class="comment">//&#x27;我是参数传进来的age&#x27;</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>); <span class="comment">//构造函数this指向实例对象</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 构造函数原型的方法</span></span><br><span class="line">  <span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">say</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">123</span>);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 普通函数</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">normalFun</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(name); <span class="comment">//&#x27;我是参数传进来的name&#x27;</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(age); <span class="comment">//&#x27;我是参数传进来的age&#x27;</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>); <span class="comment">//普通函数this指向绑定bind的第一个参数 也就是例子中的obj</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">objName</span>); <span class="comment">//&#x27;我是obj传进来的name&#x27;</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">objAge</span>); <span class="comment">//&#x27;我是obj传进来的age&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> obj = &#123;</span><br><span class="line">    <span class="attr">objName</span>: <span class="string">&#x27;我是obj传进来的name&#x27;</span>,</span><br><span class="line">    <span class="attr">objAge</span>: <span class="string">&#x27;我是obj传进来的age&#x27;</span>,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 先测试作为构造函数调用</span></span><br><span class="line">  <span class="comment">//   let bindFun = Person.mu_bind(obj, &#x27;我是参数传进来的name&#x27;);</span></span><br><span class="line">  <span class="comment">//   let a = new bindFun(&#x27;我是参数传进来的age&#x27;);</span></span><br><span class="line">  <span class="comment">//   a.say(); //123</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//   再测试作为普通函数调用a;</span></span><br><span class="line">  <span class="keyword">let</span> bindFun = normalFun.<span class="title function_">mu_bind</span>(obj, <span class="string">&#x27;我是参数传进来的name&#x27;</span>);</span><br><span class="line">  <span class="title function_">bindFun</span>(<span class="string">&#x27;我是参数传进来的age&#x27;</span>);</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>参考文章： <a href="https://juejin.cn/post/7186557308883714085">高频JavaScript手写面试题，你“行”吗</a></p><h1 id="44-函数柯里化的实现"><a href="#44-函数柯里化的实现" class="headerlink" title="44. 函数柯里化的实现"></a>44. 函数柯里化的实现</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数柯里化指的是一种将使用多个参数的一个函数转换成一系列使用一个参数的函数的技术。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">curry</span>(<span class="params">fn, args</span>) &#123;</span><br><span class="line">  <span class="comment">// 获取函数需要的参数长度</span></span><br><span class="line">  <span class="keyword">let</span> length = fn.<span class="property">length</span>;</span><br><span class="line"></span><br><span class="line">  args = args || [];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> subArgs = args.<span class="title function_">slice</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拼接得到现有的所有参数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="variable language_">arguments</span>.<span class="property">length</span>; i++) &#123;</span><br><span class="line">      subArgs.<span class="title function_">push</span>(<span class="variable language_">arguments</span>[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断参数的长度是否已经满足函数所需参数的长度</span></span><br><span class="line">    <span class="keyword">if</span> (subArgs.<span class="property">length</span> &gt;= length) &#123;</span><br><span class="line">      <span class="comment">// 如果满足，执行函数</span></span><br><span class="line">      <span class="keyword">return</span> fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, subArgs);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 如果不满足，递归返回科里化的函数，等待参数的传入</span></span><br><span class="line">      <span class="keyword">return</span> curry.<span class="title function_">call</span>(<span class="variable language_">this</span>, fn, subArgs);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// es6 实现</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">curry</span>(<span class="params">fn, ...args</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> fn.<span class="property">length</span> &lt;= args.<span class="property">length</span> ? <span class="title function_">fn</span>(...args) : curry.<span class="title function_">bind</span>(<span class="literal">null</span>, fn, ...args);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>参考文章： <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fmqyqingfeng%2FBlog%2Fissues%2F42">《JavaScript 专题之函数柯里化》</a></p><h1 id="45-实现一个-new-操作符"><a href="#45-实现一个-new-操作符" class="headerlink" title="45. 实现一个 new 操作符"></a>45. 实现一个 new 操作符</h1><p><strong>首先需要了解new做了什么事情：</strong></p><ul><li>首先创建了一个空对象。</li><li>将空对象<code>proto</code>指向构造函数的原型<code>prototype</code>。</li><li>使<code>this</code>指向新创建的对象，并执行构造函数。</li><li>执行结果有返回值并且是一个对象， 返回执行的结果， 否则返回新创建的对象。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码实现</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">mu_new</span>(<span class="params">fn,...arg</span>)&#123;</span><br><span class="line">    <span class="comment">// 首先创建空对象</span></span><br><span class="line">    <span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line">    <span class="comment">// 将空对象的原型proto指向构造函数的原型prototype</span></span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">setPrototypeOf</span>(obj, fn.<span class="property"><span class="keyword">prototype</span></span>)</span><br><span class="line">    <span class="comment">// 将this指向新创建的对象，并且执行构造函数</span></span><br><span class="line">    <span class="keyword">const</span> result = fn.<span class="title function_">apply</span>(obj,arg);</span><br><span class="line">    <span class="comment">// 执行结果有返回值并且是一个对象，返回执行的结果，否侧返回新创建的对象</span></span><br><span class="line">    <span class="keyword">return</span> result <span class="keyword">instanceof</span> <span class="title class_">Object</span> ? result : obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 验证mu_new函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Dog</span>(<span class="params">name</span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">say</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;my name is&#x27;</span> + <span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> dog = <span class="title function_">mu_new</span>(<span class="title class_">Dog</span>, <span class="string">&quot;傻🐶&quot;</span>);</span><br><span class="line">dog.<span class="title function_">say</span>() <span class="comment">//my name is傻🐶</span></span><br><span class="line"> </span><br></pre></td></tr></table></figure><h1 id="46-可以讲讲Promise吗，可以手写实现一下吗？"><a href="#46-可以讲讲Promise吗，可以手写实现一下吗？" class="headerlink" title="46. 可以讲讲Promise吗，可以手写实现一下吗？"></a>46. 可以讲讲Promise吗，可以手写实现一下吗？</h1><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。它由社区最早提出和实现，ES6 将其写进了语言标准，统一了用法，原生提供了<span class="code">`Promise`</span>对象。</span><br><span class="line"></span><br><span class="line">所谓<span class="code">`Promise`</span>，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。</span><br><span class="line"></span><br><span class="line"><span class="strong">**那我们来看看我们所熟知的`Promise`的基本原理**</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">+</span> 首先我们在调用Promise时，会返回一个Promise对象。</span><br><span class="line"><span class="bullet">+</span> 构建Promise对象时，需要传入一个executor函数，Promise的主要业务流程都在executor函数中执行。</span><br><span class="line"><span class="bullet">+</span> 如果运行在excutor函数中的业务执行成功了，会调用resolve函数；如果执行失败了，则调用reject函数。</span><br><span class="line"><span class="bullet">+</span> Promise的状态不可逆，同时调用resolve函数和reject函数，默认会采取第一次调用的结果。</span><br><span class="line"></span><br><span class="line"><span class="strong">**结合Promise/A+规范，我们还可以分析出哪些基本特征**</span></span><br><span class="line"></span><br><span class="line">Promise/A+的规范比较多，在这列出一下核心的规范。[<span class="string">Promise/A+规范</span>](<span class="link">https://link.juejin.cn/?target=https%3A%2F%2Fpromisesaplus.com%2F</span>)</span><br><span class="line"></span><br><span class="line"><span class="bullet">+</span> promise有三个状态：pending，fulfilled，rejected，默认状态是pending。</span><br><span class="line"><span class="bullet">+</span> promise有一个value保存成功状态的值，有一个reason保存失败状态的值，可以是undefined/thenable/promise。</span><br><span class="line"><span class="bullet">+</span> promise只能从pending到rejected, 或者从pending到fulfilled，状态一旦确认，就不会再改变。</span><br><span class="line"><span class="bullet">+</span> promise 必须有一个then方法，then接收两个参数，分别是promise成功的回调onFulfilled, 和promise失败的回调onRejected。</span><br><span class="line"><span class="bullet">+</span> 如果then中抛出了异常，那么就会把这个异常作为参数，传递给下一个then的失败的回调onRejected。</span><br><span class="line"></span><br><span class="line">那<span class="code">`CustomPromise`</span>，还实现不了基本原理的3，4两条，那我们来根据基本原理与Promise/A+分析下，还缺少什么</span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> promise有三个状态：pending，fulfilled，rejected。</span><br><span class="line"><span class="bullet">-</span> executor执行器调用reject与resolve两个方法</span><br><span class="line"><span class="bullet">-</span> 还需要有保存成功或失败两个值的变量</span><br><span class="line"><span class="bullet">-</span> then接收两个参数，分别是成功的回调onFulfilled,失败的回调onRejected</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p><a href="https://juejin.cn/post/7194257890893365308">手写实现promise</a></p><h1 id="47-什么是-async-await-及其如何工作-可以手写async吗"><a href="#47-什么是-async-await-及其如何工作-可以手写async吗" class="headerlink" title="47. 什么是 async/await 及其如何工作, 可以手写async吗"></a>47. 什么是 <code>async/await</code> 及其如何工作, 可以手写async吗</h1><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1、Async—声明一个异步函数</span><br><span class="line"><span class="bullet">  -</span> 自动将常规函数转换成Promise，返回值也是一个Promise对象</span><br><span class="line"><span class="bullet">  -</span> 只有async函数内部的异步操作执行完，才会执行then方法指定的回调函数</span><br><span class="line"><span class="bullet">  -</span> 异步函数内部可以使用await</span><br><span class="line">2、Await—暂停异步的功能执行(var result = await someAsyncCall();)</span><br><span class="line"><span class="bullet">  -</span> 放置在Promise调用之前，await强制其他代码等待，直到Promise完成并返回结果</span><br><span class="line"><span class="bullet">  -</span> 只能与Promise一起使用，不适用与回调</span><br><span class="line"><span class="bullet">  -</span> 只能在async函数内部使用</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p><a href="https://juejin.cn/post/7195358576364224568">手写实现async</a></p><h1 id="48-instanceof-的优缺点是什么，如何实现"><a href="#48-instanceof-的优缺点是什么，如何实现" class="headerlink" title="48. instanceof 的优缺点是什么，如何实现"></a>48. instanceof 的优缺点是什么，如何实现</h1><p><strong>优缺点：</strong></p><ul><li><strong>「优点」</strong>：能够区分Array、Object和Function，适合用于判断自定义的类实例对象</li><li><strong>「缺点」</strong>：Number，Boolean，String基本数据类型不能判断</li></ul><p><strong>实现步骤：</strong></p><ul><li>传入参数为左侧的实例L，和右侧的构造函数R</li><li>处理边界，如果要检测对象为基本类型则返回false</li><li>分别取传入参数的原型</li><li>判断左侧的原型是否取到了null，如果是null返回false；如果两侧原型相等，返回true，否则继续取左侧原型的原型。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传入参数左侧为实例L, 右侧为构造函数R</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">mu_instanceof</span>(<span class="params">L,R</span>)&#123;</span><br><span class="line">    <span class="comment">// 处理边界：检测实例类型是否为原始类型</span></span><br><span class="line">    <span class="keyword">const</span> baseTypes = [<span class="string">&#x27;string&#x27;</span>,<span class="string">&#x27;number&#x27;</span>,<span class="string">&#x27;boolean&#x27;</span>,<span class="string">&#x27;symbol&#x27;</span>,<span class="string">&#x27;undefined&#x27;</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(baseTypes.<span class="title function_">includes</span>(<span class="keyword">typeof</span> L) || L === <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分别取传入参数的原型</span></span><br><span class="line">    <span class="keyword">let</span> <span class="title class_">Lp</span> = L.<span class="property">__proto__</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="title class_">Rp</span> = R.<span class="property"><span class="keyword">prototype</span></span>; <span class="comment">// 函数才拥有prototype属性</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断原型</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="title class_">Lp</span> === <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="title class_">Lp</span> === <span class="title class_">Rp</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="title class_">Lp</span> = <span class="title class_">Lp</span>.<span class="property">__proto__</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 验证</span></span><br><span class="line"><span class="keyword">const</span> isArray = <span class="title function_">mu_instanceof</span>([],<span class="title class_">Array</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(isArray); <span class="comment">//true</span></span><br><span class="line"><span class="keyword">const</span> isDate = <span class="title function_">mu_instanceof</span>(<span class="string">&#x27;2023-01-09&#x27;</span>,<span class="title class_">Date</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(isDate); <span class="comment">// false</span></span><br><span class="line"> </span><br></pre></td></tr></table></figure><h1 id="49-js-的节流与防抖"><a href="#49-js-的节流与防抖" class="headerlink" title="49. js 的节流与防抖"></a>49. js 的节流与防抖</h1><h2 id="1-防抖"><a href="#1-防抖" class="headerlink" title="1.防抖"></a>1.防抖</h2><p><em>函数防抖是在事件被触发n秒后再执行回调，如果在「n秒内又被触发」，则「重新计时」</em></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">debounce</span>(<span class="params">fn, wait</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> timer = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (timer != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line">      &#125;</span><br><span class="line">      timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">fn</span>();</span><br><span class="line">      &#125;, wait);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 测试</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">handle</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 窗口大小改变，触发防抖，执行handle</span></span><br><span class="line">  <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;resize&#x27;</span>, <span class="title function_">debounce</span>(handle, <span class="number">1000</span>));</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h2 id="2-节流"><a href="#2-节流" class="headerlink" title="2.节流"></a>2.节流</h2><p><em>当事件触发时，保证一定时间段内只<strong>调用一次</strong>函数。例如页面滚动的时候，每隔一段时间发一次请求</em></p><p><strong>实现步骤：</strong></p><ul><li>传入参数为执行函数fn，等待时间wait。</li><li>保存初始时间now。</li><li>返回一个函数，如果超过等待时间，执行函数，将now更新为当前时间。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">throttle</span>(<span class="params">fn, wait, ...args</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> pre = <span class="title class_">Date</span>.<span class="title function_">now</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="comment">// 函数可能会有入参</span></span><br><span class="line">      <span class="keyword">var</span> context = <span class="variable language_">this</span>;</span><br><span class="line">      <span class="keyword">var</span> now = <span class="title class_">Date</span>.<span class="title function_">now</span>();</span><br><span class="line">      <span class="keyword">if</span> (now - pre &gt;= wait) &#123;</span><br><span class="line">        <span class="comment">// 将执行函数的this指向当前作用域</span></span><br><span class="line">        fn.<span class="title function_">apply</span>(context, args);</span><br><span class="line">        pre = <span class="title class_">Date</span>.<span class="title function_">now</span>();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 测试</span></span><br><span class="line">  <span class="keyword">var</span> name = <span class="string">&#x27;mu&#x27;</span>;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">handle</span>(<span class="params">val</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(val + <span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 滚动鼠标，触发防抖，执行handle</span></span><br><span class="line">  <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;scroll&#x27;</span>, <span class="title function_">throttle</span>(handle, <span class="number">1000</span>, <span class="string">&#x27;木由&#x27;</span>));</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h1 id="50-HTML、XML、XHTML-的区别"><a href="#50-HTML、XML、XHTML-的区别" class="headerlink" title="50.HTML、XML、XHTML 的区别"></a>50.HTML、XML、XHTML 的区别</h1><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="code">`HTML`</span>：超文本标记语言，是语法较为松散的、不严格的<span class="code">`Web`</span>语言；</span><br><span class="line"><span class="bullet">-</span> <span class="code">`XML`</span>：可扩展的标记语言，主要用于存储数据和结构，可扩展；</span><br><span class="line"><span class="bullet">-</span> <span class="code">`XHTML`</span>：可扩展的超文本标记语言，基于<span class="code">`XML`</span>，作用与<span class="code">`HTML`</span>类似，但语法更严格。</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h1 id="51-HTML、XHTML和HTML5区别以及有什么联系"><a href="#51-HTML、XHTML和HTML5区别以及有什么联系" class="headerlink" title="51. HTML、XHTML和HTML5区别以及有什么联系"></a>51. HTML、XHTML和HTML5区别以及有什么联系</h1><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">XHTML与HTML的区别</span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> <span class="code">`XHTML`</span>标签名必须小写；</span><br><span class="line"><span class="bullet">-</span> <span class="code">`XHTML`</span>元素必须被关闭；</span><br><span class="line"><span class="bullet">-</span> <span class="code">`XHTML`</span>元素必须被正确的嵌套；</span><br><span class="line"><span class="bullet">-</span> <span class="code">`XHTML`</span>元素必须要有根元素。</span><br><span class="line"></span><br><span class="line">XHTML与HTML5的区别</span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> <span class="code">`HTML5`</span>新增了<span class="code">`canvas`</span>绘画元素；</span><br><span class="line"><span class="bullet">-</span> <span class="code">`HTML5`</span>新增了用于绘媒介回放的<span class="code">`video`</span>和<span class="code">`audio`</span>元素；</span><br><span class="line"><span class="bullet">-</span> 更具语义化的标签，便于浏览器识别；</span><br><span class="line"><span class="bullet">-</span> 对本地离线存储有更好的支持；</span><br><span class="line"><span class="bullet">-</span> <span class="code">`MATHML`</span>，<span class="code">`SVG`</span>等，可以更好的<span class="code">`render`</span>；</span><br><span class="line"><span class="bullet">-</span> 添加了新的表单控件：<span class="code">`calendar`</span>、<span class="code">`date`</span>、<span class="code">`time`</span>、<span class="code">`email`</span>等。</span><br><span class="line"></span><br><span class="line">HTML、XHTML、HTML5之间联系</span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> <span class="code">`XHTML`</span>是<span class="code">`HTML`</span>规范版本；</span><br><span class="line"><span class="bullet">-</span> <span class="code">`HTML5`</span>是<span class="code">`HTML`</span>、<span class="code">`XHTML`</span>以及<span class="code">`HTML DOM`</span>的新标准。</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h1 id="52-行内元素有哪些？块级元素有哪些？-空-void-元素有那些？"><a href="#52-行内元素有哪些？块级元素有哪些？-空-void-元素有那些？" class="headerlink" title="52.行内元素有哪些？块级元素有哪些？ 空(void)元素有那些？"></a>52.行内元素有哪些？块级元素有哪些？ 空(void)元素有那些？</h1><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> 行内元素： <span class="code">`a`</span>, <span class="code">`b`</span>, <span class="code">`span`</span>, <span class="code">`img`</span>, <span class="code">`input`</span>, <span class="code">`select`</span>, <span class="code">`strong`</span>;</span><br><span class="line"><span class="bullet">-</span> 块级元素： <span class="code">`div`</span>, <span class="code">`ul`</span>, <span class="code">`li`</span>, <span class="code">`dl`</span>, <span class="code">`dt`</span>, <span class="code">`dd`</span>, <span class="code">`h1-5`</span>, <span class="code">`p`</span>等；</span><br><span class="line"><span class="bullet">-</span> 空元素： <span class="code">`&lt;br&gt;`</span>, <span class="code">`&lt;hr&gt;`</span>, <span class="code">`&lt;img&gt;`</span>, <span class="code">`&lt;link&gt;`</span>, <span class="code">`&lt;meta&gt;`</span>;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h1 id="53-页面导入样式时，使用link和-import有什么区别"><a href="#53-页面导入样式时，使用link和-import有什么区别" class="headerlink" title="53. 页面导入样式时，使用link和@import有什么区别"></a>53. 页面导入样式时，使用link和@import有什么区别</h1><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="code">`link`</span>属于<span class="code">`HTML`</span>标签，而<span class="code">`@import`</span>是<span class="code">`css`</span>提供的；</span><br><span class="line"><span class="bullet">-</span> 页面被加载时，<span class="code">`link`</span>会同时被加载，而<span class="code">`@import`</span>引用的css会等到页面被加载完再加载；</span><br><span class="line"><span class="bullet">-</span> <span class="code">`@import`</span>只在<span class="code">`IE5`</span>以上才能识别，而<span class="code">`link`</span>是<span class="code">`XHTML`</span>标签，无兼容问题；</span><br><span class="line"><span class="bullet">-</span> <span class="code">`link`</span>方式的样式的权重高于<span class="code">`@import`</span>的权重。</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h1 id="54-如何理解语义化标签"><a href="#54-如何理解语义化标签" class="headerlink" title="54. 如何理解语义化标签"></a>54. 如何理解语义化标签</h1><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">概念</span><br><span class="line"></span><br><span class="line">语义化是指根据内容的结构化（内容语义化），选择合适的标签（代码语义化），便于开发者阅读和写出更优雅的代码的同时，让浏览器的爬虫和机器很好的解析。</span><br><span class="line"></span><br><span class="line">语义化的好处</span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> 用正确的标签做正确的事情；</span><br><span class="line"><span class="bullet">-</span> 去掉或者丢失样式的时候能够让页面呈现出清晰的结构；</span><br><span class="line"><span class="bullet">-</span> 方便其他设备解析（如屏幕阅读器、盲人阅读器、移动设备）以意义的方式来渲染网页；</span><br><span class="line"><span class="bullet">-</span> 有利于<span class="code">`SEO`</span>：和搜索引擎建立良好沟通，有助于爬虫抓取更多的有效信息：爬虫依赖于标签来确定上下文和各个关键字的权重；</span><br><span class="line"><span class="bullet">-</span> 便于团队开发和维护，语义化更具可读性，遵循W3C标准的团队都遵循这个标准，可以减少差异化。</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h1 id="55-property和attribute的区别是什么"><a href="#55-property和attribute的区别是什么" class="headerlink" title="55. property和attribute的区别是什么"></a>55. property和attribute的区别是什么</h1><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="code">`property`</span>是<span class="code">`DOM`</span>中的属性，是<span class="code">`JavaScript`</span>里的对象;</span><br><span class="line"><span class="bullet">-</span> <span class="code">`attribute`</span>是<span class="code">`HTML`</span>标签上的特性，它的值只能够是字符串;</span><br><span class="line"></span><br><span class="line">简单的理解就是：<span class="code">`Attribute`</span>就是<span class="code">`DOM`</span>节点自带的属性，例如<span class="code">`html`</span>中常用的<span class="code">`id`</span>、<span class="code">`class`</span>、<span class="code">`title`</span>、<span class="code">`align`</span>等；而<span class="code">`Property`</span>是这个<span class="code">`DOM`</span>元素作为对象，其附加的内容，例如<span class="code">`childNodes`</span>、<span class="code">`firstChild`</span>等。</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h1 id="56-html5有哪些新特性、移除了那些元素"><a href="#56-html5有哪些新特性、移除了那些元素" class="headerlink" title="56. html5有哪些新特性、移除了那些元素"></a>56. html5有哪些新特性、移除了那些元素</h1><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">新特性</span><br><span class="line"></span><br><span class="line"><span class="strong">**HTML5 现在已经不是 SGML 的子集，主要是关于图像，位置，存储，多任务等功能的增加。**</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> 拖拽释放<span class="code">`(Drag and drop)`</span> <span class="code">`API`</span>；</span><br><span class="line"><span class="bullet">-</span> 语义化更好的内容标签（<span class="code">`header`</span>, <span class="code">`nav`</span>, <span class="code">`footer`</span>, <span class="code">`aside`</span>, <span class="code">`article`</span>, <span class="code">`section`</span>）;</span><br><span class="line"><span class="bullet">-</span> 音频、视频API(<span class="code">`audio`</span>, <span class="code">`video`</span>);</span><br><span class="line"><span class="bullet">-</span> 画布<span class="code">`(Canvas)`</span> <span class="code">`API`</span>;</span><br><span class="line"><span class="bullet">-</span> 地理<span class="code">`(Geolocation)`</span> <span class="code">`API`</span>;</span><br><span class="line"><span class="bullet">-</span> 本地离线存储 <span class="code">`localStorage`</span> 长期存储数据，浏览器关闭后数据不丢失；</span><br><span class="line"><span class="bullet">-</span> <span class="code">`sessionStorage`</span> 的数据在浏览器关闭后自动删除;</span><br><span class="line"><span class="bullet">-</span> 表单控件:<span class="code">`calendar`</span>、<span class="code">`date`</span>、<span class="code">`time`</span>、<span class="code">`email`</span>、<span class="code">`url`</span>、<span class="code">`search`</span> ;</span><br><span class="line"><span class="bullet">-</span> 新的技术<span class="code">`webworker`</span>, <span class="code">`websocket`</span>, <span class="code">`Geolocation`</span>等；</span><br><span class="line"></span><br><span class="line">移除元素</span><br><span class="line"></span><br><span class="line"><span class="strong">**纯表现元素**</span>：</span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> <span class="code">`&lt;basefont&gt;`</span> 默认字体，不设置字体，以此渲染；</span><br><span class="line"><span class="bullet">-</span> <span class="code">`&lt;font&gt;`</span> 字体标签；</span><br><span class="line"><span class="bullet">-</span> <span class="code">`&lt;center&gt;`</span> 水平居中；</span><br><span class="line"><span class="bullet">-</span> <span class="code">`&lt;u&gt;`</span> 下划线；</span><br><span class="line"><span class="bullet">-</span> <span class="code">`&lt;big&gt;`</span>字体；</span><br><span class="line"><span class="bullet">-</span> <span class="code">`&lt;strike&gt;`</span>中横字；</span><br><span class="line"><span class="bullet">-</span> <span class="code">`&lt;tt&gt;`</span>文本等宽；</span><br><span class="line"></span><br><span class="line"><span class="strong">**对可用性产生负面影响的元素**</span>：</span><br><span class="line"></span><br><span class="line"><span class="code">`&lt;frameset&gt;`</span>,<span class="code">`&lt;noframes&gt;`</span>和<span class="code">`&lt;frame&gt;`</span>；</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h1 id="57-什么是前端的结构，样式和行为相分离？以及分离的好处是什么？"><a href="#57-什么是前端的结构，样式和行为相分离？以及分离的好处是什么？" class="headerlink" title="57. 什么是前端的结构，样式和行为相分离？以及分离的好处是什么？"></a>57. 什么是前端的结构，样式和行为相分离？以及分离的好处是什么？</h1><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">结构，样式和行为分离</span><br><span class="line"></span><br><span class="line">若是将前端比作一个人来举例子，结构（<span class="code">`HTML`</span>）就相当于是人体的“骨架”，样式就相当于人体的“装饰”，例如衣服，首饰等；行为就相当于人做出的一系列“动作”。</span><br><span class="line"></span><br><span class="line">在结构，样式和行为分离，就是将三者分离开，各自负责各自的内容，各部分可以通过引用进行使用。</span><br><span class="line"></span><br><span class="line">在分离的基础上，我们需要做到代码的：<span class="strong">**精简**</span>， <span class="strong">**重用**</span>， <span class="strong">**有序**</span>。</span><br><span class="line"></span><br><span class="line">分离的好处</span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> 代码分离，利于团队的开发和后期的维护；</span><br><span class="line"><span class="bullet">-</span> 减少维护成本，提高可读性和更好的兼容性；</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h1 id="58-如何对网站的文件和资源进行优化"><a href="#58-如何对网站的文件和资源进行优化" class="headerlink" title="58. 如何对网站的文件和资源进行优化"></a>58. 如何对网站的文件和资源进行优化</h1><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> 文件合并（目的是减少<span class="code">`http`</span>请求）；</span><br><span class="line"><span class="bullet">-</span> 文件压缩 （目的是直接减少文件下载的体积）；</span><br><span class="line"><span class="bullet">-</span> 使用缓存；</span><br><span class="line"><span class="bullet">-</span> 使用<span class="code">`cdn`</span>托管资源；</span><br><span class="line"><span class="bullet">-</span> <span class="code">`gizp`</span>压缩需要的js和css文件；</span><br><span class="line"><span class="bullet">-</span> 反向链接，网站外链接优化；</span><br><span class="line"><span class="bullet">-</span> meta标签优化（<span class="code">`title`</span>, <span class="code">`description`</span>, <span class="code">`keywords`</span>）,<span class="code">`heading`</span>标签的优化,<span class="code">`alt`</span>优化；</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h1 id="59-Html5中本地存储概念是什么，有什么优点，与cookie有什么区别？"><a href="#59-Html5中本地存储概念是什么，有什么优点，与cookie有什么区别？" class="headerlink" title="59. Html5中本地存储概念是什么，有什么优点，与cookie有什么区别？"></a>59. Html5中本地存储概念是什么，有什么优点，与cookie有什么区别？</h1><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="code">`HTML5`</span>的<span class="code">`Web storage`</span>的存储方式有两种：<span class="code">`sessionStorage`</span>和<span class="code">`localStorage`</span>。</span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> <span class="code">`sessionStorage`</span>用于本地存储一个会话中的数据，当会话结束后就会销毁；</span><br><span class="line"><span class="bullet">-</span> 和<span class="code">`sessionStorage`</span>不同，<span class="code">`localStorage`</span>用于持久化的本地存储，除非用户主动删除数据，否则数据永远不会过期；</span><br><span class="line"><span class="bullet">-</span> <span class="code">`cookie`</span>是网站为了标示用户身份而储存在用户本地终端（<span class="code">`Client Side`</span>）上的数据（通常经过加密）。</span><br><span class="line"></span><br><span class="line"><span class="strong">**区别**</span>：</span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> <span class="strong">**从浏览器和服务器间的传递看**</span>： <span class="code">`cookie`</span>数据始终在同源的http请求中携带（即使不需要），即<span class="code">`cookie`</span>在浏览器和服务器间来回传递；而<span class="code">`sessionStorage`</span>和<span class="code">`localStorage`</span>不会自动把数据发给服务器，仅在本地保存。</span><br><span class="line"><span class="bullet">-</span> <span class="strong">**从大小看**</span>： 存储大小限制不同，<span class="code">`cookie`</span>数据不能超过<span class="code">`4k`</span>，只适合保存很小的数据；而<span class="code">`sessionStorage`</span>和<span class="code">`localStorage`</span> 虽然也有存储大小的限制，但比<span class="code">`cookie`</span>大得多，可以达到5M或更大。</span><br><span class="line"><span class="bullet">-</span> <span class="strong">**从数据有效期看**</span>： <span class="code">`sessionStorage`</span>在会话关闭会立刻关闭，因此持续性不久；<span class="code">`cookie`</span>只在设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭。而<span class="code">`localStorage`</span>始终有效。</span><br><span class="line"><span class="bullet">-</span> <span class="strong">**从作用域看**</span>： <span class="code">`sessionStorage`</span>不在不同的浏览器窗口中共享，即使是同一个页面；而<span class="code">`localStorage`</span>和<span class="code">`cookie`</span>都是可以在所有的同源窗口中共享的。</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h1 id="60-常见的浏览器内核有哪些"><a href="#60-常见的浏览器内核有哪些" class="headerlink" title="60. 常见的浏览器内核有哪些"></a>60. 常见的浏览器内核有哪些</h1><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="code">`Trident`</span>内核：IE最先开发或使用的， 360浏览器；</span><br><span class="line"><span class="bullet">-</span> <span class="code">`Webkit`</span>内核：Google Chrome，Safari， 搜狗浏览器，360极速浏览器， 阿里云浏览器等；</span><br><span class="line"><span class="bullet">-</span> <span class="code">`Gecko`</span>内核： Mozilla FireFox (火狐浏览器) ，K-Meleon浏览器；</span><br><span class="line"><span class="bullet">-</span> <span class="code">`Presto`</span>内核：Opera浏览器；</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h1 id="61-LocalStorage本地存储在HTML5中有什么用途"><a href="#61-LocalStorage本地存储在HTML5中有什么用途" class="headerlink" title="61. LocalStorage本地存储在HTML5中有什么用途"></a>61. LocalStorage本地存储在HTML5中有什么用途</h1><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="code">`localStorage`</span>本地存储相当于一个轻量级的数据库，可以在本地永久的储存数据（除非人为删除）。此外，还可以在断网情况下读取本地缓存的<span class="code">`cookies`</span>。</span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> 使用<span class="code">`localStorage`</span>保存数据： <span class="code">`localStorage.setItem(key, value)`</span>;</span><br><span class="line"><span class="bullet">-</span> 使用<span class="code">`localStorage`</span>获取保存的数据: <span class="code">`localStorage.getItem(key)`</span>;</span><br><span class="line"><span class="bullet">-</span> 清除<span class="code">`localStorage`</span>保存的数据： <span class="code">`localStorage.removeItem(key)`</span>;</span><br><span class="line"><span class="bullet">-</span> 清除全部<span class="code">`localStorage`</span>对象保存的数据: <span class="code">`localStorage.clear( )`</span>;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h1 id="62-为什么利用多个域名来存储网站资源会更有效"><a href="#62-为什么利用多个域名来存储网站资源会更有效" class="headerlink" title="62. 为什么利用多个域名来存储网站资源会更有效"></a>62. 为什么利用多个域名来存储网站资源会更有效</h1><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="code">`CDN`</span>缓存更加方便；</span><br><span class="line"><span class="bullet">-</span> 突破浏览器并发限制；</span><br><span class="line"><span class="bullet">-</span> 节约<span class="code">`cookie`</span>宽带；</span><br><span class="line"><span class="bullet">-</span> 节约主域名的连接数，优化页面下响应速度；</span><br><span class="line"><span class="bullet">-</span> 防止不必要的安全问题；</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h1 id="63-HTML中几种图片格式的区别以及使用"><a href="#63-HTML中几种图片格式的区别以及使用" class="headerlink" title="63. HTML中几种图片格式的区别以及使用"></a>63. HTML中几种图片格式的区别以及使用</h1><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">页面中常用的几种图片格式有: <span class="code">`png`</span>, <span class="code">`jpg(jpeg)`</span>,<span class="code">`gif`</span>, <span class="code">`bmp`</span>等；</span><br><span class="line"></span><br><span class="line">（1）、<span class="strong">**Png格式的特征**</span></span><br><span class="line"></span><br><span class="line">特征： 图片背景透明，可以支持的颜色有很多。</span><br><span class="line"></span><br><span class="line">使用范围: 比较广，在目前使用频率最高。</span><br><span class="line"></span><br><span class="line">（2）、<span class="strong">**jpg格式特征**</span></span><br><span class="line"></span><br><span class="line">特征： 图片不支持透明，静态图，支持的颜色也比较多，可压缩。</span><br><span class="line"></span><br><span class="line">使用范围： 使用范围较广，可使用作为电脑做面壁纸，手机屏保等，可根据需求来确实使用图片的分辨率，</span><br><span class="line"></span><br><span class="line">（3）、<span class="strong">**gif格式特征**</span></span><br><span class="line"></span><br><span class="line">特征： 动态图，支持的颜色较少。</span><br><span class="line"></span><br><span class="line">使用范围： 在目前看到的在网站内使用频率较低。</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h1 id="64-DNS是什么"><a href="#64-DNS是什么" class="headerlink" title="64.DNS是什么"></a>64.DNS是什么</h1><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">全称 Domain Name System , 即域名系统。</span><br><span class="line"></span><br><span class="line"><span class="quote">&gt; 万维网上作为域名和 IP 地址相互映射的一个分布式数据库，能够使用户更方便的访问互联网，而不用去记住能够被机器直接读取的 IP 数串。DNS 协议运行在 UDP 协议之上，使用端口号 53。</span></span><br><span class="line"></span><br><span class="line">简单的说, 通过域名, 最终得到该域名对应的 IP 地址的过程叫做域名解析（或主机名解析）。</span><br><span class="line"></span><br><span class="line"><span class="code">```text</span></span><br><span class="line"><span class="code">www.zuofc.com (域名)  - DNS解析 -&gt; 111.222.33.444 (IP地址)</span></span><br><span class="line"><span class="code">```</span></span><br><span class="line"></span><br><span class="line">有 dns 的地方, 就有缓存。浏览器、操作系统、Local DNS、根域名服务器，它们都会对 DNS 结果做一定程度的缓存。</span><br><span class="line"></span><br><span class="line">DNS 查询过程如下:</span><br><span class="line"></span><br><span class="line"><span class="bullet">1.</span> 首先搜索浏览器自身的 DNS 缓存, 如果存在，则域名解析到此完成。</span><br><span class="line"><span class="bullet">2.</span> 如果浏览器自身的缓存里面没有找到对应的条目，那么会尝试读取操作系统的 hosts 文件看是否存在对应的映射关系, 如果存在，则域名解析到此完成。</span><br><span class="line"><span class="bullet">3.</span> 如果本地 hosts 文件不存在映射关系，则查找本地 DNS 服务器 (ISP 服务器, 或者自己手动设置的 DNS 服务器), 如果存在, 域名到此解析完成。</span><br><span class="line"><span class="bullet">4.</span> 如果本地 DNS 服务器还没找到的话, 它就会向根服务器发出请求, 进行递归查询。</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h1 id="65-什么是强缓存"><a href="#65-什么是强缓存" class="headerlink" title="65.什么是强缓存"></a>65.什么是强缓存</h1><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">强缓存</span><br><span class="line">浏览器在加载资源时，会先根据本地缓存资源的 header 中的信息判断是否命中强缓存，如果命中则直接使用缓存中的资源不会再向服务器发送请求。</span><br><span class="line"></span><br><span class="line">这里的 header 中的信息指的是 expires 和 cahe-control.</span><br><span class="line"></span><br><span class="line"><span class="title class_">Expires</span></span><br><span class="line">该字段是 http1.<span class="number">0</span> 时的规范，它的值为一个绝对时间的 <span class="variable constant_">GMT</span> 格式的时间字符串，比如 <span class="title class_">Expires</span><span class="symbol">:Mon</span>,<span class="number">18</span> <span class="title class_">Oct</span> <span class="number">2066</span> <span class="number">23</span><span class="symbol">:</span><span class="number">59</span><span class="symbol">:</span><span class="number">59</span> <span class="variable constant_">GMT</span>。这个时间代表着这个资源的失效时间，在此时间之前，即命中缓存。这种方式有一个明显的缺点，由于失效时间是一个绝对时间，所以当服务器与客户端时间偏差较大时，就会导致缓存混乱（本地时间也可以随便更改）。</span><br><span class="line"></span><br><span class="line"><span class="title class_">Cache</span>-<span class="title class_">Control</span>（优先级高于 <span class="title class_">Expires</span>）</span><br><span class="line"><span class="title class_">Cache</span>-<span class="title class_">Control</span> 是 http1.<span class="number">1</span> 时出现的 header 信息，主要是利用该字段的 max-age 值来进行判断，它是一个相对时间，例如 <span class="title class_">Cache</span>-<span class="title class_">Control</span><span class="symbol">:max-age=</span><span class="number">3600</span>，代表着资源的有效期是 <span class="number">3600</span> 秒。cache-control 除了该字段外，还有下面几个比较常用的设置值：</span><br><span class="line"></span><br><span class="line">no-cache：需要进行协商缓存，发送请求到服务器确认是否使用缓存。</span><br><span class="line">no-store：禁止使用缓存，每一次都要重新请求数据。</span><br><span class="line"><span class="keyword">public</span>：可以被所有的用户缓存，包括终端用户和 <span class="variable constant_">CDN</span> 等中间代理服务器。</span><br><span class="line"><span class="keyword">private</span>：只能被终端用户的浏览器缓存，不允许 <span class="variable constant_">CDN</span> 等中继缓存服务器对其缓存。</span><br><span class="line"><span class="title class_">Cache</span>-<span class="title class_">Control</span> 与 <span class="title class_">Expires</span> 可以在服务端配置同时启用，同时启用的时候 <span class="title class_">Cache</span>-<span class="title class_">Control</span> 优先级高。</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h1 id="66-什么是协商缓存"><a href="#66-什么是协商缓存" class="headerlink" title="66.什么是协商缓存"></a>66.什么是协商缓存</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">当强缓存没有命中的时候，浏览器会发送一个请求到服务器，服务器根据 header 中的部分信息来判断是否命中缓存。如果命中，则返回 <span class="number">304</span> ，告诉浏览器资源未更新，可使用本地的缓存。</span><br><span class="line"></span><br><span class="line">这里的 header 中的信息指的是 <span class="keyword">Last</span><span class="operator">-</span>Modify<span class="operator">/</span>If<span class="operator">-</span>Modify<span class="operator">-</span>Since 和 ETag<span class="operator">/</span>If<span class="operator">-</span><span class="keyword">None</span><span class="operator">-</span>Match.</span><br><span class="line"></span><br><span class="line"><span class="keyword">Last</span><span class="operator">-</span>Modify<span class="operator">/</span>If<span class="operator">-</span>Modify<span class="operator">-</span>Since</span><br><span class="line">浏览器第一次请求一个资源的时候，服务器返回的 header 中会加上 <span class="keyword">Last</span><span class="operator">-</span>Modify，<span class="keyword">Last</span><span class="operator">-</span>modify 是一个时间标识该资源的最后修改时间（只能精确到秒，所以间隔时间小于 <span class="number">1</span> 秒的请求是检测不到文件更改的。）。</span><br><span class="line"></span><br><span class="line">当浏览器再次请求该资源时，request 的请求头中会包含 If<span class="operator">-</span>Modify<span class="operator">-</span>Since，该值为缓存之前返回的 <span class="keyword">Last</span><span class="operator">-</span>Modify。服务器收到 If<span class="operator">-</span>Modify<span class="operator">-</span>Since 后，根据资源的最后修改时间判断是否命中缓存。</span><br><span class="line"></span><br><span class="line">如果命中缓存，则返回 <span class="number">304</span>，并且不会返回资源内容，并且不会返回 <span class="keyword">Last</span><span class="operator">-</span>Modify。</span><br><span class="line"></span><br><span class="line">缺点:</span><br><span class="line"></span><br><span class="line">短时间内资源发生了改变，<span class="keyword">Last</span><span class="operator">-</span>Modified 并不会发生变化。</span><br><span class="line"></span><br><span class="line">周期性变化。如果这个资源在一个周期内修改回原来的样子了，我们认为是可以使用缓存的，但是 <span class="keyword">Last</span><span class="operator">-</span>Modified 可不这样认为, 因此便有了 ETag。</span><br><span class="line"></span><br><span class="line">ETag<span class="operator">/</span>If<span class="operator">-</span><span class="keyword">None</span><span class="operator">-</span><span class="keyword">Match</span></span><br><span class="line">Etag 是基于文件内容进行编码的，可以保证如果服务器有更新，一定会重新请求资源，但是编码需要付出额外的开销。</span><br><span class="line"></span><br><span class="line">与 <span class="keyword">Last</span><span class="operator">-</span>Modify<span class="operator">/</span>If<span class="operator">-</span>Modify<span class="operator">-</span>Since 不同的是，Etag<span class="operator">/</span>If<span class="operator">-</span><span class="keyword">None</span><span class="operator">-</span><span class="keyword">Match</span> 返回的是一个校验码。ETag 可以保证每一个资源是唯一的，资源变化都会导致 ETag 变化。服务器根据浏览器上送的 If<span class="operator">-</span><span class="keyword">None</span><span class="operator">-</span><span class="keyword">Match</span> 值来判断是否命中缓存。</span><br><span class="line"></span><br><span class="line">与 <span class="keyword">Last</span><span class="operator">-</span>Modified 不一样的是，当服务器返回 <span class="number">304</span> <span class="keyword">Not</span> Modified 的响应时，由于 ETag 重新生成过，response header 中还会把这个 ETag 返回，即使这个 ETag 跟之前的没有变化。</span><br><span class="line"></span><br><span class="line"><span class="keyword">Last</span><span class="operator">-</span>Modified 与 ETag 是可以一起使用的，服务器会优先验证 ETag，一致的情况下，才会继续比对 <span class="keyword">Last</span><span class="operator">-</span>Modified，最后才决定是否返回 <span class="number">304</span>。 </span><br></pre></td></tr></table></figure><h1 id="67-打开-Chrome-浏览器一个-Tab-页面，至少会出现几个进程？"><a href="#67-打开-Chrome-浏览器一个-Tab-页面，至少会出现几个进程？" class="headerlink" title="67.打开 Chrome 浏览器一个 Tab 页面，至少会出现几个进程？"></a>67.打开 Chrome 浏览器一个 Tab 页面，至少会出现几个进程？</h1><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">最新的 <span class="selector-tag">Chrome</span> 浏览器包括至少四个: <span class="number">1</span> 个浏览器（<span class="selector-tag">Browser</span>）主进程、<span class="number">1</span> 个 <span class="selector-tag">GPU</span> 进程、<span class="number">1</span> 个网络（<span class="selector-tag">NetWork</span>）进程、多个渲染进程和多个插件进程, 当然还有复杂的情况；</span><br><span class="line"></span><br><span class="line">页面中有 <span class="selector-tag">iframe</span> 的话, <span class="selector-tag">iframe</span> 会单独在进程中</span><br><span class="line"></span><br><span class="line">有插件的话，插件也会开启进程</span><br><span class="line"></span><br><span class="line">多个页面属于同一站点，并且从 <span class="selector-tag">a</span> 打开 <span class="selector-tag">b</span> 页面，会共用一个渲染进程</span><br><span class="line"></span><br><span class="line">装了扩展的话，扩展也会占用进程</span><br><span class="line"></span><br><span class="line">这些进程都可以通过 <span class="selector-tag">Chrome</span> 任务管理器来查看</span><br></pre></td></tr></table></figure><h1 id="68-即使如今多进程架构，还是会碰到单页面卡死的最终崩溃导致所有页面崩溃的情况，讲一讲你的理解？"><a href="#68-即使如今多进程架构，还是会碰到单页面卡死的最终崩溃导致所有页面崩溃的情况，讲一讲你的理解？" class="headerlink" title="68.即使如今多进程架构，还是会碰到单页面卡死的最终崩溃导致所有页面崩溃的情况，讲一讲你的理解？"></a>68.即使如今多进程架构，还是会碰到单页面卡死的最终崩溃导致所有页面崩溃的情况，讲一讲你的理解？</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">提供一种情况，就是同一站点, 围绕这个展开也行。</span><br><span class="line"></span><br><span class="line"><span class="title class_">Chrome</span> 的默认策略是，每个标签对应一个渲染进程。但是如果从一个页面打开了新页面，而新页面和当前页面属于同一站点时，那么新页面会复用父页面的渲染进程。官方把这个默认策略叫 process-per-site-instance。</span><br><span class="line"></span><br><span class="line">更加简单的来说，就是如果多个页面符合同一站点，这几个页面会分配到一个渲染进程中去, 所以有这样子的一种情况, 一个页面崩溃了，会导致同一个站点的其他页面也奔溃，这是因为它们使用的是同一个渲染进程。</span><br><span class="line"></span><br><span class="line">有人会问为什么会跑到一个进程里面呢?</span><br><span class="line"></span><br><span class="line">你想一想呀, 属于同一家的站点，比如下面三个:</span><br><span class="line"></span><br><span class="line"><span class="attr">https</span>:<span class="comment">//time.geekbang.org</span></span><br><span class="line"><span class="attr">https</span>:<span class="comment">//www.geekbang.org</span></span><br><span class="line"><span class="attr">https</span>:<span class="comment">//www.geekbang.org:8080</span></span><br><span class="line">它们在一个渲染进程中的话，它们就会共享 <span class="variable constant_">JS</span> 执行环境，也就是 A 页面可以直接在 B 页面中执行脚本了, 有些时候就是有这样子的需求嘛。</span><br></pre></td></tr></table></figure><h1 id="69-TCP-建立连接过程讲一讲，为什么握手需要三次？"><a href="#69-TCP-建立连接过程讲一讲，为什么握手需要三次？" class="headerlink" title="69.TCP 建立连接过程讲一讲，为什么握手需要三次？"></a>69.TCP 建立连接过程讲一讲，为什么握手需要三次？</h1><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">**三次握手**</span><br><span class="line"></span><br><span class="line">第一次握手</span><br><span class="line">客户端向服务端发送连接请求报文段。该报文段的头部中 SYN=<span class="number">1</span>，ACK=<span class="number">0</span>，seq=x。请求发送后，客户端便进入 SYN-SENT 状态。</span><br><span class="line"></span><br><span class="line">PS1：SYN=<span class="number">1</span>，ACK=<span class="number">0</span> 表示该报文段为连接请求报文。</span><br><span class="line">PS2：x 为本次 TCP 通信的字节流的初始序号。</span><br><span class="line">TCP 规定：SYN=<span class="number">1</span> 的报文段不能有数据部分，但要消耗掉一个序号。</span><br><span class="line">第二次握手</span><br><span class="line">服务端收到连接请求报文段后，如果同意连接，则会发送一个应答：SYN=<span class="number">1</span>，ACK=<span class="number">1</span>，seq=y，ack=x+<span class="number">1</span>。</span><br><span class="line">该应答发送完成后便进入 SYN-RCVD 状态。</span><br><span class="line"></span><br><span class="line">PS1：SYN=<span class="number">1</span>，ACK=<span class="number">1</span> 表示该报文段为连接同意的应答报文。</span><br><span class="line">PS2：seq=y 表示服务端作为发送者时，发送字节流的初始序号。</span><br><span class="line">PS3：ack=x+<span class="number">1</span> 表示服务端希望下一个数据报发送序号从 x+<span class="number">1</span> 开始的字节。</span><br><span class="line">第三次握手</span><br><span class="line">当客户端收到连接同意的应答后，还要向服务端发送一个确认报文段，表示：服务端发来的连接同意应答已经成功收到。</span><br><span class="line">该报文段的头部为：ACK=<span class="number">1</span>，seq=x+<span class="number">1</span>，ack=y+<span class="number">1</span>。</span><br><span class="line">客户端发完这个报文段后便进入 ESTABLISHED 状态，服务端收到这个应答后也进入 ESTABLISHED 状态，此时连接的建立完成！</span><br><span class="line"></span><br><span class="line">**为什么连接建立需要三次握手，而不是两次握手**</span><br><span class="line"></span><br><span class="line">在谢希仁著《计算机网络》第四版中讲 “三次握手” 的目的是 “为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误”。在另一部经典的《计算机网络》一书中讲“三次握手” 的目的是为了解决 “网络中存在延迟的重复分组” 的问题。这两种不用的表述其实阐明的是同一个问题。</span><br><span class="line"></span><br><span class="line">谢希仁版《计算机网络》中的例子是这样的，“已失效的连接请求报文段”的产生在这样一种情况下：client 发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达 server。本来这是一个早已失效的报文段。但 server 收到此失效的连接请求报文段后，就误认为是 client 再次发出的一个新的连接请求。于是就向 client 发出确认报文段，同意建立连接。假设不采用 “三次握手”，那么只要 server 发出确认，新的连接就建立了。由于现在 client 并没有发出建立连接的请求，因此不会理睬 server 的确认，也不会向 server 发送数据。但 server 却以为新的运输连接已经建立，并一直等待 client 发来数据。这样，server 的很多资源就白白浪费掉了。采用“三次握手” 的办法可以防止上述现象发生。例如刚才那种情况，client 不会向 server 的确认发出确认。server 由于收不到确认，就知道 client 并没有要求建立连接。”</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">**四次挥手**</span><br><span class="line"></span><br><span class="line">第一次挥手</span><br><span class="line">若 <span class="selector-tag">A</span> 认为数据发送完成，则它需要向 <span class="selector-tag">B</span> 发送连接释放请求。该请求只有报文头，头中携带的主要参数为：</span><br><span class="line">FIN=<span class="number">1</span>，seq=u。此时，<span class="selector-tag">A</span> 将进入 FIN-WAIT-<span class="number">1</span> 状态。</span><br><span class="line"></span><br><span class="line">PS1：FIN=<span class="number">1</span> 表示该报文段是一个连接释放请求。</span><br><span class="line">PS2：seq=u，u-<span class="number">1</span> 是 <span class="selector-tag">A</span> 向 <span class="selector-tag">B</span> 发送的最后一个字节的序号。</span><br><span class="line">第二次挥手</span><br><span class="line"><span class="selector-tag">B</span> 收到连接释放请求后，会通知相应的应用程序，告诉它 <span class="selector-tag">A</span> 向 <span class="selector-tag">B</span> 这个方向的连接已经释放。此时 <span class="selector-tag">B</span> 进入 CLOSE-WAIT 状态，并向 <span class="selector-tag">A</span> 发送连接释放的应答，其报文头包含：</span><br><span class="line">ACK=<span class="number">1</span>，seq=v，ack=u+<span class="number">1</span>。</span><br><span class="line"></span><br><span class="line">PS1：ACK=<span class="number">1</span>：除 TCP 连接请求报文段以外，TCP 通信过程中所有数据报的 ACK 都为 <span class="number">1</span>，表示应答。</span><br><span class="line">PS2：seq=v，v-<span class="number">1</span> 是 <span class="selector-tag">B</span> 向 <span class="selector-tag">A</span> 发送的最后一个字节的序号。</span><br><span class="line">PS3：ack=u+<span class="number">1</span> 表示希望收到从第 u+<span class="number">1</span> 个字节开始的报文段，并且已经成功接收了前 u 个字节。</span><br><span class="line"><span class="selector-tag">A</span> 收到该应答，进入 FIN-WAIT-<span class="number">2</span> 状态，等待 <span class="selector-tag">B</span> 发送连接释放请求。</span><br><span class="line"></span><br><span class="line">第二次挥手完成后，<span class="selector-tag">A</span> 到 <span class="selector-tag">B</span> 方向的连接已经释放，<span class="selector-tag">B</span> 不会再接收数据，<span class="selector-tag">A</span> 也不会再发送数据。但 <span class="selector-tag">B</span> 到 <span class="selector-tag">A</span> 方向的连接仍然存在，<span class="selector-tag">B</span> 可以继续向 <span class="selector-tag">A</span> 发送数据。</span><br><span class="line"></span><br><span class="line">第三次挥手</span><br><span class="line">当 <span class="selector-tag">B</span> 向 <span class="selector-tag">A</span> 发完所有数据后，向 <span class="selector-tag">A</span> 发送连接释放请求，请求头：FIN=<span class="number">1</span>，ACK=<span class="number">1</span>，seq=w，ack=u+<span class="number">1</span>。<span class="selector-tag">B</span> 便进入 LAST-ACK 状态。</span><br><span class="line"></span><br><span class="line">第四次挥手</span><br><span class="line"><span class="selector-tag">A</span> 收到释放请求后，向 <span class="selector-tag">B</span> 发送确认应答，此时 <span class="selector-tag">A</span> 进入 <span class="selector-tag">TIME</span>-WAIT 状态。该状态会持续 <span class="number">2MS</span>L 时间，若该时间段内没有 <span class="selector-tag">B</span> 的重发请求的话，就进入 CLOSED 状态，撤销 TCB。当 <span class="selector-tag">B</span> 收到确认应答后，也便进入 CLOSED 状态，撤销 TCB。</span><br><span class="line"></span><br><span class="line">为什么 <span class="selector-tag">A</span> 要先进入 <span class="selector-tag">TIME</span>-WAIT 状态，等待 <span class="number">2MS</span>L 时间后才进入 CLOSED 状态？</span><br><span class="line">为了保证 <span class="selector-tag">B</span> 能收到 <span class="selector-tag">A</span> 的确认应答。</span><br><span class="line">若 <span class="selector-tag">A</span> 发完确认应答后直接进入 CLOSED 状态，那么如果该应答丢失，<span class="selector-tag">B</span> 等待超时后就会重新发送连接释放请求，但此时 <span class="selector-tag">A</span> 已经关闭了，不会作出任何响应，因此 <span class="selector-tag">B</span> 永远无法正常关闭。</span><br></pre></td></tr></table></figure><h1 id="70-从输入-URL-到页面展示，这中间发生了什么"><a href="#70-从输入-URL-到页面展示，这中间发生了什么" class="headerlink" title="70.从输入 URL 到页面展示，这中间发生了什么"></a>70.从输入 URL 到页面展示，这中间发生了什么</h1><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">URL解析</span><br><span class="line"><span class="bullet">  -</span> 首先判断你输入的是一个合法的URL 还是一个待搜索的关键词，并且根据你输入的内容进行对应操作</span><br><span class="line">DNS 查询</span><br><span class="line"><span class="bullet">  -</span> DNS查询对应ip</span><br><span class="line">TCP 连接</span><br><span class="line"><span class="bullet">  -</span> 在确定目标服务器服务器的IP地址后，则经历三次握手建立TCP连接</span><br><span class="line">HTTP 请求</span><br><span class="line"><span class="bullet">  -</span> 当建立tcp连接之后，就可以在这基础上进行通信，浏览器发送 http 请求到目标服务器</span><br><span class="line">响应请求</span><br><span class="line"><span class="bullet">  -</span> 当服务器接收到浏览器的请求之后，就会进行逻辑操作，处理完成之后返回一个HTTP响应消息</span><br><span class="line">页面渲染</span><br><span class="line"><span class="bullet">  -</span> 当浏览器接收到服务器响应的资源后，首先会对资源进行解析：</span><br><span class="line"></span><br><span class="line">  查看响应头的信息，根据不同的指示做对应处理，比如重定向，存储cookie，解压gzip，缓存资源等等</span><br><span class="line">  查看响应头的 Content-Type的值，根据不同的资源类型采用不同的解析方式</span><br><span class="line">  关于页面的渲染过程如下：</span><br><span class="line"></span><br><span class="line">  解析HTML，构建 DOM 树</span><br><span class="line">  解析 CSS ，生成 CSS 规则树</span><br><span class="line">  合并 DOM 树和 CSS 规则，生成 render 树</span><br><span class="line">  布局 render 树（ Layout / reflow ），负责各元素尺寸、位置的计算</span><br><span class="line">  绘制 render 树（ paint ），绘制页面像素信息</span><br><span class="line">  浏览器会将各层的信息发送给 GPU，GPU 会将各层合成（ composite ），显示在屏幕上</span><br></pre></td></tr></table></figure><h1 id="71-什么是-CDN"><a href="#71-什么是-CDN" class="headerlink" title="71.什么是 CDN"></a>71.什么是 CDN</h1><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">全称 <span class="attribute">Content</span> Delivery Network, 即内容分发网络。</span><br><span class="line"></span><br><span class="line">摘录一个形象的比喻, 来理解 CDN 是什么。</span><br><span class="line"></span><br><span class="line"><span class="number">10</span> 年前，还没有火车票代售点一说，<span class="number">12306</span><span class="selector-class">.cn</span> 更是无从说起。那时候火车票还只能在火车站的售票大厅购买，而我所在的小县城并不通火车，火车票都要去市里的火车站购买，而从我家到县城再到市里，来回就是 <span class="number">4</span> 个小时车程，简直就是浪费生命。后来就好了，小县城里出现了火车票代售点，甚至乡镇上也有了代售点，可以直接在代售点购买火车票，方便了不少，全市人民再也不用在一个点苦逼的排队买票了。</span><br><span class="line"></span><br><span class="line">简单的理解 CDN 就是这些代售点 (缓存服务器) 的承包商, 他为买票者提供了便利, 帮助他们在最近的地方 (最近的 CDN 节点) 用最短的时间 (最短的请求时间) 买到票(拿到资源), 这样去火车站售票大厅排队的人也就少了。也就减轻了售票大厅的压力(起到分流作用, 减轻服务器负载压力)。</span><br><span class="line"></span><br><span class="line">用户在浏览网站的时候，CDN 会选择一个离用户最近的 CDN 边缘节点来响应用户的请求，这样海南移动用户的请求就不会千里迢迢跑到北京电信机房的服务器（假设源站部署在北京电信机房）上了。</span><br><span class="line"></span><br><span class="line">CDN 缓存</span><br><span class="line">关于 CDN 缓存, 在浏览器本地缓存失效后, 浏览器会向 CDN 边缘节点发起请求。类似浏览器缓存, CDN 边缘节点也存在着一套缓存机制。CDN 边缘节点缓存策略因服务商不同而不同，但一般都会遵循 http 标准协议，通过 http 响应头中的</span><br><span class="line"></span><br><span class="line">Cache-control: max-age   //后面会提到</span><br><span class="line">的字段来设置 CDN 边缘节点数据缓存时间。</span><br><span class="line"></span><br><span class="line">当浏览器向 CDN 节点请求数据时，CDN 节点会判断缓存数据是否过期，若缓存数据并没有过期，则直接将缓存数据返回给客户端；否则，CDN 节点就会向服务器发出回源请求，从服务器拉取最新数据，更新本地缓存，并将最新数据返回给客户端。 CDN 服务商一般会提供基于文件后缀、目录多个维度来指定 CDN 缓存时间，为用户提供更精细化的缓存管理。</span><br><span class="line"></span><br><span class="line">CDN 优势</span><br><span class="line">CDN 节点解决了跨运营商和跨地域访问的问题，访问延时大大降低。</span><br><span class="line">大部分请求在 CDN 边缘节点完成，CDN 起到了分流作用，减轻了源服务器的负载。</span><br></pre></td></tr></table></figure><h1 id="72-说说HTTP与HTTPS的区别"><a href="#72-说说HTTP与HTTPS的区别" class="headerlink" title="72. 说说HTTP与HTTPS的区别"></a>72. 说说HTTP与HTTPS的区别</h1><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HTTPS是HTTP协议的安全版本，HTTP协议的数据传输是明文的，是不安全的，HTTPS使用了SSL/TLS协议进行了加密处理，相对更安全</span><br><span class="line">HTTP 和 HTTPS 使用连接方式不同，默认端口也不一样，HTTP是80，HTTPS是443</span><br><span class="line">HTTPS 由于需要设计加密以及多次握手，性能方面不如 HTTP</span><br><span class="line">HTTPS需要SSL，SSL 证书需要钱，功能越强大的证书费用越高</span><br></pre></td></tr></table></figure><h1 id="73-webpack文件指纹策略：hash-chunkhash-contenthash"><a href="#73-webpack文件指纹策略：hash-chunkhash-contenthash" class="headerlink" title="73.webpack文件指纹策略：hash chunkhash contenthash"></a>73.webpack文件指纹策略：hash chunkhash contenthash</h1><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">hash策略：是以项目为单位的，项目内容改变则会生成新的hash，内容不变则hash不变</span><br><span class="line"></span><br><span class="line">chunkhash策略：是以chunk为单位的，当一个文件内容改变，则整个相应的chunk组模块的hash回发生改变</span><br><span class="line"></span><br><span class="line">contenthash策略：是以自身内容为单为的</span><br><span class="line"></span><br><span class="line">推荐使用：css ：contenthash</span><br><span class="line"></span><br><span class="line">•js：chunkhash</span><br></pre></td></tr></table></figure><h1 id="74-说说webpack的构建流程"><a href="#74-说说webpack的构建流程" class="headerlink" title="74.说说webpack的构建流程"></a>74.说说webpack的构建流程</h1><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2f6f2ca5dcff4bdcb1e0397661d9e583~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="在这里插入图片描述"></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.初始化参数：解析webpack配置参数，合并shell传入和webpack.config.js文件配置的参数，形成最后的配置结果。</span><br><span class="line">2.开始编译：上一步得到的参数初始化compiler对象，注册所有配置的插件，插件监听webpack构建生命周期的事件节点，做出相应的反应，执行对象的 run 方法开始执行编译。</span><br><span class="line">3.确定入口：从配置的entry入口，开始解析文件构建AST语法树，找出依赖，递归下去。</span><br><span class="line">4.编译模块：递归中根据文件类型和loader配置，调用所有配置的loader对文件进行转换，再找出该模块依赖的模块，再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理。</span><br><span class="line">5.完成模块编译：在经过第4步使⽤ Loader 翻译完所有模块后，得到了每个模块被翻译后的最终内容以及它们之间的依赖关系；</span><br><span class="line">6.输出资源：根据⼊⼝和模块之间的依赖关系，组装成⼀个个包含多个模块的 Chunk，再把每个 Chunk 转换成⼀个单独的⽂件加⼊到输出列表，这步是可以修改输出内容的最后机会；</span><br><span class="line">7.输出完成：在确定好输出内容后，根据配置确定输出的路径和⽂件名，把⽂件内容写⼊到⽂件系统。</span><br></pre></td></tr></table></figure><h1 id="75-说说Loader和Plugin的区别？编写Loader，Plugin的思路"><a href="#75-说说Loader和Plugin的区别？编写Loader，Plugin的思路" class="headerlink" title="75.说说Loader和Plugin的区别？编写Loader，Plugin的思路"></a>75.说说Loader和Plugin的区别？编写Loader，Plugin的思路</h1><h2 id="一、区别"><a href="#一、区别" class="headerlink" title="一、区别"></a>一、区别</h2><ul><li>loader 是文件加载器，能够加载资源文件，并对这些文件进行一些处理，诸如编译、压缩等，最终一起打包到指定的文件中</li><li>plugin 赋予了 webpack 各种灵活的功能，例如打包优化、资源管理、环境变量注入等，目的是解决 loader 无法实现的其他事</li></ul><p>从整个运行时机上来看，如下图所示：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/82612d86c7ae4aeaafc68a3487df9f93~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="img"></p><p>可以看到，两者在运行时机上的区别：</p><ul><li>loader 运行在打包文件之前</li><li>plugins 在整个编译周期都起作用</li></ul><p>在<code>Webpack</code> 运行的生命周期中会广播出许多事件，<code>Plugin</code> 可以监听这些事件，在合适的时机通过<code>Webpack</code>提供的 <code>API</code>改变输出结果</p><p>对于<code>loader</code>，实质是一个转换器，将A文件进行编译形成B文件，操作的是文件，比如将<code>A.scss</code>或<code>A.less</code>转变为<code>B.css</code>，单纯的文件转换过程</p><h2 id="二、编写loader"><a href="#二、编写loader" class="headerlink" title="二、编写loader"></a>二、编写loader</h2><p>在编写 <code>loader</code> 前，我们首先需要了解 <code>loader</code> 的本质</p><p>其本质为函数，函数中的 <code>this</code> 作为上下文会被 <code>webpack</code> 填充，因此我们不能将 <code>loader</code>设为一个箭头函数</p><p>函数接受一个参数，为 <code>webpack</code> 传递给 <code>loader</code> 的文件源内容</p><p>函数中 <code>this</code> 是由 <code>webpack</code> 提供的对象，能够获取当前 <code>loader</code> 所需要的各种信息</p><p>函数中有异步操作或同步操作，异步操作通过 <code>this.callback</code> 返回，返回值要求为 <code>string</code> 或者 <code>Buffer</code></p><p>代码如下所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导出一个函数，source为webpack传递给loader的文件源内容</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="keyword">function</span>(<span class="params">source</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> content = <span class="title function_">doSomeThing2JsString</span>(source);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果 loader 配置了 options 对象，那么this.query将指向 options</span></span><br><span class="line">    <span class="keyword">const</span> options = <span class="variable language_">this</span>.<span class="property">query</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 可以用作解析其他模块路径的上下文</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;this.context&#x27;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * this.callback 参数：</span></span><br><span class="line"><span class="comment">     * error：Error | null，当 loader 出错时向外抛出一个 error</span></span><br><span class="line"><span class="comment">     * content：String | Buffer，经过 loader 编译后需要导出的内容</span></span><br><span class="line"><span class="comment">     * sourceMap：为方便调试生成的编译后内容的 source map</span></span><br><span class="line"><span class="comment">     * ast：本次编译生成的 AST 静态语法树，之后执行的 loader 可以直接使用这个 AST，进而省去重复生成 AST 的过程</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">callback</span>(<span class="literal">null</span>, content); <span class="comment">// 异步</span></span><br><span class="line">    <span class="keyword">return</span> content; <span class="comment">// 同步</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>一般在编写<code>loader</code>的过程中，保持功能单一，避免做多种功能</p><p>如<code>less</code>文件转换成 <code>css</code>文件也不是一步到位，而是 <code>less-loader</code>、<code>css-loader</code>、<code>style-loader</code>几个 <code>loader</code>的链式调用才能完成转换</p><h2 id="三、编写plugin"><a href="#三、编写plugin" class="headerlink" title="三、编写plugin"></a>三、编写plugin</h2><p>由于<code>webpack</code>基于发布订阅模式，在运行的生命周期中会广播出许多事件，插件通过监听这些事件，就可以在特定的阶段执行自己的插件任务</p><p>在之前也了解过，<code>webpack</code>编译会创建两个核心对象：</p><ul><li>compiler：包含了 webpack 环境的所有的配置信息，包括 options，loader 和 plugin，和 webpack 整个生命周期相关的钩子</li><li>compilation：作为 plugin 内置事件回调函数的参数，包含了当前的模块资源、编译生成资源、变化的文件以及被跟踪依赖的状态信息。当检测到一个文件变化，一次新的 Compilation 将被创建</li></ul><p>如果自己要实现<code>plugin</code>，也需要遵循一定的规范：</p><ul><li>插件必须是一个函数或者是一个包含 <code>apply</code> 方法的对象，这样才能访问<code>compiler</code>实例</li><li>传给每个插件的 <code>compiler</code> 和 <code>compilation</code> 对象都是同一个引用，因此不建议修改</li><li>异步的事件需要在插件处理完任务时调用回调函数通知 <code>Webpack</code> 进入下一个流程，不然会卡住</li></ul><p>实现<code>plugin</code>的模板如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyPlugin</span> &#123;</span><br><span class="line">    <span class="comment">// Webpack 会调用 MyPlugin 实例的 apply 方法给插件实例传入 compiler 对象</span></span><br><span class="line">  apply (compiler) &#123;</span><br><span class="line">    <span class="comment">// 找到合适的事件钩子，实现自己的插件功能</span></span><br><span class="line">    compiler.<span class="property">hooks</span>.<span class="property">emit</span>.<span class="title function_">tap</span>(<span class="string">&#x27;MyPlugin&#x27;</span>, <span class="function"><span class="params">compilation</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// compilation: 当前打包构建流程的上下文</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(compilation);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// do something...</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>在 <code>emit</code> 事件发生时，代表源文件的转换和组装已经完成，可以读取到最终将输出的资源、代码块、模块及其依赖，并且可以修改输出资源的内容</p><h1 id="76-提高webpack的构建速度"><a href="#76-提高webpack的构建速度" class="headerlink" title="76.提高webpack的构建速度"></a>76.提高webpack的构建速度</h1><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">优化 loader 配置</span><br><span class="line">合理使用 resolve.extensions</span><br><span class="line">优化 resolve.modules</span><br><span class="line">优化 resolve.<span class="keyword">alias</span></span><br><span class="line">使用 DLLPlugin 插件</span><br><span class="line">使用 cache-loader</span><br><span class="line">terser 启动多线程</span><br><span class="line">合理使用 sourceMap</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h1 id="77-webpack-热更新是怎么做到的"><a href="#77-webpack-热更新是怎么做到的" class="headerlink" title="77.webpack 热更新是怎么做到的"></a>77.webpack 热更新是怎么做到的</h1><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">通过webpack-dev-server创建两个服务器：提供静态资源的服务（express）和Socket服务</span><br><span class="line">express server 负责直接提供静态资源的服务（打包后的资源直接被浏览器请求和解析）</span><br><span class="line">socket server 是一个 websocket 的长连接，双方可以通信</span><br><span class="line">当 socket server 监听到对应的模块发生变化时，会生成两个文件<span class="selector-class">.json</span>（manifest文件）和<span class="selector-class">.js</span>文件（update chunk）</span><br><span class="line">通过长连接，socket server 可以直接将这两个文件主动发送给客户端（浏览器）</span><br><span class="line">浏览器拿到两个新的文件后，通过HMR runtime机制，加载这两个文件，并且针对修改的模块进行更新</span><br></pre></td></tr></table></figure><h1 id="78-webpack中常见的Loader"><a href="#78-webpack中常见的Loader" class="headerlink" title="78.webpack中常见的Loader"></a>78.webpack中常见的Loader</h1><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">style-loader: 将css添加到DOM的内联样式标签style里</span></span><br><span class="line">css-loader :允许将css文件通过require的方式引入，并返回css代码</span><br><span class="line"><span class="section">less-loader: 处理less</span></span><br><span class="line"><span class="section">sass-loader: 处理sass</span></span><br><span class="line"><span class="section">postcss-loader: 用postcss来处理CSS</span></span><br><span class="line"><span class="section">autoprefixer-loader: 处理CSS3属性前缀，已被弃用，建议直接使用postcss</span></span><br><span class="line"><span class="section">file-loader: 分发文件到output目录并返回相对路径</span></span><br><span class="line"><span class="section">url-loader: 和file-loader类似，但是当文件小于设定的limit时可以返回一个Data Url</span></span><br><span class="line"><span class="section">html-minify-loader: 压缩HTML</span></span><br><span class="line">babel-loader :用babel来转换ES6文件到ES</span><br></pre></td></tr></table></figure><h1 id="79-webpack中常见的Plugin"><a href="#79-webpack中常见的Plugin" class="headerlink" title="79.webpack中常见的Plugin"></a>79.webpack中常见的Plugin</h1><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/42a9982ea5ee422d8a6877b2a36a83f1~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="img"></p><h1 id="80-Git常用的命令有哪些"><a href="#80-Git常用的命令有哪些" class="headerlink" title="80.Git常用的命令有哪些"></a>80.Git常用的命令有哪些</h1><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line">**基本操作**</span><br><span class="line">  </span><br><span class="line">git init 初始化仓库，默认为 master 分支</span><br><span class="line"></span><br><span class="line">git add . 提交全部文件修改到缓存区</span><br><span class="line"></span><br><span class="line">git add &lt;具体某个文件路径+全名&gt; 提交某些文件到缓存区</span><br><span class="line"></span><br><span class="line">git diff 查看当前代码 add后，会 add 哪些内容</span><br><span class="line"></span><br><span class="line">git diff --staged查看现在 commit 提交后，会提交哪些内容</span><br><span class="line"></span><br><span class="line">git status 查看当前分支状态</span><br><span class="line"></span><br><span class="line">git pull &lt;远程仓库名&gt; &lt;远程分支名&gt; 拉取远程仓库的分支与本地当前分支合并</span><br><span class="line"></span><br><span class="line">git pull &lt;远程仓库名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt; 拉取远程仓库的分支与本地某个分支合并</span><br><span class="line"></span><br><span class="line">git commit -m <span class="string">&quot;&lt;注释&gt;&quot;</span> 提交代码到本地仓库，并写提交注释</span><br><span class="line"></span><br><span class="line">git commit -v 提交时显示所有diff信息</span><br><span class="line"></span><br><span class="line">git commit --amend [file1] [file2] 重做上一次commit，并包括指定文件的新变化</span><br><span class="line"></span><br><span class="line">**提交规则**</span><br><span class="line"></span><br><span class="line"><span class="section">feat: 新特性，添加功能</span></span><br><span class="line"></span><br><span class="line"><span class="section">fix: 修改 bug</span></span><br><span class="line"></span><br><span class="line"><span class="section">refactor: 代码重构</span></span><br><span class="line"></span><br><span class="line"><span class="section">docs: 文档修改</span></span><br><span class="line"></span><br><span class="line"><span class="section">style: 代码格式修改, 注意不是 css 修改</span></span><br><span class="line"></span><br><span class="line"><span class="section">test: 测试用例修改</span></span><br><span class="line"></span><br><span class="line"><span class="section">chore: 其他修改, 比如构建流程, 依赖管理</span></span><br><span class="line"></span><br><span class="line">**分支操作**</span><br><span class="line">  </span><br><span class="line">git branch 查看本地所有分支</span><br><span class="line"></span><br><span class="line">git branch -r 查看远程所有分支</span><br><span class="line"></span><br><span class="line">git branch -a 查看本地和远程所有分支</span><br><span class="line"></span><br><span class="line">git merge &lt;分支名&gt; 合并分支</span><br><span class="line"></span><br><span class="line">git merge --abort 合并分支出现冲突时，取消合并，一切回到合并前的状态</span><br><span class="line"></span><br><span class="line">git branch &lt;新分支名&gt; 基于当前分支，新建一个分支</span><br><span class="line"></span><br><span class="line">git checkout --orphan &lt;新分支名&gt; 新建一个空分支（会保留之前分支的所有文件）</span><br><span class="line"></span><br><span class="line">git branch -D &lt;分支名&gt; 删除本地某个分支</span><br><span class="line"></span><br><span class="line">git push &lt;远程库名&gt; :&lt;分支名&gt; 删除远程某个分支</span><br><span class="line"></span><br><span class="line">git branch &lt;新分支名称&gt; &lt;提交ID&gt; 从提交历史恢复某个删掉的某个分支</span><br><span class="line"></span><br><span class="line">git branch -m &lt;原分支名&gt; &lt;新分支名&gt; 分支更名</span><br><span class="line"></span><br><span class="line">git checkout &lt;分支名&gt; 切换到本地某个分支</span><br><span class="line"></span><br><span class="line">git checkout &lt;远程库名&gt;/&lt;分支名&gt; 切换到线上某个分支</span><br><span class="line"></span><br><span class="line">git checkout -b &lt;新分支名&gt; 把基于当前分支新建分支，并切换为这个分支</span><br><span class="line"></span><br><span class="line">**远程操作**</span><br><span class="line"></span><br><span class="line">git fetch [remote] 下载远程仓库的所有变动</span><br><span class="line"></span><br><span class="line">git remote -v 显示所有远程仓库</span><br><span class="line"></span><br><span class="line">git pull [remote] [branch] 拉取远程仓库的分支与本地当前分支合并</span><br><span class="line"></span><br><span class="line">git fetch 获取线上最新版信息记录，不合并</span><br><span class="line"></span><br><span class="line">git push [remote] [branch] 上传本地指定分支到远程仓库</span><br><span class="line"></span><br><span class="line">git push [remote] --force 强行推送当前分支到远程仓库，即使有冲突</span><br><span class="line"></span><br><span class="line">git push [remote] --all 推送所有分支到远程仓库</span><br><span class="line"></span><br><span class="line">**撤销操作**</span><br><span class="line"></span><br><span class="line">git checkout [file] 恢复暂存区的指定文件到工作区</span><br><span class="line"></span><br><span class="line">git checkout [commit] [file] 恢复某个commit的指定文件到暂存区和工作区</span><br><span class="line"></span><br><span class="line">git checkout . 恢复暂存区的所有文件到工作区</span><br><span class="line"></span><br><span class="line">git reset [commit] 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变</span><br><span class="line"></span><br><span class="line">git reset --hard 重置暂存区与工作区，与上一次commit保持一致</span><br><span class="line"></span><br><span class="line">git reset [file] 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变</span><br><span class="line"></span><br><span class="line">git revert [commit] 后者的所有变化都将被前者抵消，并且应用到当前分支</span><br><span class="line"></span><br><span class="line">reset：真实硬性回滚，目标版本后面的提交记录全部丢失了</span><br><span class="line"></span><br><span class="line">revert：同样回滚，这个回滚操作相当于一个提价，目标版本后面的提交记录也全部都有</span><br><span class="line"></span><br><span class="line">**存储操作**</span><br><span class="line"></span><br><span class="line">git stash 暂时将未提交的变化移除</span><br><span class="line"></span><br><span class="line">git stash pop 取出储藏中最后存入的工作状态进行恢复，会删除储藏</span><br><span class="line"></span><br><span class="line">git stash list 查看所有储藏中的工作</span><br><span class="line"></span><br><span class="line">git stash apply &lt;储藏的名称&gt; 取出储藏中对应的工作状态进行恢复，不会删除储藏</span><br><span class="line"></span><br><span class="line">git stash clear 清空所有储藏中的工作</span><br><span class="line"></span><br><span class="line">git stash drop &lt;储藏的名称&gt; 删除对应的某个储藏</span><br></pre></td></tr></table></figure><h1 id="81-标准的CSS盒子模型及其和低版本的IE盒子模型的区别？"><a href="#81-标准的CSS盒子模型及其和低版本的IE盒子模型的区别？" class="headerlink" title="81.标准的CSS盒子模型及其和低版本的IE盒子模型的区别？"></a>81.标准的CSS盒子模型及其和低版本的IE盒子模型的区别？</h1><p>标准（W3C）盒子模型：<code>width</code> = 内容宽度<code>（content） + border + padding + margin</code></p><p>低版本IE盒子模型： <code>width</code> = 内容宽度<code>（content + border + padding）+ margin</code></p><p>图片展示:</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e67a7e62bf014408ad1c20e3951c179a~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="img"></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9599a855d62546d993f481f44caa252c~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="img"></p><p>区别： 标准盒子模型盒子的<code>height</code>和<code>width</code>是<code>content</code>（内容）的宽高，而IE盒子模型盒子的宽高则包括<code>content+padding+border</code>部分。</p><h1 id="82-几种解决IE6存在的bug的方法"><a href="#82-几种解决IE6存在的bug的方法" class="headerlink" title="82.几种解决IE6存在的bug的方法"></a>82.几种解决IE6存在的bug的方法</h1><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> 由<span class="code">`float`</span>引起的双边距的问题，使用<span class="code">`display`</span>解决；</span><br><span class="line"><span class="bullet">-</span> 由<span class="code">`float`</span>引起的3像素问题，使用<span class="code">`display: inline -3px`</span>;</span><br><span class="line"><span class="bullet">-</span> 使用正确的书写顺序<span class="code">`link visited hover active`</span>，解决超链接<span class="code">`hover`</span>点击失效问题；</span><br><span class="line"><span class="bullet">-</span> 对于<span class="code">`IE`</span> 的<span class="code">`z-index`</span>问题，通过给父元素增加<span class="code">`position: relative`</span>解决；</span><br><span class="line"><span class="bullet">-</span> 使用<span class="code">`!important`</span>解决<span class="code">`Min-height`</span>最小高度问题；</span><br><span class="line"><span class="bullet">-</span> 使用<span class="code">`iframe`</span>解决<span class="code">`select`</span>在<span class="code">`IE6`</span>下的覆盖问题；</span><br><span class="line"><span class="bullet">-</span> 使用<span class="code">`over: hidden`</span>, <span class="code">`zoom: 0.08`</span>, <span class="code">`line-height: 1px`</span>解决定义1px左右的容器宽度问题；</span><br></pre></td></tr></table></figure><h1 id="83-CSS选择符有哪些？哪些属性可以继承？"><a href="#83-CSS选择符有哪些？哪些属性可以继承？" class="headerlink" title="83.CSS选择符有哪些？哪些属性可以继承？"></a>83.CSS选择符有哪些？哪些属性可以继承？</h1><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">常见的选择符有一下：</span><br><span class="line"></span><br><span class="line">`id`选择器（`<span class="selector-id">#content</span>`），类选择器（`<span class="selector-class">.content</span>`）, 标签选择器（`<span class="selector-tag">div</span>`, `<span class="selector-tag">p</span>`, `<span class="selector-tag">span</span>`等）, 相邻选择器（`<span class="selector-tag">h1</span>+<span class="selector-tag">p</span>`）, 子选择器（`<span class="selector-tag">ul</span>&gt;<span class="selector-tag">li</span>`）, 后代选择器（`<span class="selector-tag">li</span> <span class="selector-tag">a</span>`）， 通配符选择器（`*`）, 属性选择器（`<span class="selector-tag">a</span><span class="selector-attr">[rel = <span class="string">&quot;external&quot;</span>]</span>`）， 伪类选择器（`<span class="selector-tag">a</span><span class="selector-pseudo">:hover</span>`, `<span class="selector-tag">li</span><span class="selector-pseudo">:nth-child</span>`）</span><br><span class="line"></span><br><span class="line">可继承的样式属性： `<span class="attribute">font-size</span>`, `<span class="attribute">font-family</span>`, `<span class="attribute">color</span>`, `<span class="selector-tag">ul</span>`, `<span class="selector-tag">li</span>`, `<span class="selector-tag">dl</span>`, `<span class="selector-tag">dd</span>`, `<span class="selector-tag">dt</span>`;</span><br><span class="line"></span><br><span class="line">不可继承的样式属性： `<span class="attribute">border</span>`, `<span class="attribute">padding</span>`, `<span class="attribute">margin</span>`, `<span class="attribute">width</span>`, `<span class="attribute">height</span>`；</span><br></pre></td></tr></table></figure><h1 id="84-position的值relative和absolute定位原点？"><a href="#84-position的值relative和absolute定位原点？" class="headerlink" title="84.position的值relative和absolute定位原点？"></a>84.position的值relative和absolute定位原点？</h1><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">首先，使用<span class="code">`position`</span>的时候，应该记住一个规律是‘<span class="strong">**子绝父相**</span>’。</span><br><span class="line"></span><br><span class="line"><span class="code">`relative`</span>（相对定位）： 生成相对定位的元素，定位原点是元素本身所在的位置；</span><br><span class="line"></span><br><span class="line"><span class="code">`absolute`</span>（绝对定位）：生成绝对定位的元素，定位原点是离自己这一级元素最近的一级<span class="code">`position`</span>设置为<span class="code">`absolute`</span>或者<span class="code">`relative`</span>的父元素的左上角为原点的。</span><br><span class="line"></span><br><span class="line"><span class="code">`fixed`</span> （老IE不支持）：生成绝对定位的元素，相对于浏览器窗口进行定位。</span><br><span class="line"></span><br><span class="line"><span class="code">`static`</span>：默认值。没有定位，元素出现在正常的流中（忽略 <span class="code">`top`</span>, <span class="code">`bottom`</span>, <span class="code">`left`</span>, <span class="code">`right`</span>、<span class="code">`z-index`</span> 声明）。</span><br><span class="line"></span><br><span class="line"><span class="code">`inherit`</span>：规定从父元素继承 <span class="code">`position`</span> 属性的值。</span><br><span class="line"></span><br><span class="line"><span class="strong">**更新一个属性**</span></span><br><span class="line"></span><br><span class="line"><span class="code">`sticky`</span>: (新增元素，目前兼容性可能不是那么的好)，可以设置 position:sticky 同时给一个 (top,bottom,right,left) 之一即可。</span><br><span class="line"></span><br><span class="line"><span class="strong">**注意**</span>：</span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> 使用<span class="code">`sticky`</span>时，必须指定top、bottom、left、right4个值之一，不然只会处于相对定位；</span><br><span class="line"><span class="bullet">-</span> <span class="code">`sticky`</span>只在其父元素内其效果，且保证父元素的高度要高于<span class="code">`sticky`</span>的高度；</span><br><span class="line"><span class="bullet">-</span> 父元素不能<span class="code">`overflow:hidden`</span>或者<span class="code">`overflow:auto`</span>等属性。</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h1 id="85-CSS3有哪些新特性？"><a href="#85-CSS3有哪些新特性？" class="headerlink" title="85.CSS3有哪些新特性？"></a>85.CSS3有哪些新特性？</h1><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">关于<span class="code">`CSS`</span>新增的特性，有以下：</span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> 选择器;</span><br><span class="line"><span class="bullet">-</span> 圆角<span class="code">`（border-raduis）`</span>;</span><br><span class="line"><span class="bullet">-</span> 多列布局<span class="code">`（multi-column layout）`</span>;</span><br><span class="line"><span class="bullet">-</span> 阴影<span class="code">`（shadow）`</span>和反射<span class="code">`（reflect）`</span>;</span><br><span class="line"><span class="bullet">-</span> 文字特效<span class="code">`（text-shadow）`</span>;</span><br><span class="line"><span class="bullet">-</span> 文字渲染<span class="code">`（text-decoration`</span>）;</span><br><span class="line"><span class="bullet">-</span> 线性渐变<span class="code">`（gradient）`</span>;</span><br><span class="line"><span class="bullet">-</span> 旋转<span class="code">`（rotate`</span>）/缩放<span class="code">`（scale）`</span>/倾斜<span class="code">`（skew）`</span>/移动<span class="code">`（translate）`</span>;</span><br><span class="line"><span class="bullet">-</span> 媒体查询<span class="code">`（@media）`</span>;</span><br><span class="line"><span class="bullet">-</span> <span class="code">`RGBA`</span>和透明度 ;</span><br><span class="line"><span class="bullet">-</span> <span class="code">`@font-face`</span>属性;</span><br><span class="line"><span class="bullet">-</span> 多背景图 ;</span><br><span class="line"><span class="bullet">-</span> 盒子大小;</span><br><span class="line"><span class="bullet">-</span> 语音;</span><br></pre></td></tr></table></figure><h1 id="86-用纯CSS创建一个三角形的原理是什么？"><a href="#86-用纯CSS创建一个三角形的原理是什么？" class="headerlink" title="86.用纯CSS创建一个三角形的原理是什么？"></a>86.用纯CSS创建一个三角形的原理是什么？</h1><p>实现步骤： 1.首先保证元素是块级元素；2.设置元素的边框；3.不需要显示的边框使用透明色。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">css: </span><br><span class="line">    * &#123;<span class="attribute">margin</span>: <span class="number">0</span>; <span class="attribute">padding</span>: <span class="number">0</span>;&#125;</span><br><span class="line">    <span class="selector-class">.content</span> &#123;</span><br><span class="line">        <span class="attribute">width</span>:<span class="number">0</span>;</span><br><span class="line">        <span class="attribute">height</span>:<span class="number">0</span>;</span><br><span class="line">        <span class="attribute">margin</span>:<span class="number">0</span> auto;</span><br><span class="line">        <span class="attribute">border</span>:<span class="number">50px</span> solid transparent;</span><br><span class="line">        <span class="attribute">border-top</span>: <span class="number">50px</span> solid pink;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">html</span>: </span><br><span class="line">    &lt;div class=<span class="string">&quot;content&quot;</span>&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure><h1 id="87-什么是响应式设计？响应式设计的基本原理是什么？如何兼容低版本的IE？"><a href="#87-什么是响应式设计？响应式设计的基本原理是什么？如何兼容低版本的IE？" class="headerlink" title="87.什么是响应式设计？响应式设计的基本原理是什么？如何兼容低版本的IE？"></a>87.什么是响应式设计？响应式设计的基本原理是什么？如何兼容低版本的IE？</h1><p>响应式网站设计<code>（Responsive Web design</code>）是一个网站能够兼容多个终端，而不是为每一个终端做一个特定的版本。</p><p>关于原理： 基本原理是通过媒体查询<code>（@media）</code>查询检测不同的设备屏幕尺寸做处理。</p><p>关于兼容： 页面头部必须有mate声明的<code>viewport</code>。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta <span class="attr">name</span>=<span class="string">&quot;’viewport’&quot;</span> content=<span class="string">&quot;”width=device-width,&quot;</span> initial-scale=<span class="string">&quot;1.&quot;</span> maximum-scale=<span class="string">&quot;1,user-scalable=no”&quot;</span>/&gt; </span><br></pre></td></tr></table></figure><h1 id="88-CSS优化、提高性能的方法有哪些？"><a href="#88-CSS优化、提高性能的方法有哪些？" class="headerlink" title="88.CSS优化、提高性能的方法有哪些？"></a>88.CSS优化、提高性能的方法有哪些？</h1><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> 多个<span class="code">`css`</span>可合并，并尽量减少<span class="code">`http`</span>请求</span><br><span class="line"><span class="bullet">-</span> 属性值为0时，不加单位</span><br><span class="line"><span class="bullet">-</span> 将<span class="code">`css`</span>文件放在页面最上面</span><br><span class="line"><span class="bullet">-</span> 避免后代选择符，过度约束和链式选择符</span><br><span class="line"><span class="bullet">-</span> 使用紧凑的语法</span><br><span class="line"><span class="bullet">-</span> 避免不必要的重复</span><br><span class="line"><span class="bullet">-</span> 使用语义化命名，便于维护</span><br><span class="line"><span class="bullet">-</span> 尽量少的使用<span class="code">`!impotrant`</span>，可以选择其他选择器</span><br><span class="line"><span class="bullet">-</span> 精简规则，尽可能合并不同类的重复规则</span><br><span class="line"><span class="bullet">-</span> 遵守盒子模型规则</span><br></pre></td></tr></table></figure><h1 id="89-display-inline-block-什么时候会显示间隙？"><a href="#89-display-inline-block-什么时候会显示间隙？" class="headerlink" title="89.display:inline-block 什么时候会显示间隙？"></a>89.display:inline-block 什么时候会显示间隙？</h1><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> 有空格时候会有间隙， 可以删除空格解决；</span><br><span class="line"><span class="bullet">-</span> <span class="code">`margin`</span>正值的时候， 可以让<span class="code">`margin`</span>使用负值解决；</span><br><span class="line"><span class="bullet">-</span> 使用<span class="code">`font-size`</span>时候，可通过设置<span class="code">`font-size:0`</span>、<span class="code">`letter-spacing`</span>、<span class="code">`word-spacing`</span>解决； </span><br></pre></td></tr></table></figure><h1 id="90-什么是外边距重叠？-重叠的结果是什么？"><a href="#90-什么是外边距重叠？-重叠的结果是什么？" class="headerlink" title="90. 什么是外边距重叠？ 重叠的结果是什么？"></a>90. 什么是外边距重叠？ 重叠的结果是什么？</h1><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">首先，外边距重叠就是 <span class="code">`margin-collapse`</span>。相邻的两个盒子（可能是兄弟关系也可能是祖先关系）的外边距可以结合成一个单独的外边距。 这种合并外边距的方式被称为折叠，结合而成的外边距称为折叠外边距。</span><br><span class="line"></span><br><span class="line">折叠结果遵循下列计算原则：</span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> 两个相邻的外面边距是正数时，折叠结果就是他们之中的较大值；</span><br><span class="line"><span class="bullet">-</span> 两个相邻的外边距都是负数时，折叠结果是两者绝对值的较大值；</span><br><span class="line"><span class="bullet">-</span> 两个外边距一正一负时，折叠结果是两者的相加的和；</span><br></pre></td></tr></table></figure><h1 id="91-有哪几种隐藏元素的方法？"><a href="#91-有哪几种隐藏元素的方法？" class="headerlink" title="91.有哪几种隐藏元素的方法？"></a>91.有哪几种隐藏元素的方法？</h1><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="code">`visibility: hidden;`</span> 这个属性只是简单的隐藏某个元素，但是元素占用的空间任然存在；</span><br><span class="line"><span class="bullet">-</span> <span class="code">`opacity: 0;`</span><span class="code">`CSS3`</span>属性，设置0可以使一个元素完全透明；</span><br><span class="line"><span class="bullet">-</span> <span class="code">`position: absolute;`</span> 设置一个很大的 left 负值定位，使元素定位在可见区域之外；</span><br><span class="line"><span class="bullet">-</span> <span class="code">`display: none;`</span> 元素会变得不可见，并且不会再占用文档的空间；</span><br><span class="line"><span class="bullet">-</span> <span class="code">`transform: scale(0);`</span> 将一个元素设置为缩放无限小，元素将不可见，元素原来所在的位置将被保留；</span><br><span class="line"><span class="bullet">-</span> <span class="code">`&lt;div hidden=&quot;hidden&quot;&gt;`</span> <span class="code">`HTML5`</span>属性,效果和<span class="code">`display:none;`</span>相同，但这个属性用于记录一个元素的状态；</span><br><span class="line"><span class="bullet">-</span> <span class="code">`height: 0;`</span> 将元素高度设为 0 ，并消除边框；</span><br><span class="line"><span class="bullet">-</span> <span class="code">`filter: blur(0);`</span> <span class="code">`CSS3`</span>属性，括号内的数值越大，图像高斯模糊的程度越大，到达一定程度可使图像消失`；</span><br></pre></td></tr></table></figure><h1 id="92-对BFC规范-块级格式化上下文：block-formatting-context-的理解"><a href="#92-对BFC规范-块级格式化上下文：block-formatting-context-的理解" class="headerlink" title="92.对BFC规范(块级格式化上下文：block formatting context)的理解"></a>92.对BFC规范(块级格式化上下文：block formatting context)的理解</h1><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="code">`BFC`</span>规定了内部的<span class="code">`Block Box`</span>如何布局。一个页面是由很多个<span class="code">`Box`</span>组成的，元素的类型和<span class="code">`display`</span>属性，决定了这个<span class="code">`Box`</span>的类型。不同类型的<span class="code">`box`</span>，会参与不同的<span class="code">`Formatting Context`</span>（决定如何渲染文档的容器），因此<span class="code">`Box`</span>内的元素会以不用的方式渲染，也是就是说<span class="code">`BFC`</span>内部的元素和外部的元素不会相互影响。</span><br><span class="line"></span><br><span class="line">定位方案：</span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> 内部的<span class="code">`box`</span>会在垂直方向上一个接一个的放置；</span><br><span class="line"><span class="bullet">-</span> <span class="code">`box`</span>垂直方向的距离由<span class="code">`margin`</span>决定，属于同一个<span class="code">`BFC`</span>的两个相邻<span class="code">`Box`</span>的<span class="code">`margin`</span>会发生重叠；</span><br><span class="line"><span class="bullet">-</span> 每个元素<span class="code">`margin box`</span>的左边，与包含块<span class="code">`border box`</span>的左边相接触；</span><br><span class="line"><span class="bullet">-</span> <span class="code">`BFC`</span>的区域不会与float box重叠；</span><br><span class="line"><span class="bullet">-</span> <span class="code">`BFC`</span>是页面上的一个隔离的独立容器，容器里面的元素不会影响到外面的元素；</span><br><span class="line"><span class="bullet">-</span> 计算<span class="code">`BFC`</span>的高度时，浮动元素也会参与计算。</span><br><span class="line"></span><br><span class="line">满足下列条件之一就可以出发BFC：</span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> 根元素变化，即<span class="code">`html`</span>；</span><br><span class="line"><span class="bullet">-</span> <span class="code">`float`</span>的值不为<span class="code">`none`</span>（默认）；</span><br><span class="line"><span class="bullet">-</span> <span class="code">`overflow`</span>的值不为<span class="code">`visible`</span>（默认）；</span><br><span class="line"><span class="bullet">-</span> <span class="code">`display`</span>的值为<span class="code">`inline-block`</span>, <span class="code">`tabke-cell`</span>，<span class="code">`table-caption`</span>；</span><br><span class="line"><span class="bullet">-</span> <span class="code">`position`</span>的值为<span class="code">`absolute`</span>或<span class="code">`fixed`</span>;</span><br></pre></td></tr></table></figure><h1 id="93-经常遇到的浏览器的兼容性有哪些？原因，解决方法是什么，常用hack的技巧-？"><a href="#93-经常遇到的浏览器的兼容性有哪些？原因，解决方法是什么，常用hack的技巧-？" class="headerlink" title="93.经常遇到的浏览器的兼容性有哪些？原因，解决方法是什么，常用hack的技巧 ？"></a>93.经常遇到的浏览器的兼容性有哪些？原因，解决方法是什么，常用hack的技巧 ？</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">（<span class="number">1</span>）、问题：<span class="string">`png24`</span>位的图片在<span class="string">`ie`</span>浏览器上出现背景。解决： 做成<span class="string">`png8`</span>；</span><br><span class="line"></span><br><span class="line">（<span class="number">2</span>）、问题：浏览器默认的<span class="string">`margin`</span>和<span class="string">`padding`</span>不同。 解决： 添加一个全局的<span class="string">`*&#123; margin： 0; padding： 0;&#125;`</span>；</span><br><span class="line"></span><br><span class="line">（<span class="number">3</span>）、问题：<span class="string">`IE`</span>下,可以使用获取常规属性的方法来获取自定义属性,也可以使用<span class="string">`getAttribute()`</span>获取自定义属性，而<span class="string">`Firefox`</span>下,只能使用<span class="string">`getAttribute()`</span>获取自定义属性。 解决： 统一通过<span class="string">`getAttribute()`</span>获取自定义属性；</span><br><span class="line"></span><br><span class="line">（<span class="number">4</span>）、问题： <span class="string">`IE`</span>下,<span class="string">`event`</span>对象有<span class="string">`x`</span>,<span class="string">`y`</span>属性,但是没有<span class="string">`pageX`</span>,<span class="string">`pageY`</span>属性，而<span class="string">`Firefox`</span>下,<span class="string">`event`</span>对象有<span class="string">`pageX`</span>,<span class="string">`pageY`</span>属性,但是没有<span class="string">`x`</span>,<span class="string">`y`</span>属性。 解决： 使用<span class="string">`mX(mX = event.x ? event.x : event.pageX;)`</span>来代替<span class="string">`IE`</span>下的<span class="string">`event.x`</span>或者<span class="string">`Firefox`</span>下的<span class="string">`event.pageX`</span>。</span><br></pre></td></tr></table></figure><h1 id="94-怎么让Chrome支持小于12px-的文字？"><a href="#94-怎么让Chrome支持小于12px-的文字？" class="headerlink" title="94. 怎么让Chrome支持小于12px 的文字？"></a>94. 怎么让Chrome支持小于12px 的文字？</h1><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.shrink</span> &#123;</span><br><span class="line">    -webkit-<span class="attribute">transform</span>: <span class="built_in">scale</span>(<span class="number">0.8</span>);</span><br><span class="line">    -o-<span class="attribute">transform</span>: <span class="built_in">scale</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="attribute">display</span>: inilne-block;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="95-link、-visited、-hover、-active的执行顺序是怎么样的？"><a href="#95-link、-visited、-hover、-active的执行顺序是怎么样的？" class="headerlink" title="95. :link、:visited、:hover、:active的执行顺序是怎么样的？"></a>95. :link、:visited、:hover、:active的执行顺序是怎么样的？</h1><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`L-V-H-<span class="selector-tag">A</span>`，`<span class="built_in">l</span>(link)<span class="built_in">ov</span>(visited)e <span class="built_in">h</span>(hover)<span class="selector-tag">a</span>(active)te`，即用喜欢和讨厌两个词来概括</span><br></pre></td></tr></table></figure><h1 id="96-CSS属性overflow属性定义溢出元素内容区的内容会如何处理"><a href="#96-CSS属性overflow属性定义溢出元素内容区的内容会如何处理" class="headerlink" title="96. CSS属性overflow属性定义溢出元素内容区的内容会如何处理?"></a>96. CSS属性overflow属性定义溢出元素内容区的内容会如何处理?</h1><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> 参数是<span class="code">`scroll`</span>的时候，一定会出滚动条；</span><br><span class="line"><span class="bullet">-</span> 参数是<span class="code">`auto`</span>的时候，子元素内容大于父元素时出现滚动条；</span><br><span class="line"><span class="bullet">-</span> 参数是<span class="code">`visible`</span>的时候，溢出的内容出现在父元素之外；</span><br><span class="line"><span class="bullet">-</span> 参数是<span class="code">`hidden`</span>的时候，溢出隐藏；</span><br></pre></td></tr></table></figure><h1 id="97-css样式引入方式的优缺点对比"><a href="#97-css样式引入方式的优缺点对比" class="headerlink" title="97. css样式引入方式的优缺点对比"></a>97. css样式引入方式的优缺点对比</h1><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">内嵌样式： 优点： 方便书写，权重高；缺点： 没有做到结构和样式分离；</span><br><span class="line">内联样式： 优点：结构样式相分离； 缺点：没有彻底分离；</span><br><span class="line">外联样式： 优点： 完全实现了结构和样式相分离； 缺点： 需要引入才能使用；</span><br></pre></td></tr></table></figure><h1 id="98-position-跟-display、overflow、float-这些特性相互叠加后会怎么样？"><a href="#98-position-跟-display、overflow、float-这些特性相互叠加后会怎么样？" class="headerlink" title="98. position 跟 display、overflow、float 这些特性相互叠加后会怎么样？"></a>98. position 跟 display、overflow、float 这些特性相互叠加后会怎么样？</h1><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="code">`display`</span>属性规定元素应该生成的框的类型；</span><br><span class="line"><span class="bullet">-</span> <span class="code">`position`</span>属性规定元素的定位类型；</span><br><span class="line"><span class="bullet">-</span> <span class="code">`float`</span>属性是一种布局方式，定义元素往哪个方向浮动；</span><br><span class="line"></span><br><span class="line"><span class="strong">**叠加结果**</span>：有点类似于优先机制。<span class="code">`position`</span>的值-- <span class="code">`absolute/fixed`</span>优先级最高，有他们在时，<span class="code">`float`</span>不起作用，<span class="code">`display`</span>值需要调整。<span class="code">`float`</span>或者<span class="code">`absolute`</span>定位的元素，只能是块元素或者表格。</span><br></pre></td></tr></table></figure><h1 id="99-什么是回流（重排）和重绘以及其区别？"><a href="#99-什么是回流（重排）和重绘以及其区别？" class="headerlink" title="99. 什么是回流（重排）和重绘以及其区别？"></a>99. 什么是回流（重排）和重绘以及其区别？</h1><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> 回流（重排），<span class="code">`reflow`</span>:当<span class="code">`render tree`</span>中的一部分（或全部）因为元素的规模尺寸，布局，隐藏等改变时而需要重新构建；</span><br><span class="line"><span class="bullet">-</span> 重绘<span class="code">`（repaint`</span>）:当<span class="code">`render tree`</span>中的一些元素需要更新属性，而这些属性只影响元素的外观，风格，而不会影响布局时，称其为<span class="strong">**重绘**</span>，例如颜色改变等。</span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> 增加或者删除可见的<span class="code">`dom`</span>元素；</span><br><span class="line"><span class="bullet">-</span> 元素的位置发生了改变；</span><br><span class="line"><span class="bullet">-</span> 元素的尺寸发生了改变，例如边距，宽高等几何属性改变；</span><br><span class="line"><span class="bullet">-</span> 内容改变，例如图片大小，字体大小改变等；</span><br><span class="line"><span class="bullet">-</span> 页面渲染初始化；</span><br><span class="line"><span class="bullet">-</span> 浏览器窗口尺寸改变，例如<span class="code">`resize`</span>事件发生时等；</span><br><span class="line"><span class="bullet">-</span> 重排（回流）一定会引发重绘<span class="strong">**。</span></span><br></pre></td></tr></table></figure><h1 id="100-说说-px、em、rem的区别及使用场景"><a href="#100-说说-px、em、rem的区别及使用场景" class="headerlink" title="100.说说 px、em、rem的区别及使用场景"></a>100.说说 px、em、rem的区别及使用场景</h1><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="strong">**三者的区别：**</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> px是固定的像素，一旦设置了就无法因为适应页面大小而改变。</span><br><span class="line"><span class="bullet">-</span> em和rem相对于px更具有灵活性，他们是相对长度单位，其长度不是固定的，更适用于响应式布局。</span><br><span class="line"><span class="bullet">-</span> em是相对于其父元素来设置字体大小，这样就会存在一个问题，进行任何元素设置，都有可能需要知道他父元素的大小。而rem是相对于根元素，这样就意味着，只需要在根元素确定一个参考值。</span><br><span class="line"></span><br><span class="line"><span class="strong">**使用场景：**</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> 对于只需要适配少部分移动设备，且分辨率对页面影响不大的，使用px即可 。</span><br><span class="line"><span class="bullet">-</span> 对于需要适配各种移动设备，使用rem，例如需要适配iPhone和iPad等分辨率差别比较挺大的设备</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-Vue3-0性能提升主要是体现在哪些方面&quot;&gt;&lt;a href=&quot;#1-Vue3-0性能提升主要是体现在哪些方面&quot; class=&quot;headerlink&quot; title=&quot;1.Vue3.0性能提升主要是体现在哪些方面&quot;&gt;&lt;/a&gt;1.Vue3.0性能提升主要是体现在哪些</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>vue2/3区别理解</title>
    <link href="https://admin741-cl.github.io/posts/5a61.html"/>
    <id>https://admin741-cl.github.io/posts/5a61.html</id>
    <published>2021-11-03T12:09:44.000Z</published>
    <updated>2023-06-19T12:58:53.186Z</updated>
    
    <content type="html"><![CDATA[<h1 id="持续更新中…"><a href="#持续更新中…" class="headerlink" title="持续更新中…."></a>持续更新中….</h1><h1 id="01v-show和v-if指令的共同点和不同点"><a href="#01v-show和v-if指令的共同点和不同点" class="headerlink" title="01v-show和v-if指令的共同点和不同点"></a>01v-show和v-if指令的共同点和不同点</h1><p>相同点：v-show和v-if都能控制元素的显示和隐藏</p><p>不同点：手段：v-if是动态的向DOM树内添加或者删除DOM元素；<br> v-show是通过设置DOM元素的display样式属性控制显隐；<br> 编译过程：v-if切换有一个局部编译/卸载的过程，切换过程中合适地销毁和重建内部的事件监听和子组件；<br> v-show只是简单的基于css切换；编译条件：v-if是惰性的，如果初始条件为假，则什么也不做；只有在条件第一次变为真时才开始局部编译;<br> v-show是在任何条件下，无论首次条件是否为真，都被编译，然后被缓存，而且DOM元素保留；性能消耗：v-if有更高的切换消耗；<br> v-show有更高的初始渲染消耗；使用场景：v-if适合运营条件不大可能改变；v-show适合频繁切换。</p><h1 id="02vue组件中data为什么必须是一个函数"><a href="#02vue组件中data为什么必须是一个函数" class="headerlink" title="02vue组件中data为什么必须是一个函数\"></a>02vue组件中data为什么必须是一个函数\</h1><p>Vue组件可能存在多个实例，如果使用对象形式定义data，则会导致它们共用一个data对象，那么状态变更将会影响所有组件实例，这是不合理的；采用函数形式定义，在initData时会将其作为工厂函数返回全新data对象，有效规避多实例之间状态污染问题。而在Vue根实例创建过程中则不存在该限制，也是因为根实例只能有一个，不需要担心这种情况。</p><h1 id="03-nextTick的使用"><a href="#03-nextTick的使用" class="headerlink" title="03$nextTick的使用\"></a>03$nextTick的使用\</h1><p><strong><em>\</em>用法：**</strong>将回调延迟到下次DOM更新循环之后执行。在修改数据之后立即使用它，然后等待DOM更新。它跟全局方法 Vue.nextTick 一样，不同的是回调的 this 自动绑定到调用它的实例上。</p><p><strong><em>\</em>$nextTick() 的应用场景**</strong></p><p>  在vue的生命周期 created() 钩子函数中进行 dom 操作，一定要放在 $nextTick() 函数中执行。在 created() 钩子函数执行的时候 DOM 其实并未进行任何渲染，而此时进行 DOM 操作无异于徒劳，所以此处一定要将 DOM 操作的代码放进 nextTick() 的回调函数中。</p><p>  mounted() 钩子函数，因为该钩子函数执行时，所有的 DOM 挂载和 渲染都已完成，此时在该钩子函数中进行任何 DOM 操作都不会有问题</p><p>在数据变化后要执行某个操作，而这个操作需要随数据改变而改变DOM结构时，这个操作都是需要放置 $nextTick() 的回调函数中。</p><h1 id="04Vue中双向数据绑定是如何实现的"><a href="#04Vue中双向数据绑定是如何实现的" class="headerlink" title="04Vue中双向数据绑定是如何实现的\"></a>04Vue中双向数据绑定是如何实现的\</h1><p>Vue 数据双向绑定主要是指：数据变化更新视图，视图变化更新数据</p><p>实现原理：采用数据监听、解析结合订阅者模式的方式，通过Object.defineProperty()来监听各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。从而实现数据的双向绑定</p><p>主要分为以下几个步骤：</p><p>需要observe的数据对象进行递归遍历，包括子属性对象的属性，都加上setter和getter这样的话，给这个对象的某个值赋值，就会触发setter，那么就能监听到了数据变化</p><p>compile解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图</p><p>Watcher订阅者是Observer和Compile之间通信的桥梁，主要做的事情是: ①在自身实例化时往属性订阅器(dep)里面添加自己 ②自身必须有一个update()方法 ③待属性变动dep.notice()通知时，能调用自身的update()方法，并触发Compile中绑定的回调，则功成身退。</p><p>MVVM作为数据绑定的入口，整合Observer、Compile和Watcher三者，通过Observer来监听自己的model数据变化，通过Compile来解析编译模板指令，最终利用Watcher搭起Observer和Compile之间的通信桥梁，达到数据变化 -&gt; 视图更新；视图交互变化(input) -&gt; 数据model变更的双向绑定效果。</p><h1 id="05vue中v-if和v-for优先级在vue2和vue3中的区别"><a href="#05vue中v-if和v-for优先级在vue2和vue3中的区别" class="headerlink" title="05vue中v-if和v-for优先级在vue2和vue3中的区别"></a>05vue中v-if和v-for优先级在vue2和vue3中的区别</h1><p>实践中不管是<a href="https://so.csdn.net/so/search?q=vue2&amp;spm=1001.2101.3001.7020">vue2</a>或者vue3都不应该把v-if和v-for放在一起使用。</p><p>在 vue 2.x 中，在一个元素上同时使用 v-if 和 v-for 时， v-for 会优先作用。</p><p>在 vue 3.x 中， v-if 总是优先于 v-for 生效。</p><p>vue2中v-for的优先级是高于v-if的，放在一起，会先执行循环在判断条件，并且如果值渲染列表中一小部分元素，也得再每次重渲染的时候遍历整个列表，比较浪费资源。</p><p>vue3中v-if的优先级是高于v-for的，所以v-if执行时，它调用相应的变量如果不存在，就会导致异常</p><h1 id="06vue常用的修饰符"><a href="#06vue常用的修饰符" class="headerlink" title="06vue常用的修饰符"></a>06vue常用的修饰符</h1><p>.stop：等同于 JavaScript 中的 event.stopPropagation() ，防止事件冒泡；</p><p>.prevent ：等同于 JavaScript 中的 event.preventDefault() ，防止执行预设的行为（如果事件可取消，则取消该事件，而不停止事件的进一步传播）；作用是阻止默认事件（例如a标签的跳转</p><p>.capture ：与事件冒泡的方向相反，事件捕获由外到内；</p><p>.self ：只会触发自己范围内的事件，不包含子元素；</p><p>.once ：只会触发一次。</p><p>.trim修饰符的作用是把v-model绑定的值的首尾空格给去掉。在实际开发中我们一般用于搜索框的内容修饰，过滤掉用户多输入前后空格导致内容查不出来的情况。</p><p>.left，.right，.middle这三个修饰符是鼠标的左中右按键触发的事件.</p><h1 id="07自定义指令详解"><a href="#07自定义指令详解" class="headerlink" title="07自定义指令详解"></a>07自定义指令详解</h1><p><strong><em>\</em>为什么需要自定义指令**</strong>：因为vue是MVVM模式，只需要关注于数据和业务逻辑，不需要关注DOM的操作，但是有时候面对一些特殊的业务需求时，需要进行DOM的操作，这个时候就需要进行自定义指令。</p><p>自定义局部指令:在options api选项中的directives中设置。局部自定义指令是一个对象，对象的属性是自定义指令的名称，对象中属性的值是自定义指令的钩子函数对象</p><p>自定义全局指令:在app的directive方法。参数一（name）：自定义指令的名称。参数二（hooks）：自定义指令的钩子函数对象</p><h1 id="08slot是什么？有什么作用？原理是什么？"><a href="#08slot是什么？有什么作用？原理是什么？" class="headerlink" title="08slot是什么？有什么作用？原理是什么？"></a>08slot是什么？有什么作用？原理是什么？</h1><p>slot又名插槽，是Vue的内容分发机制，组件内部的模板引擎使用slot元素作为承载分发内容的出口。插槽slot是子组件的一个模板标签元素，而这一个标签元素是否显示，以及怎么显示是由父组件决定的。slot又分三类，默认插槽，具名插槽和作用域插槽。</p><p>默认插槽：又名匿名插槽，当slot没有指定name属性值的时候一个默认显示插槽，一个组件内只有有一个匿名插槽。</p><p>具名插槽：带有具体名字的插槽，也就是带有name属性的slot，一个组件可以出现多个具名插槽。</p><p>作用域插槽：默认插槽、具名插槽的一个变体，可以是匿名插槽，也可以是具名插槽，该插槽的不同点是在子组件渲染作用域插槽时，可以将子组件内部的数据传递给父组件，让父组件根据子组件的传递过来的数据决定如何渲染该插槽。</p><p>实现原理：当子组件vm实例化时，获取到父组件传入的slot标签的内容，存放在vm.$slot中，默认插槽为vm.$slot.default，具名插槽为vm.$slot.xxx，xxx 为插槽名，当组件执行渲染函数时候，遇到slot标签，使用$slot中的内容进行替换，此时可以为插槽传递数据，若存在数据，则可称该插槽为作用域插槽。</p><h1 id="09vue初始化页面闪动问题"><a href="#09vue初始化页面闪动问题" class="headerlink" title="09vue初始化页面闪动问题"></a>09vue初始化页面闪动问题</h1><p>在简单项目中，使用 v-cloak 指令是解决屏幕闪动的好方法。但在大型、工程化的项目中（webpack、vue-router）只有一个空的 div 元素，元素中的内容是通过路由挂载来实现的，这时我们就不需要用到 v-cloak 指令了。</p><h1 id="10vue更新数组时触发视图更新的方法"><a href="#10vue更新数组时触发视图更新的方法" class="headerlink" title="10vue更新数组时触发视图更新的方法"></a>10vue更新数组时触发视图更新的方法</h1><p>Vue.set 响应式新增与修改数据</p><p>可以设置对象或数组的值，通过key或数组索引，可以触发视图更新</p><p>Vue.delete：删除对象或数组中元素，通过key或数组索引，可以触发视图更新</p><p> push() 向数组的末尾添加一个或多个元素，并返回新的长度。</p><p> pop() 删除最后一个元素，把数组长度减 1，并且返回它删除的元素的值。</p><p> shift() 把数组的第一个元素从其中删除，并返回第一个元素的值。</p><p> unshift() 向数组的开头添加一个或更多元素，并返回新的长度。</p><p> splice() 向/从数组中添加/删除项目，然后返回被删除的项目。 该方法会改变原始数组。</p><p> sort() 对数组的元素进行排序。</p><p> reverse() 颠倒数组中元素的顺序。</p><p>filter()、concat()、 slice()  这些方法不会改变被操作的数组，返回一个新的数组；</p><h1 id="11Vue2-0-和-Vue3-0-有什么区别？"><a href="#11Vue2-0-和-Vue3-0-有什么区别？" class="headerlink" title="11Vue2.0 和 Vue3.0 有什么区别？"></a>11Vue2.0 和 Vue3.0 有什么区别？</h1><p><strong><em>\</em>双向绑定更新**</strong></p><p>vue2 的双向数据绑定是利⽤ES5 的⼀个 API ，Object.defineProperty()对数据进⾏劫持 结合 发布订阅模式的⽅式来实现的。</p><p>vue3 中使⽤了 ES6 的 ProxyAPI 对数据代理，通过 reactive() 函数给每⼀个对象都包⼀层 Proxy，通过 Proxy 监听属性的变化，从⽽ 实现对数据的监控。</p><p>  这⾥是相⽐于vue2版本，使⽤proxy的优势如下</p><p>  1.defineProperty只能监听某个属性，不能对全对象监听 可以省去for in、闭包等内容来提升效率（直接绑定整个对象即可）</p><p>  2.可以监听数组，不⽤再去单独的对数组做特异性操作,通过Proxy可以直接拦截所有对象类型数据的操作，完美⽀持对数组的监听。</p><p><strong><em>\</em>获取props**</strong></p><p>vue2在script代码块可以直接获取props，vue3通过setup指令传递</p><p><strong><em>\</em>API不同**</strong></p><p>Vue2使⽤的是选项类型API（Options API），Vue3使⽤的是合成型API（Composition API）</p><p><strong><em>\</em>建立数据data**</strong></p><p>vue2是把数据放入data中，vue3就需要使用一个新的setup()方法，此方法在组件初始化构造得时候触发。</p><p><strong><em>\</em>生命周期不同**</strong></p><p>vue2   ———— vue3</p><p>beforeCreate  -&gt; setup() 开始创建组件之前，创建的是data和method</p><p>created     -&gt; setup()</p><p>beforeMount   -&gt; onBeforeMount 组件挂载到节点上之前执行的函数。</p><p>mounted    -&gt; onMounted 组件挂载完成后执行的函数</p><p>beforeUpdate  -&gt; onBeforeUpdate 组件更新之前执行的函数。</p><p>updated     -&gt; onUpdated 组件更新完成之后执行的函数。</p><p>beforeDestroy  -&gt; onBeforeUnmount 组件挂载到节点上之前执行的函数。</p><p>destroyed    -&gt; onUnmounted 组件卸载之前执行的函数。dszhuoyi</p><p>activated    -&gt; onActivated 组件卸载完成后执行的函数</p><p>deactivated   -&gt; onDeactivated</p><p><strong><em>\</em>关于v-if和v-for的优先级:**</strong></p><p>vue2 在一个元素上同时使用 v-if 和 v-for  v-for会优先执行</p><p>  vue3 v-if 总会优先于  v-for生效</p><p><strong><em>\</em>vue2和vue3的diff算法**</strong></p><p><strong><em>\</em>vue2**</strong></p><p>  vue2 diff算法就是进行虚拟节点对比，并返回一个patch对象，用来存储两个节点 不同的地方，最后用patch记录的消息去局部更新Dom。</p><p>  vue2 diff算法会比较每一个vnode,而对于一些不参与更新的元素，进行比较是有 点消耗性能的。</p><p><strong><em>\</em>vue3**</strong></p><p>  vue3 diff算法在初始化的时候会给每个虚拟节点添加一个patchFlags，patchFlags 就是优化的标识。</p><p>  只会比较patchFlags发生变化的vnode,进行更新视图，对于没有变化的元素做静 态标记，在渲染的时候直接复用。</p><h1 id="12-Vue3带来了什么改变？"><a href="#12-Vue3带来了什么改变？" class="headerlink" title="12.Vue3带来了什么改变？"></a>12.Vue3带来了什么改变？</h1><p>Vue3.0在性能方面比Vue2.x快了1.2～2倍。</p><p>重写虚拟DOM的实现</p><p>运行时编译</p><p>静态提升与事件侦听器缓存</p><p>SSR 速度提高</p><p>Vue3.x采用TypeScript重写，开发者使用Vue3.x时可以充分体验TS给编码带来的便利。</p><p>Composition API：vue2中，我们一般会采用mixin来复用逻辑代码，用倒是挺好用的，不过也存在一些问题：例如代码来源不清晰、方法属性等冲突。基于此在vue3中引入了Composition API（组合API），使用纯函数分隔复用代码。和React中的hooks的概念很相似</p><h1 id="13-reactive与ref的区别？"><a href="#13-reactive与ref的区别？" class="headerlink" title="13.reactive与ref的区别？"></a>13.reactive与ref的区别？</h1><p>Vue3 中的 ref 和 reactive 是 Vue3 中用于数据管理的两种不同的响应式 API。</p><p>ref 用于创建一个包装简单值的响应式引用，例如一个数字、字符串或对象。当 ref 创建一个响应式引用时，它返回一个对象，该对象具有一个 value 属性，该属性指向实际值。当 ref 返回的对象中的 value 属性更改时，组件将自动重新渲染。</p><p>reactive 用于创建一个响应式对象，该对象可以包含多个属性和嵌套属性。当使用 reactive 创建响应式对象时，返回的对象是一个代理对象，该对象具有与原始对象相同的属性，并且任何对代理对象属性的更改都将触发组件的重新渲染。</p><p>综上所述，如果需要对简单值进行响应式处理，则使用 ref，如果需要对对象或嵌套对象进行响应式处理，则使用 reactive。</p><h1 id="14-计算属性和watch以及methods的区别？"><a href="#14-计算属性和watch以及methods的区别？" class="headerlink" title="14.计算属性和watch以及methods的区别？"></a>14.计算属性和watch以及methods的区别？</h1><p><strong><em>\</em>对于Computed：**</strong>它支持缓存，只有依赖的数据发生了变化，才会重新计算</p><p>不支持异步，当Computed中有异步操作时，无法监听数据的变化</p><p>computed的值会默认走缓存，计算属性是基于它们的响应式依赖进行缓存的，也就是基于data声明过，或者父组件传递过来的props中的数据进行计算的。</p><p>如果一个属性是由其他属性计算而来的，这个属性依赖其他的属性，一般会使用computed</p><p>如果computed属性的属性值是函数，那么默认使用get方法，函数的返回值就是属性的属性值；在computed中，属性有一个get方法和一个set方法，当数据发生变化时，会调用set方法。</p><p><strong><em>\</em>对于Watch：**</strong>它不支持缓存，数据变化时，它就会触发相应的操作</p><p>支持异步监听</p><p>监听的函数接收两个参数，第一个参数是最新的值，第二个是变化之前的值</p><p>当一个属性发生变化时，就需要执行相应的操作监听数据必须是data中声明的或者父组件传递过来的props中的数据，当发生变化时，会触发其他操作，函数</p><p>有两个的参数：immediate：组件加载立即触发回调函数 deep：深度监听，发现数据内部的变化，在复杂数据类型中使用，例如数组中的对象发生变化。需要注意的是，deep无法监听到数组和对象内部的变化。</p><p>当想要执行异步或者昂贵的操作以响应不断的变化时，就需要使用watch。</p><h1 id="15-route-和-router-的区别？"><a href="#15-route-和-router-的区别？" class="headerlink" title="15.$route 和 $router 的区别？"></a>15.$route 和 $router 的区别？</h1><p>$route 是“路由信息对象”，包括 path，params，hash，query，fullPath，matched，name 等路由信息参数</p><p>$router 是“路由实例”想要导航到不同URL 对象包括了路由的跳转方法，钩子函数等。</p><h1 id="16-v-model的使用？"><a href="#16-v-model的使用？" class="headerlink" title="16.v-model的使用？"></a>16.v-model的使用？</h1><p>v-model实现双向绑定的语法糖，常用于表单与组件之间的数据双向绑定.</p><p>V-model的原理：</p><pre><code>v-bind绑定一个value属性v-on指令给当前元素绑定input事件</code></pre><p>可看出v-model绑定在表单上时，v-model其实就是v-bind绑定value和v-on监听input事件的结合体</p><p>组件上的双向绑定（原理）</p><p>v-model绑定在组件上的时候做了以下步骤</p><pre><code>在父组件内给子组件标签添加 v-model ，其实就是给子组件绑定了 value 属性子组件内使用 prop 创建 创建 value 属性可以拿到父组件传递下来的值，名字必须是 value。子组件内部更改 value 的时候，必须通过 $emit 派发一个 input 事件，并携最新的值v-model 会自动监听 input 事件，把接收到的最新的值同步赋值到 v-model 绑定的变量上</code></pre><h1 id="17EventBus注册在全局上时，路由切换时会重复触发事件，如何解决呢？"><a href="#17EventBus注册在全局上时，路由切换时会重复触发事件，如何解决呢？" class="headerlink" title="17EventBus注册在全局上时，路由切换时会重复触发事件，如何解决呢？"></a>17EventBus注册在全局上时，路由切换时会重复触发事件，如何解决呢？</h1><p>添加Bus.$off来关闭</p><p>beforeDestroy () {</p><p>bus.$off(‘get’, this.myhandle)</p><p>}</p><p>如果想要用bus 来进行页面组件之间的数据传递，需要注意亮点，组件$emit事件应在beforeDestory生命周期内。其次，组件B内的$on记得要销毁。</p><h1 id="18-vuex有哪几种属性？"><a href="#18-vuex有哪几种属性？" class="headerlink" title="18.vuex有哪几种属性？"></a>18.vuex有哪几种属性？</h1><p>vuex 是 Vue 配套的 公共数据管理工具，它可以把一些共享的数据，保存到 vuex 中，方便整个程序中的任何组件直接获取或修改我们的公共数据。</p><p>有五种，分别是 State、 Getter、Mutation 、Action、 Module</p><p>vuex 是 Vue 配套的 公共数据管理工具，它可以把一些共享的数据，保存到 vuex 中，方便整个程序中的任何组件直接获取或修改我们的公共数据。</p><p>有五种，分别是 State、 Getter、Mutation 、Action、 Module</p><p>state：用来存放多个组件会用到的公共属性</p><p>mutations：改变state的规范途径，并且只能同步操作，可以在vue-devtools 追踪到修改记录</p><p>getters：作用和computed相似，对state里面的多个属性计算时使用</p><p>actions：一些对state的异步操作可以放在actions中，并通过在action提交到mutaions进行状态的修改</p><p>modules：当store对象过于庞大时，可以根据具体的业务需求分为多个module</p><h1 id="19-vue中过滤器有什么作用及详解？"><a href="#19-vue中过滤器有什么作用及详解？" class="headerlink" title="19.vue中过滤器有什么作用及详解？"></a>19.vue中过滤器有什么作用及详解？</h1><p>根据过滤器的名称，过滤器是用来过滤数据的，在Vue中使用filters来过滤数据，filters不会修改数据，而是过滤数据，改变用户看到的输出（计算属性 computed ，方法 methods 都是通过修改数据来处理数据格式的输出显示）。</p><p>使用场景：需要格式化数据的情况，比如需要处理时间、价格等数据格式的输出 / 显示。比如后端返回一个 年月日的日期字符串，前端需要展示为 多少天前 的数据格式，此时就可以用fliters过滤器来处理数据。</p><p>过滤器是一个函数，它会把表达式中的值始终当作函数的第一个参数。过滤器用在插值表达式 (两个花括号嵌套) 和 v-bind 表达式 中，然后放在操作符“ | ”后面进行指示。</p><h1 id="20-v-on可以监听多个方法吗？"><a href="#20-v-on可以监听多个方法吗？" class="headerlink" title="20.v-on可以监听多个方法吗？"></a>20.v-on可以监听多个方法吗？</h1><p>可以一个元素绑定多个事件的两种写法，一个事件绑定多个函数的两种写法，修饰符的使用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a v-on=&#x27;&#123;click:DoSomething,mouseleave:MouseLeave&#125;&#x27;&gt;doSomething&lt;/a&gt;</span><br></pre></td></tr></table></figure><p>在method方法里面分别写两个事件；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;button @click=&quot;a(),b()&quot;&gt;点我ab&lt;/button&gt;</span><br></pre></td></tr></table></figure><h1 id="21-请详细说下你对vue生命周期的理解？"><a href="#21-请详细说下你对vue生命周期的理解？" class="headerlink" title="21.请详细说下你对vue生命周期的理解？"></a>21.请详细说下你对vue生命周期的理解？</h1><p>Vue的生命周期就是vue实例从创建到销毁的全过程，也就是new Vue() 开始就是vue生命周期的开始。Vue 实例有⼀个完整的⽣命周期，也就是从开始创建、初始化数据、编译模版、挂载Dom -&gt; 渲染、更新 -&gt; 渲染、卸载 等⼀系列过程，称这是Vue的⽣命周期。</p><p>有八个阶段创建前/后，载入前/后，更新前/后，销毁前/后</p><p>创建前/后： 在beforeCreate阶段，vue实例的挂载元素el和数据对象data都为undefined，还未初始化。在created阶段，vue实例的数据对象data有了，el还没有</p><p>载入前/后：在beforeMount阶段，vue实例的$el和data都初始化了，但还是挂载之前为虚拟的dom节点，data.message还未替换。在mounted阶段，vue实例挂载完成，data.message成功渲染。</p><p>更新前/后：当data变化时，会触发beforeUpdate和updated方法</p><p>销毁前/后：在执行destroy方法后，对data的改变不会再触发周期函数，说明此时vue实例已经解除了事件监听以及和dom的绑定，但是dom结构依然存在</p><h1 id="22-vue优点？"><a href="#22-vue优点？" class="headerlink" title="22.vue优点？"></a>22.vue优点？</h1><p><strong><em>\</em>轻量级框架**</strong>：只关注视图层，是一个构建数据的视图集合，大小只有几十 kb ；</p><p><strong><em>\</em>简单易学**</strong>：国人开发，中文文档，不存在语言障碍 ，易于理解和学习；</p><p><strong><em>\</em>双向数据绑定**</strong>：保留了 angular 的特点，在数据操作方面更为简单；</p><p><strong><em>\</em>组件化**</strong>：保留了 react 的优点，实现了 html 的封装和重用，在构建单页面应用方面有着独特的优势；</p><p><strong><em>\</em>视图，数据，结构分离**</strong>：使数据的更改更为简单，不需要进行逻辑代码的修改，只需要操作数据就能完成相关操作；</p><p><strong><em>\</em>虚拟DOM**</strong>：dom 操作是非常耗费性能的，不再使用原生的 dom 操作节点，极大解放 dom 操作，但具体操作的还是 dom 不过是换了另一种方式；</p><p><strong><em>\</em>运行速度更快**</strong>：相比较于 react 而言，同样是操作虚拟 dom，就性能而言， vue 存在很大的优势</p><h1 id="23-单页面应用和多页面应用区别及优缺点？"><a href="#23-单页面应用和多页面应用区别及优缺点？" class="headerlink" title="23.单页面应用和多页面应用区别及优缺点？"></a>23.单页面应用和多页面应用区别及优缺点？</h1><p><strong><em>\</em>单页面**</strong>（Sing Page Application——SPA）：顾名思义，只有一个页面。一般是一个主页和多个路由页面组成。</p><p><strong><em>\</em>优点**</strong>：</p><p>  公共资源不重新加载，局部加载，服务器压力小</p><p>  切换速度快，用户体验好</p><p>  前后端分离</p><p> <strong><em>\</em>缺点**</strong>：</p><p>  不利于SEO（可以优化：比如路由懒加载等）</p><p>  初次加载时耗时多</p><p>  开发难度较大（相对多页面）</p><p><strong><em>\</em>多页面**</strong>（Multi Page Application——MPA）：有多个HTML页面，跳转的时候是从一个html页面跳到另一个页面。</p><p><strong><em>\</em>优点**</strong>：</p><p>  利于SEO。</p><p>  更容易扩展。</p><p>  更易数据分析。</p><p><strong><em>\</em>缺点**</strong>：</p><p>  开发成本高。</p><p>  服务器压力大。</p><p>  用户体验相对较差。</p><h1 id="24-vue路由跳转传参的方式有哪些？"><a href="#24-vue路由跳转传参的方式有哪些？" class="headerlink" title="24.vue路由跳转传参的方式有哪些？"></a>24.vue路由跳转传参的方式有哪些？</h1><p><strong><em>\</em>params传参(显示参数)**</strong></p><p>在url中会显示出传参的值，刷新页面不会失去拿到的参数，使用该方式传值的时候，需要子路由提前配置好参数</p><p><strong><em>\</em>params传参(不显示参数)**</strong></p><p>在url中不会显示出传参的值，但刷新页面会失去拿到的参数，使用该方式 传值 的时候，需要子路由提前配置好name参数</p><p><strong><em>\</em>query 传参**</strong></p><p>query 传过去的参数会拼接在地址栏中（?name=xx），刷新页面数据不会丢失，使用path和name都可以</p><p><strong><em>\</em>VUE几种路由跳转几种方式的区别**</strong></p><p>this.$router.push：跳转到指定url路径，并想history栈中添加一个记录，点击后退会返回到上一个页面</p><p>this.$router.replace：跳转到指定url路径，但是history栈中不会有记录，点击返回会跳转到上上个页面 (就是直接替换了当前页面)</p><p>this.$router.go(n)：向前或者向后跳转n个页面，n可为正整数或负整数</p><h1 id="25-vue遇到的坑，如何解决的？"><a href="#25-vue遇到的坑，如何解决的？" class="headerlink" title="25.vue遇到的坑，如何解决的？"></a>25.vue遇到的坑，如何解决的？</h1><p>用webpack打包后访问index.html出现资源加载404问题，解决：开发环境的static文件夹是基于根目录的，所以直接用‘/’ 。</p><p>vue中，假如，你引入某个样式，然后这个样式里面有引用到图片，如果你的文件中没有这个图片，这时候，即使你没有引用这个图片对应的类名，但是只要你有引入这个css文件，他找不到相应路径图片也会报错！！！</p><p>用for循环出来的列表，在设置列表中的元素的动态属性时，需要加bind属性“：”，不然动态属性设置不出来</p><p>在vue中的html中的img中的src不可以直接设置为变量，在data里面直接引路径，只能通过import的形式引入,值得注意的是，引用这个方式的时候src是变量需要加“：”，不然会报错！！！！！</p><p>在中使用v-for=”(item ,index) in list”进行循环时，需要注意加：:key=“index”,不然会出现警告！</p><p>父组件ajax异步更新数据，子组件props获取不到</p><p>应用场景</p><p>当父组件  axjos  获取数据，子组件使用  props  接收数据时，执行  mounted  的时候  axjos  还没有返回数据，而且  mounted 只执行一次，这时  props  中接收的数据为空</p><p>解决方案：在对应组件中判断数据的长度</p><h1 id="26-vue封装通用组件方法思路？"><a href="#26-vue封装通用组件方法思路？" class="headerlink" title="26.vue封装通用组件方法思路？"></a>26.vue封装通用组件方法思路？</h1><p>封装组件需要注意三点：1. props参数2. slot定制插槽3. event自定义事件</p><p>首先，使用Vue.extend()创建一个组件</p><p>然后，使用Vue.component()方法注册组件</p><p>接着，如果子组件需要数据，可以在props中接受定义</p><p>最后，子组件修改好数据之后，想把数据传递给父组件，可以使用emit()方法</p><p>父子组件<strong><em>\</em>间的数据传递**</strong></p><p>  <strong><em>\</em>父组件通过 prop 将数据传递给子组件**</strong></p><p>  <strong><em>\</em>子组件通**</strong>过 emit 事件将子组件数据传递给父组件</p><p>  子组件不能直接修改 prop 中传给父组件的值</p><h1 id="27-Vue-js中ajax请求代码应该写在组件的methods中还是vuex的actions中？"><a href="#27-Vue-js中ajax请求代码应该写在组件的methods中还是vuex的actions中？" class="headerlink" title="27.Vue.js中ajax请求代码应该写在组件的methods中还是vuex的actions中？"></a>27.Vue.js中ajax请求代码应该写在组件的methods中还是vuex的actions中？</h1><p>如果请求来的数据是不是要被其他组件公用，仅仅在请求的组件内使用，就不需要放入vuex 的state里。</p><p>如果被其他地方复用，这个很大几率上是需要的，如果需要，请将请求放入action里，方便复用，并包装成promise返回，在调用处用async await处理返回的数据。如果不要复用这个请求，那么直接写在vue文件里很方便。</p><h1 id="28-Vuex中如何异步修改状态？"><a href="#28-Vuex中如何异步修改状态？" class="headerlink" title="28.Vuex中如何异步修改状态？"></a>28.Vuex中如何异步修改状态？</h1><p>actions类似于mutations，不同在于：Action提交的是mutation，而不是直接变更状态；</p><p>Action可以包含任意异步操作，Action函数接受一个与store实例具有相同方法和属性的 context对象，因此你可以调用context.commit提交一个mutation，或者通过context.state 和context.getters来获取state和getters。</p><p>Action 通过store.dispatch方法触发：store.dispatch(‘increment’)</p><h1 id="29-刷新浏览器后，Vuex的数据是否存在？如何解决？"><a href="#29-刷新浏览器后，Vuex的数据是否存在？如何解决？" class="headerlink" title="29.刷新浏览器后，Vuex的数据是否存在？如何解决？"></a>29.刷新浏览器后，Vuex的数据是否存在？如何解决？</h1><p>原因：因为 store 里的数据是保存在运行内存中的，当页面刷新时，页面会重新加载vue实例，store里面的数据就会被重新赋值初始化。</p><p>localStorage 或者就是sessionStorage</p><p>下载持久化存储插件。比如使用：vuex-along 的实质也是将 vuex 中的数据存放到 localStorage 或者 sessionStroage 中，只不过这个存取过程组件会帮我们完成，我们只需要用vuex的读取数据方式操作就可以了</p><h1 id="30-vuex中的辅助函数怎么使用？"><a href="#30-vuex中的辅助函数怎么使用？" class="headerlink" title="30.vuex中的辅助函数怎么使用？"></a>30.vuex中的辅助函数怎么使用？</h1><p>vuex的辅助函数有4个</p><p><strong><em>\</em>mapState**</strong> 函数返回的是一个对象。通常，我们需要使用一个工具函数将多个对象合并为一个，以使我们可以将最终对象传给 computed 属性。</p><p><strong><em>\</em>mapGetters**</strong> 辅助函数仅仅是将 store 中的 getter 映射到局部计算属性，因此你可以这样来使用他</p><p><strong><em>\</em>mapMutations**</strong> 辅助函数将组件中的 methods 映射为 store.commit，其原理就是将this.montify 映射为this.$store.commit(‘montify’)</p><p><strong><em>\</em>mapActions**</strong>在组件中使用 this.$store.dispatch(‘prodect’) 分发 action，或者使用 mapActions 辅助函数将组件的 methods 映射为 store.dispatch 调用</p><h1 id="31-vue插槽的理解？"><a href="#31-vue插槽的理解？" class="headerlink" title="31.vue插槽的理解？"></a>31.vue插槽的理解？</h1><p>Vue插槽是Vue中常见的一种组件间的相互通信方式，作用是让父组件可以向子组件指定位置插入html结构，适用于父组件===&gt;子组件，在要接收数据的组件页面通过<slot>标签来表示，简单来说，就是通过此标签来起到占位的作用，而要插入的内容也会对应到标签所在的位置。</p><p><strong><em>\</em>默认插槽是插槽最基本的方式**</strong>：<br>首先在父组件App.Vue中引入子组件，并在引入的子组件标签内插入需要的html元素，在子组件中把需要用插槽的地方用<slot>标签替代</p><p><strong><em>\</em>具名插槽就是有名字的插槽**</strong>。</p><p>使用：首先在要插入html的部分需要用一个<template>标签包裹住各个部分其次，当给<template>标签绑定slot=“name” 属性时，需要在子组件中对应每个<template> 给出一个<slot> 并且添加上name属性</p><p><strong><em>\</em>作用域插槽**</strong></p><p>数据在组件的自身，但根据数据生成的结构需要组件的使用者来决定，也就是说，作用域插槽的不同之处就在于，数据不在父组件身上，而是在子组件身上，且组件的结构和内容由父组件决定。作用域组件限定了组件内结构和数据的展示范围，以便在开发中我们可以根据一个组件而不断变换其中的内容和结构。</p><h1 id="32-vue3中如何获取refs，dom对象的方式？"><a href="#32-vue3中如何获取refs，dom对象的方式？" class="headerlink" title="32.vue3中如何获取refs，dom对象的方式？"></a>32.vue3中如何获取refs，dom对象的方式？</h1><p>Vue3中无法使用this.$refs的方式获取ref的DOM实例</p><p>Vue3提供了getCurrentInstance函数，此函数能返回当前组件的实例对象，也就是当前vue这个实例对象。</p><p>通过打印getCurrentInstance获取的对象就可以看见此对象包含页面中的refs。</p><h1 id="33-vue3中生命周期的和vue2中的区别？"><a href="#33-vue3中生命周期的和vue2中的区别？" class="headerlink" title="33.vue3中生命周期的和vue2中的区别？"></a>33.vue3中生命周期的和vue2中的区别？</h1><p>vue2常用生命周期：</p><p>创建前：beforeCreate() 只有一些实例本身的事件和生命周期函数</p><p>创建后：Created() 是最早使用data和methods中数据的钩子函数</p><p>挂载前：beforeMount() 指令已经解析完毕，内存中已经生成dom树</p><p>挂载后：Mounted() dom渲染完毕页面和内存的数据已经同步</p><p>更新前：beforeUptate() 当data的数据发生改变会执行这个钩子，内存中的数据是新的，页面是旧的</p><p>更新后：Updated() 内存和页面都是新的</p><p>销毁前：beforeDestroy() 即将销毁data和methods中的数据此时还是可以使用的，可以做一些释放内存的操作</p><p>销毁后：Destroyed() 已经销毁完毕</p><p>vue3生命周期做出了一些改动</p><p>前面的是vue2的后面是vue3</p><p>beforeCreate  -&gt; setup() 开始创建组件之前，创建的是data和method</p><p>created    -&gt; setup()</p><p>beforeMount  -&gt; onBeforeMount 组件挂载到节点上之前执行的函数。</p><p>mounted    -&gt; onMounted 组件挂载完成后执行的函数</p><p>beforeUpdate  -&gt; onBeforeUpdate 组件更新之前执行的函数。</p><p>updated    -&gt; onUpdated 组件更新完成之后执行的函数。</p><p>beforeDestroy -&gt; onBeforeUnmount 组件挂载到节点上之前执行的函数。</p><h1 id="34-说说vue中的diff算法？"><a href="#34-说说vue中的diff算法？" class="headerlink" title="34.说说vue中的diff算法？"></a>34.说说vue中的diff算法？</h1><p>diff算法 当data发生改变 会根据新的数据生成一个新的虚拟dom ，新的虚拟dom和旧的虚拟dom进行对比，这个对比的过程就是diff算法。</p><p>Vue2 是全量 Diff（当数据发生变化，它就会新生成一个DOM树，并和之前的DOM树进行比较，找到不同的节点然后更新。）；Vue3 是静态标记 + 非全量 Diff（Vue 3在创建虚拟DOM树的时候，会根据DOM中的内容会不会发生变化，添加一个静态标记。之后在与上次虚拟节点进行对比的时候，就只会对比这些带有静态标记的节点。）</p><p>使用最长递增子序列优化对比流程，可以最大程度的减少 DOM 的移动，达到最少的 DOM 操作</p><h1 id="35-说说-Vue-中-CSS-scoped-的原理？"><a href="#35-说说-Vue-中-CSS-scoped-的原理？" class="headerlink" title="35.说说 Vue 中 CSS scoped 的原理？"></a>35.说说 Vue 中 CSS scoped 的原理？</h1><p>scoped 属性是 style 标签上的一个特殊属性（布尔值）。表示当前style 里的样式只属于当前模块。（作用域、私有化的思想）保证css的作用域不会变成全局 而被其它模块的css污染。</p><p>在vue中引入了scoped这个概念，scoped的设计思想就是让当前组件的样式不会修改到其它地方的样式，使用了data-v-hash的方式来使css有了它对应模块的标识，这样写css的时候不需要加太多额外的选择器，方便很多。</p><h1 id="36-vue3中怎么设置全局变量？"><a href="#36-vue3中怎么设置全局变量？" class="headerlink" title="36.vue3中怎么设置全局变量？"></a>36.vue3中怎么设置全局变量？</h1><p>首先在main.js里写一个我们要定义的全局变量</p><p>app.config.globalProperties.$key = “内容”;// 定义全局变量</p><p>现在在页面里需要使用这个变量，只需要从vue中引入getCurrentInstance即可</p><p>import {getCurrentInstance} from ‘vue’;</p><p> setup(){</p><p>  const { proxy } = getCurrentInstance();</p><p>  console.log(proxy.$key);</p><p> }</p><h1 id="37-Vue中给对象添加新属性时，界面不刷新怎么办"><a href="#37-Vue中给对象添加新属性时，界面不刷新怎么办" class="headerlink" title="37.Vue中给对象添加新属性时，界面不刷新怎么办?"></a>37.Vue中给对象添加新属性时，界面不刷新怎么办?</h1><p>vue2的响应式原理使用的是对象代理去实现的,对象代理中有一个get和set方法,当我们访问对象的时候就会触发get方法,当我们对对象中的值进行修改时会触发set方法。但是当我们给对象添加一个新的属性时对象代理是检测不到的,所以就会出现直接给对象添加属性响应式不生效的问题。</p><p>所以在vue中可以使用this.$set(对象名,‘属性名’,属性值)的方法去给对象添加属性,或者使用Vue.set(对象名,‘属性名’,属性值)的方法进行添加,添加之后的属性就带有响应式了</p><h1 id="38-谈谈对Vue中双向绑定的理解？"><a href="#38-谈谈对Vue中双向绑定的理解？" class="headerlink" title="38.谈谈对Vue中双向绑定的理解？"></a>38.谈谈对Vue中双向绑定的理解？</h1><p>Vue.js 是采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty()来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。主要分为以下几个步骤：</p><p>需要observe的数据对象进行递归遍历，包括子属性对象的属性，都加上setter和getter这样的话，给这个对象的某个值赋值，就会触发setter，那么就能监听到了数据变化</p><p>compile解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图</p><p>Watcher订阅者是Observer和Compile之间通信的桥梁，主要做的事情是: ①在自身实例化时往属性订阅器(dep)里面添加自己 ②自身必须有一个update()方法 ③待属性变动dep.notice()通知时，能调用自身的update()方法，并触发Compile中绑定的回调，则功成身退。</p><p>MVVM作为数据绑定的入口，整合Observer、Compile和Watcher三者，通过Observer来监听自己的model数据变化，通过Compile来解析编译模板指令，最终利用Watcher搭起Observer和Compile之间的通信桥梁，达到数据变化 -&gt; 视图更新；视图交互变化(input) -&gt; 数据model变更的双向绑定效果。</p><h1 id="39-为什么vue2和vue3语法不可以混用？"><a href="#39-为什么vue2和vue3语法不可以混用？" class="headerlink" title="39.为什么vue2和vue3语法不可以混用？"></a>39.为什么vue2和vue3语法不可以混用？</h1><p>Vue 2和Vue 3在设计上有一些重大区别，因此它们的语法和用法也有很大的不同。主要的区别有以下几点：</p><p>1.模板编译方式：Vue 2使用基于字符串的模板编译，而Vue 3则采用了基于函数的模板编译方式。</p><p>2.响应式系统：Vue 3中通过Proxy实现了更加高效的响应式系统，与Vue 2中的Object.defineProperty有很大不同。</p><p>3.组件注册方式：Vue 3中使用了新的API来注册组件，如<code>createApp</code>和<code>defineComponent</code>，而Vue 2中则是通过<code>Vue.component</code>等全局API来注册组件。</p><p>由于这些重大区别，Vue 2和Vue 3的语法和用法也有很大的不同。例如，在Vue 3中，使用v-bind指令绑定属性时需要加上冒号（:），而在Vue 2中则不需要。同时，Vue 3中的生命周期钩子函数也发生了变化。如果混用Vue 2和Vue 3的语法，会导致代码无法正常工作或者出现意外的错误，因此不建议混用两个版本的语法。</p><h1 id="40-vue3中setup函数如何进行组件通讯？"><a href="#40-vue3中setup函数如何进行组件通讯？" class="headerlink" title="40.vue3中setup函数如何进行组件通讯？"></a>40.vue3中setup函数如何进行组件通讯？</h1><p><strong><em>\</em>Props方式**</strong>是Vue中最常见的一种父传子的一种方式，我们将数据以及对数据的操作定义在父组件，子组件仅做列表的一个渲染，子组件只需要对父组件传递的值进行渲染即可</p><p><strong><em>\</em>emit方式**</strong>也是Vue中最常见的组件通信方式，该方式用于子传父，在子组件中点击【添加】按钮后，emit一个自定义事件，并将添加的值作为参数传递。在父组件中只需要监听子组件自定义的事件，然后执行对应的添加操作</p><p><strong><em>\</em>provide和inject**</strong>是Vue中提供的一对API，该API可以实现父组件向子组件传递数据，无论层级有多深，都可以通过这对API实现。</p><p><strong><em>\</em>Vuex 和 Pinia**</strong> 是 Vue 3 中的状态管理工具，使用这两个工具可以轻松实现组件通信。</p><p><strong><em>\</em>Refs**</strong>有时候想访问 r e f s 绑 定 的 组 件 的 属 性 或 者 方 法 ， 我 们 会 使 用 refs绑定的组件的属性或者方法，我们会使用 refs绑定的组件的属性或者方法，我们会使用refs。但是Vue3不同于Vue2，在 Vue3的setup中我们是无法访问到this的，所以我们需要借助一个方法，那就是getCurrentInstance，该方法返回了当前的实例对象。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;持续更新中…&quot;&gt;&lt;a href=&quot;#持续更新中…&quot; class=&quot;headerlink&quot; title=&quot;持续更新中….&quot;&gt;&lt;/a&gt;持续更新中….&lt;/h1&gt;&lt;h1 id=&quot;01v-show和v-if指令的共同点和不同点&quot;&gt;&lt;a href=&quot;#01v-show和v-i</summary>
      
    
    
    
    
    <category term="面试题" scheme="https://admin741-cl.github.io/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>vue3笔记（更新中）</title>
    <link href="https://admin741-cl.github.io/posts/f0ec.html"/>
    <id>https://admin741-cl.github.io/posts/f0ec.html</id>
    <published>2021-10-19T07:16:45.000Z</published>
    <updated>2023-06-17T02:33:40.025Z</updated>
    
    <content type="html"><![CDATA[<h1 id="vite-的基本使用"><a href="#vite-的基本使用" class="headerlink" title="vite 的基本使用"></a>vite 的基本使用</h1><p>首先，我们安装一下vite工具：</p><ul><li>npm install vite –g # 全局安装</li><li>npm install vite –D # 局部安装</li></ul><p>​    如果报错自行百度</p><h2 id="用vite创建项目"><a href="#用vite创建项目" class="headerlink" title="用vite创建项目"></a>用vite创建项目</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm init vite 项目名字</span><br><span class="line">会提示create-vite没有安装 输入y进行安装</span><br><span class="line">npm info vite version 查看vite版本</span><br></pre></td></tr></table></figure><h2 id="vite配置端口"><a href="#vite配置端口" class="headerlink" title="vite配置端口"></a>vite配置端口</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">在vite.<span class="property">config</span>.<span class="property">js</span>中去配置</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineConfig</span>(&#123;</span><br><span class="line">  <span class="attr">plugins</span>: [<span class="title function_">vue</span>()],</span><br><span class="line">  <span class="attr">server</span>: &#123;</span><br><span class="line">    <span class="attr">host</span>: <span class="string">&#x27;0.0.0.0&#x27;</span>,<span class="comment">//ip地址 运行后就是你自己的本机ip</span></span><br><span class="line">    <span class="attr">port</span>: <span class="number">6688</span>, <span class="comment">// 设置服务启动端口号</span></span><br><span class="line">    <span class="attr">open</span>: <span class="literal">true</span>, <span class="comment">// 设置服务启动时是否自动打开浏览器</span></span><br><span class="line">    <span class="attr">https</span>: <span class="literal">false</span>,<span class="comment">// 是否开启 https</span></span><br><span class="line">    <span class="attr">strictPort</span>:<span class="literal">true</span>,<span class="comment">//strictPort：设置为true，若端口已被占用则会直接退出，反之为false，尝试下一个端口</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="vue3使用keep-alive"><a href="#vue3使用keep-alive" class="headerlink" title="vue3使用keep-alive"></a>vue3使用keep-alive</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">在app.vue中可以使用这种方式,进行所有数据缓存</span><br><span class="line">&lt;router-view v-slot=&quot;&#123; Component, route &#125;&quot;&gt;</span><br><span class="line">    &lt;keep-alive &gt;</span><br><span class="line">    &lt;!-- &lt;keep-alive :include=&quot;[&#x27;cc&#x27;]&quot;&gt;可以指定那个页面进行缓存 --&gt;</span><br><span class="line">        &lt;component :is=&quot;Component&quot; /&gt;</span><br><span class="line">    &lt;/keep-alive&gt;</span><br><span class="line">&lt;/router-view&gt;</span><br><span class="line">activeated()&#123;&#125;</span><br><span class="line">    activated：当组件被激活时调用，即从缓存中取出组件时调用。</span><br><span class="line">    deactivated：当组件被停用时调用，即组件被缓存时调用。</span><br></pre></td></tr></table></figure><h1 id="element-plus"><a href="#element-plus" class="headerlink" title="element plus"></a>element plus</h1><h2 id="表格的文字溢出"><a href="#表格的文字溢出" class="headerlink" title="表格的文字溢出"></a>表格的文字溢出</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&lt;el-table-column</span><br><span class="line">     prop=&quot;yichu&quot;</span><br><span class="line">     label=&quot;文字溢出&quot;</span><br><span class="line">     width=&quot;220&quot;</span><br><span class="line">     :show-overflow-tooltip=&quot;true&quot;</span><br><span class="line">   &gt;</span><br><span class="line">     &lt;!-- 文字溢出效果 可设置多少行 --&gt;</span><br><span class="line">     &lt;!-- &lt;template #default=&quot;scope&quot;&gt;</span><br><span class="line">       &lt;el-tooltip</span><br><span class="line">         class=&quot;box-item&quot;</span><br><span class="line">         effect=&quot;dark&quot;</span><br><span class="line">         :content=&quot;scope.row.dizhi&quot;</span><br><span class="line">         placement=&quot;top-start&quot;</span><br><span class="line">       &gt;</span><br><span class="line">         &lt;div</span><br><span class="line">           style=&quot;</span><br><span class="line">             overflow: hidden;</span><br><span class="line">             display: -webkit-box;</span><br><span class="line">             text-overflow: ellipsis;</span><br><span class="line">             -webkit-line-clamp: 1;</span><br><span class="line">             -webkit-box-orient: vertical;</span><br><span class="line">             white-space: normal;</span><br><span class="line">           &quot;</span><br><span class="line">         &gt;</span><br><span class="line">           &#123;&#123; scope.row.dizhi &#125;&#125;</span><br><span class="line">         &lt;/div&gt;</span><br><span class="line">         &#123;&#123; scope.row.dizhi &#125;&#125;</span><br><span class="line">       &lt;/el-tooltip&gt;</span><br><span class="line">     &lt;/template&gt; --&gt;</span><br><span class="line"> &lt;/el-table-column&gt;</span><br></pre></td></tr></table></figure><p>使用中文</p><h1 id="vue3使用pinia"><a href="#vue3使用pinia" class="headerlink" title="vue3使用pinia"></a>vue3使用pinia</h1><p>安装注册看：<a href="https://pinia.vuejs.org/zh/introduction.html">https://pinia.vuejs.org/zh/introduction.html</a></p><h2 id="状态定义"><a href="#状态定义" class="headerlink" title="状态定义"></a><strong>状态定义</strong></h2><p>​    可以通过 defineStore 来简单创建一个存储管理;</p><p>​    <strong>第一个参数</strong>：相当于为容器起一个名字。注意：这里的<strong>名字必须唯一，不能重复</strong>。</p><p>​    <strong>第二个参数</strong>：可以简单理解为一个配置对象，对容器仓库的配置说明</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; defineStore &#125; <span class="keyword">from</span> <span class="string">&#x27;pinia&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// useStore 可以是 useUser、useCart 之类的任何东西</span></span><br><span class="line"><span class="comment">// 第一个参数是应用程序中 store 的唯一 id</span></span><br><span class="line"><span class="comment">// option store</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> useStore = <span class="title function_">defineStore</span>(<span class="string">&#x27;admin&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">state</span>: <span class="function">() =&gt;</span> &#123; <span class="comment">//为什么写成函数 防止数据污染</span></span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">age</span>: <span class="number">18</span> &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">getters</span>: &#123;<span class="comment">//相当于computed 计算属性</span></span><br><span class="line">    <span class="title function_">gettersAge</span>(<span class="params">state</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> state.<span class="property">age</span> + <span class="number">5</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">actions</span>: &#123; <span class="comment">//相当于methods</span></span><br><span class="line">    <span class="title function_">addAge</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="comment">//this指向的是对应的store仓库 </span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">age</span>++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//setup store  写法</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> useCounterStort = <span class="title function_">defineStore</span>(<span class="string">&#x27;main&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> counter = <span class="title function_">ref</span>(<span class="number">10</span>)<span class="comment">//state</span></span><br><span class="line">  <span class="keyword">const</span> gettersCounter = <span class="title function_">computed</span>(<span class="function">() =&gt;</span> &#123;<span class="comment">//getters</span></span><br><span class="line">    <span class="keyword">return</span> counter.<span class="property">value</span> + <span class="number">6</span></span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">addCounter</span>(<span class="params"></span>) &#123;<span class="comment">//actions</span></span><br><span class="line">    counter.<span class="property">value</span>++</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    counter, gettersCounter, addCounter</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><p>在页面上的基本使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;&#123;&#123; store.age &#125;&#125;&lt;/div&gt;</span><br><span class="line">  &lt;div&gt;&#123;&#123; store.gettersAge &#125;&#125;&lt;/div&gt;</span><br><span class="line">  &lt;el-button type=&quot;&quot; @click=&quot;store.addAge&quot;&gt;store&lt;/el-button&gt;</span><br><span class="line">  &lt;br/&gt;</span><br><span class="line">  &lt;div&gt;&#123;&#123; counter &#125;&#125;&lt;/div&gt;</span><br><span class="line">  &lt;div&gt;&#123;&#123; gettersCounter &#125;&#125;&lt;/div&gt;</span><br><span class="line">  &lt;el-button type=&quot;&quot; @click=&quot;counterStore.addCounter&quot;&gt;counterStort&lt;/el-button&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script setup&gt;</span><br><span class="line">import &#123; ref, reactive, onMounted, toRefs, computed &#125; from &quot;vue&quot;;</span><br><span class="line">import &#123; useStore, useCounterStort &#125; from &quot;@/store/index&quot;;</span><br><span class="line">import &#123; storeToRefs &#125; from &#x27;pinia&#x27;//为了从 store 中提取属性时保持其响应性，你需要使用 storeToRefs()  详情看官网</span><br><span class="line"></span><br><span class="line">// 定义一个变量进行接收</span><br><span class="line">const store = useStore();</span><br><span class="line"></span><br><span class="line">const counterStore = useCounterStort();</span><br><span class="line">// 为了方便进行结构赋值 只能结构数据 不能结构方法</span><br><span class="line">const &#123;counter,gettersCounter&#125; = storeToRefs(counterStore);</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped lang=&quot;less&quot;&gt;&lt;/style&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="修改state中的数据"><a href="#修改state中的数据" class="headerlink" title="修改state中的数据"></a>修改state中的数据</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;h2&gt;名字：&#123;&#123; storeAge.name &#125;&#125;&lt;/h2&gt;</span><br><span class="line">  &lt;div&gt;&#123;&#123; storeAge.age &#125;&#125;&lt;/div&gt;</span><br><span class="line">  &lt;div&gt;&#123;&#123; storeAge.gettersAge &#125;&#125;&lt;/div&gt;</span><br><span class="line">  &lt;div&gt;&#123;&#123; storeAge.arr &#125;&#125;&lt;/div&gt;</span><br><span class="line">  &lt;!-- &lt;el-button type=&quot;&quot; @click=&quot;store.addAge&quot;&gt;store&lt;/el-button&gt; --&gt;</span><br><span class="line">  &lt;!-- 使用actions中的函数 --&gt;</span><br><span class="line">  &lt;el-button type=&quot;&quot; @click=&quot;changAge&quot;&gt;修改age&lt;/el-button&gt;</span><br><span class="line"></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script setup&gt;</span><br><span class="line">import &#123; ref, reactive, onMounted, toRefs, computed &#125; from &quot;vue&quot;;</span><br><span class="line">import &#123; useStore, useCounterStort &#125; from &quot;@/store/index&quot;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 定义一个变量进行接收</span><br><span class="line">const storeAge = useStore();</span><br><span class="line"></span><br><span class="line">//修改state的状态</span><br><span class="line"></span><br><span class="line">const changAge = ()=&gt;&#123;</span><br><span class="line">  // 方法一 直接修改</span><br><span class="line">  // storeAge.age++ </span><br><span class="line">  // 方法二 批量进行修改  $patch(对象)是一个函数</span><br><span class="line">  // storeAge.$patch(&#123;//多数据建议使用这种</span><br><span class="line">  //   age:88,</span><br><span class="line">  //   name:&#x27;老王八&#x27;,</span><br><span class="line">  //   arr:[...storeAge.arr,77]</span><br><span class="line">  // &#125;)</span><br><span class="line">  // 方式三 针对于数组数据进行修改$patch(函数) 强烈推荐</span><br><span class="line">  // state 就是 store中定义的state</span><br><span class="line">  storeAge.$patch((state)=&gt;&#123;</span><br><span class="line">    state.name=&#x27;666&#x27;</span><br><span class="line">    state.arr.push(7)</span><br><span class="line">  &#125;)</span><br><span class="line">  //方法四：在逻辑比较复杂的时候，封装到actions的函数在store文件中的index.js</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped lang=&quot;less&quot;&gt;&lt;/style&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="getters使用"><a href="#getters使用" class="headerlink" title="getters使用"></a>getters使用</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; defineStore &#125; <span class="keyword">from</span> <span class="string">&#x27;pinia&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; computed, ref &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// useStore 可以是 useUser、useCart 之类的任何东西</span></span><br><span class="line"><span class="comment">// 第一个参数是应用程序中 store 的唯一 id</span></span><br><span class="line"><span class="comment">// option store</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> useStore = <span class="title function_">defineStore</span>(<span class="string">&#x27;admin&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">state</span>: <span class="function">() =&gt;</span> &#123; <span class="comment">//为什么写成函数 防止数据污染</span></span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">age</span>: <span class="number">18</span>, <span class="attr">name</span>: <span class="string">&quot;胡二狗&quot;</span>, <span class="attr">arr</span>: [<span class="number">1</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">4</span>] &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">getters</span>: &#123;<span class="comment">//相当于computed 计算属性</span></span><br><span class="line">    <span class="comment">// gettersAge: (state) =&gt; &#123;</span></span><br><span class="line">    <span class="comment">//   return state.age + 5</span></span><br><span class="line">    <span class="comment">// &#125;,</span></span><br><span class="line">    <span class="comment">// gettersAge() &#123;// 不推荐 可以通过this直接进行访问 this指向的state实例</span></span><br><span class="line">    <span class="comment">//   return this.age + 5</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 访问其他的getters，可以使用this 不能使用箭头函数！</span></span><br><span class="line">    <span class="comment">// gettersName(state) &#123;</span></span><br><span class="line">    <span class="comment">//   return this.gettersAge +state.name</span></span><br><span class="line">    <span class="comment">// &#125;,</span></span><br><span class="line">    <span class="comment">// 当计算的值有外界来决定的时候 向getters传递参数的时候,返回函数的方式接收参数，和普通的函数一样，没有缓存的作用 一般用不着这写法</span></span><br><span class="line">    <span class="attr">gettersAge</span>: <span class="function">(<span class="params">state</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="function">(<span class="params">data_a</span>)=&gt;</span>state.<span class="property">age</span>+data_a</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 在页面上：&lt;div&gt;&#123;&#123; storeAge.gettersAge(10) &#125;&#125;&lt;/div&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 访问他store中的getters中的数据</span></span><br><span class="line">    <span class="title function_">gettersAge</span>(<span class="params">state</span>)&#123;</span><br><span class="line">      <span class="keyword">const</span> counterStort = <span class="title function_">useCounterStort</span>()</span><br><span class="line">      <span class="keyword">return</span> state.<span class="property">age</span>+counterStort.<span class="property">gettersCounter</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">actions</span>: &#123; <span class="comment">//相当于methods</span></span><br><span class="line">    <span class="title function_">addAge</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="comment">//this指向的是对应的store仓库 </span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">age</span>++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//setup store</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> useCounterStort = <span class="title function_">defineStore</span>(<span class="string">&#x27;main&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> counter = <span class="title function_">ref</span>(<span class="number">10</span>)<span class="comment">//state</span></span><br><span class="line">  <span class="keyword">const</span> gettersCounter = <span class="title function_">computed</span>(<span class="function">() =&gt;</span> &#123;<span class="comment">//getters</span></span><br><span class="line">    <span class="keyword">return</span> counter.<span class="property">value</span> + <span class="number">6</span></span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">addCounter</span>(<span class="params"></span>) &#123;<span class="comment">//actions</span></span><br><span class="line">    counter.<span class="property">value</span>++</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    counter, gettersCounter, addCounter</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="actions使用"><a href="#actions使用" class="headerlink" title="actions使用"></a>actions使用</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">actions</span>: &#123; <span class="comment">//相当于methods 不能只用箭头函数因为this</span></span><br><span class="line">  <span class="title function_">addAge</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">//this指向的是对应的store仓库 </span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span>++</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">async</span> <span class="title function_">getList</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 两种请求方法</span></span><br><span class="line">    <span class="comment">// axios.get(&quot;https://www.fastmock.site/mock/bf1fcb3c2e2945669c2c8dOecb8009b8/api/getGoodsList&quot;).then((res) =&gt; &#123;</span></span><br><span class="line">    <span class="comment">//   console.log(res);</span></span><br><span class="line">    <span class="comment">// &#125;)</span></span><br><span class="line">    <span class="comment">// let res = await axios.get(&quot;https://www.fastmock.site/mock/bf1fcb3c2e2945669c2c8dOecb8009b8/api/getGoodsList&quot;)</span></span><br><span class="line">    <span class="comment">// console.log(res);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//访问其他store中actions</span></span><br><span class="line">    <span class="keyword">const</span> counterStort = <span class="title function_">useCounterStort</span>()</span><br><span class="line">    <span class="keyword">if</span> (counterStort.<span class="title function_">login</span>()) &#123;</span><br><span class="line">      <span class="keyword">let</span> res = <span class="keyword">await</span> axios.<span class="title function_">get</span>(<span class="string">&quot;https://www.fastmock.site/mock/bf1fcb3c2e2945669c2c8dOecb8009b8/api/getGoodsList&quot;</span>)</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(res);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="pinia和vuex的比较"><a href="#pinia和vuex的比较" class="headerlink" title="pinia和vuex的比较"></a>pinia和vuex的比较</h2><p>pinia最重要的是，搭配 TypeScript 一起使用时有非常可靠的类型推断支持pinia 没有 mutations，而actions的使用不同，在actions中可以处理同步也可以处理异步，getters的使用是一致的,state与vue2中data是相似的<br>pinia 没有总出口全是模块化，需要定义模块名称，当多个模块需要协作的时候需要引入多个模块，vuex是有总入口的，在使用模块化的时候不需要引入多个模块<br>pinia 在修改状态的时候不需要通过其他api，vuex需要通过commit，dispatch去修改所以在语法上比vuex更容易理解和使用，灵活<br>pinia就是更好的vuex，建议在项目中可以直接使用它了，尤其是使用了TypeScript的项目。<br>vue3+pinia+ts</p><h1 id="vue3使用进度条"><a href="#vue3使用进度条" class="headerlink" title="vue3使用进度条"></a>vue3使用进度条</h1><p>一、安装 <a href="https://so.csdn.net/so/search?q=NProgress&amp;spm=1001.2101.3001.7020">NProgress</a><br>    <strong>npm install nprogress —save</strong></p><p>如果使用 ts，还需安装 @types/nprogress<br>    <strong>npm i —save-dev @types/nprogress</strong></p><p> 二、在 router/index.ts 中引入 nprogress</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// router/index.ts</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">NProgress</span> <span class="keyword">from</span> <span class="string">&#x27;nprogress&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;nprogress/nprogress.css&#x27;</span></span><br></pre></td></tr></table></figure><p> 三、<a href="https://so.csdn.net/so/search?q=路由守卫&amp;spm=1001.2101.3001.7020">路由守卫</a>监听路由变化</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// router/index.ts</span></span><br><span class="line"><span class="keyword">import</span> &#123; createRouter, createWebHashHistory, <span class="title class_">RouteRecordRaw</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">NProgress</span> <span class="keyword">from</span> <span class="string">&#x27;nprogress&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;nprogress/nprogress.css&#x27;</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> <span class="attr">routes</span>: <span class="title class_">Array</span>&lt;<span class="title class_">RouteRecordRaw</span>&gt; = [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;home&#x27;</span>,</span><br><span class="line">    <span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;@/layout/MyHome.vue&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> router = <span class="title function_">createRouter</span>(&#123;</span><br><span class="line">  <span class="attr">history</span>: <span class="title function_">createWebHashHistory</span>(),</span><br><span class="line">  routes</span><br><span class="line">&#125;)</span><br><span class="line"> </span><br><span class="line">router.<span class="title function_">beforeEach</span>(<span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="title class_">NProgress</span>.<span class="title function_">start</span>() <span class="comment">// 进度条开始</span></span><br><span class="line">  <span class="title function_">next</span>()</span><br><span class="line">&#125;)</span><br><span class="line"> </span><br><span class="line">router.<span class="title function_">afterEach</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="title class_">NProgress</span>.<span class="title function_">done</span>() <span class="comment">// 进度条结束</span></span><br><span class="line">&#125;)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router</span><br></pre></td></tr></table></figure><p>四、进度条属性配置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// router/index.ts</span></span><br><span class="line"> </span><br><span class="line"><span class="title class_">NProgress</span>.<span class="title function_">configure</span>(&#123;</span><br><span class="line">  <span class="attr">easing</span>: <span class="string">&#x27;ease&#x27;</span>, <span class="comment">// 动画方式</span></span><br><span class="line">  <span class="attr">speed</span>: <span class="number">500</span>, <span class="comment">// 递增进度条的速度</span></span><br><span class="line">  <span class="attr">showSpinner</span>: <span class="literal">false</span>, <span class="comment">// 是否显示加载 icon</span></span><br><span class="line">  <span class="attr">trickleSpeed</span>: <span class="number">200</span>, <span class="comment">// 自动递增间隔</span></span><br><span class="line">  <span class="attr">minimum</span>: <span class="number">0.3</span> <span class="comment">// 初始化时的最小百分比</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>五、修改进度条颜色  在 App.vue 文件中修改进度条样式</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#nprogress</span> <span class="selector-class">.bar</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: red <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="百度地图的使用"><a href="#百度地图的使用" class="headerlink" title="百度地图的使用"></a>百度地图的使用</h1><blockquote><p>百度地图开放Api:  <a href="https://lbsyun.baidu.com/index.php?title=%E9%A6%96%E9%A1%B5">https://lbsyun.baidu.com/index.php?title=%E9%A6%96%E9%A1%B5</a></p><p>​    登录账号 点击控制台进入 注册完成信息</p><p><img src="C:\Users\19578\Desktop\vue3\images\百度地图01.png" alt=""></p><p><strong>申请秘钥：</strong>点击我的应用管理-&gt;我的应用-&gt;创建应用-&gt;浏览器端</p><p><img src="./images/百度地图02.png" alt=""></p><p>JSAPi百度地图文档： </p><p> <a href="https://lbsyun.baidu.com/index.php?title=jspopularGL/guide/getkey【JavaScript">https://lbsyun.baidu.com/index.php?title=jspopularGL/guide/getkey【JavaScript</a> API GL】</p><p><a href="https://lbsyun.baidu.com/jsdemo.htm#aCreateMap【百度开放平台示例中心】（推荐）">https://lbsyun.baidu.com/jsdemo.htm#aCreateMap【百度开放平台示例中心】（推荐）</a></p><p>申请百度地图APi的密钥：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;//api.map.baidu.com/api?type=webgl&amp;v=1.0&amp;ak=你的密钥&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></blockquote><h1 id="获取当前天气和位置"><a href="#获取当前天气和位置" class="headerlink" title="获取当前天气和位置"></a>获取当前天气和位置</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="attr">init</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="variable constant_">AK</span> = <span class="string">&quot;EAG3waLsHfeWew8ZjxlvQgvxuqXY5moB&quot;</span>; <span class="comment">//AK</span></span><br><span class="line">        <span class="keyword">const</span> <span class="title class_">BMap</span>_URL =</span><br><span class="line">            <span class="string">&quot;https://api.map.baidu.com/api?v=2.0&amp;ak=&quot;</span> +</span><br><span class="line">            <span class="variable constant_">AK</span> +</span><br><span class="line">            <span class="string">&quot;&amp;s=1&amp;callback=onBMapCallback&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// 如果已加载直接返回</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="title class_">BMap</span> !== <span class="string">&quot;undefined&quot;</span>) &#123;</span><br><span class="line">                <span class="title function_">resolve</span>(<span class="title class_">BMap</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 百度地图异步加载回调处理</span></span><br><span class="line">            <span class="variable language_">window</span>.<span class="property">onBMapCallback</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">                <span class="title function_">resolve</span>(<span class="title class_">BMap</span>);</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 插入script脚本</span></span><br><span class="line">            <span class="keyword">let</span> scriptNode = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;script&quot;</span>);</span><br><span class="line">            <span class="comment">// scriptNode.setAttribute(type, &#x27;text/javascript&#x27;);</span></span><br><span class="line">            scriptNode.<span class="title function_">setAttribute</span>(<span class="string">&quot;src&quot;</span>, <span class="title class_">BMap</span>_URL);</span><br><span class="line">            <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(scriptNode);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import &#123; ref, reactive, onMounted &#125; from &quot;vue&quot;;</span><br><span class="line">import myBMap from &quot;./bmap.js&quot;; // 引入刚才创建的bmap.js文件</span><br><span class="line">import axios from &quot;axios&quot;;</span><br><span class="line">export default &#123;</span><br><span class="line">  //props: &#123;&#125;,</span><br><span class="line">  components: &#123;&#125;,</span><br><span class="line">  setup() &#123;</span><br><span class="line">    let weather = ref(&quot;&quot;); // 天气</span><br><span class="line">    let temperature = ref(&quot;&quot;); // 温度</span><br><span class="line"></span><br><span class="line">    // 结合浏览器获取城市位置(我只需要获取省和市,具体看个人需求)</span><br><span class="line">    const getCity = () =&gt; &#123;</span><br><span class="line">      // const BMap = (window as any).BMapGL;</span><br><span class="line">      myBMap.init().then((BMap) =&gt; &#123;</span><br><span class="line">        let myCity = new BMap.LocalCity();</span><br><span class="line">        myCity.get(</span><br><span class="line">          (result) =&gt; &#123;</span><br><span class="line">            let geoc = new BMap.Geocoder();</span><br><span class="line">            geoc.getLocation(result.center, (res) =&gt; &#123;</span><br><span class="line">              // 位置信息</span><br><span class="line">              console.log(&quot;位置&quot;, res.addressComponents);</span><br><span class="line"></span><br><span class="line">              getLocationId(</span><br><span class="line">                res.addressComponents.province,</span><br><span class="line">                res.addressComponents.city</span><br><span class="line">              );</span><br><span class="line">            &#125;);</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123; enableHighAccuracy: true &#125;</span><br><span class="line">        );</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    // 获取城市id</span><br><span class="line">    const getLocationId = (province, city) =&gt; &#123;</span><br><span class="line">      axios(&#123;</span><br><span class="line">        method: &quot;get&quot;,</span><br><span class="line">        url:</span><br><span class="line">          &quot;https://geoapi.qweather.com/v2/city/lookup?key=56a14978f76747a8897384f7bef56c20&amp;adm=&quot; +</span><br><span class="line">          province +</span><br><span class="line">          &quot;&amp;location=&quot; +</span><br><span class="line">          city,</span><br><span class="line">      &#125;).then((res) =&gt; &#123;</span><br><span class="line">        getWeather(res.data.location[0].id);</span><br><span class="line">        console.log(res.data.location[0]);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    // 获取天气</span><br><span class="line">    const getWeather = (id) =&gt; &#123;</span><br><span class="line">      axios(&#123;</span><br><span class="line">        method: &quot;get&quot;,</span><br><span class="line">        url:</span><br><span class="line">          &quot;https://devapi.qweather.com/v7/weather/now?key=56a14978f76747a8897384f7bef56c20&amp;location=&quot; +</span><br><span class="line">          id,</span><br><span class="line">      &#125;).then((res) =&gt; &#123;</span><br><span class="line">        temperature.value = res.data.now.temp;</span><br><span class="line">        weather.value = res.data.now.text;</span><br><span class="line">        console.log(res.data, 1213);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    onMounted(async () =&gt; &#123;</span><br><span class="line">      getCity(); // 获取城市</span><br><span class="line">      // var result = await axios.get(</span><br><span class="line">      //   &quot;http://wthrcdn.etouch.cn/weather_mini?city=&quot; + &quot;杭州&quot;</span><br><span class="line">      // );</span><br><span class="line">      // console.log(result.data.data.forecast);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    return &#123;</span><br><span class="line">      getWeather,</span><br><span class="line">      getLocationId,</span><br><span class="line">      getCity,</span><br><span class="line">      weather,</span><br><span class="line">      temperature,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped lang=&quot;less&quot;&gt;&lt;/style&gt;</span><br></pre></td></tr></table></figure><h1 id="vue中使用echarts"><a href="#vue中使用echarts" class="headerlink" title="vue中使用echarts"></a>vue中使用echarts</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnpm install echarts --save  </span><br></pre></td></tr></table></figure><h2 id="全局引入-（在app-vue中引入）"><a href="#全局引入-（在app-vue中引入）" class="headerlink" title="全局引入 （在app.vue中引入）"></a>全局引入 （在app.vue中引入）</h2><p><strong>不常用</strong>    </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">import * as echarts from &quot;echarts&quot;</span><br><span class="line">import &#123; provide &#125; from &quot;vue&quot;;</span><br><span class="line">         provide(&quot;echarts&quot;,echarts)//第一个参数：要传播的名字第二个参数要传播的数据</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">   在其他组件内</span><br><span class="line">&lt;template&gt;</span><br><span class="line">&lt;div id=&quot;echartone&quot;&gt;&lt;/div&gt;//必须有宽高</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script setup&gt;</span><br><span class="line">         import &#123; inject,onMounted,reactive &#125; from &quot;vue&quot;;</span><br><span class="line">         </span><br><span class="line">let $echarts=inject(&quot;echarts&quot;)</span><br><span class="line">         let data=reactive(&#123;&#125;)</span><br><span class="line">         let yAxis=reactive([])</span><br><span class="line">         let xAxis=reactive([])</span><br><span class="line">onMounted(()=&gt;&#123;</span><br><span class="line">            var &#123; data &#125; = await axios.get(``);//获取数据</span><br><span class="line">            xAxis=data.map(v=v.title)</span><br><span class="line">         yAxis=data.map(v=v.num)</span><br><span class="line">   let myChart=$echarts.init(document.getElementById(&#x27;echartone&#x27;))</span><br><span class="line">            </span><br><span class="line">           myChart.setOption(&#123;</span><br><span class="line">               xAxis: &#123;</span><br><span class="line">                   type: &quot;value&quot;,</span><br><span class="line">               &#125;,</span><br><span class="line">               yAxis: &#123; type: &quot;category&quot;,data:xdata &#125;,</span><br><span class="line">               series:[</span><br><span class="line">                   &#123;</span><br><span class="line">                       type: &quot;bar&quot;,</span><br><span class="line">                       data:ydata</span><br><span class="line">                   &#125;,</span><br><span class="line">               ]</span><br><span class="line">           &#125;);</span><br><span class="line">&#125;)</span><br><span class="line">     &lt;/script&gt;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="局部引入（在所需页面引入）"><a href="#局部引入（在所需页面引入）" class="headerlink" title="局部引入（在所需页面引入）"></a>局部引入（在所需页面引入）</h2><p><strong>个人推荐使用</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line">http://t.csdn.cn/rI6MV 案例</span><br><span class="line">在组件页面 template 中创建一个容器，定义一个高宽的 dom 容器</span><br><span class="line">&lt;div id=&quot;myChart&quot; :style=&quot;&#123; width: &#x27;300px&#x27;, height: &#x27;300px&#x27; &#125;&quot;&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  import &#123; defineComponent, toRefs, reactive, onMounted &#125; from &#x27;vue&#x27;</span><br><span class="line">  import * as echarts from &#x27;echarts&#x27;</span><br><span class="line">  </span><br><span class="line">  export default defineComponent(&#123;</span><br><span class="line">    name: &#x27;Histogram&#x27;,</span><br><span class="line">    setup() &#123;</span><br><span class="line">      const state = reactive(&#123;</span><br><span class="line">        option: &#123;</span><br><span class="line">          grid: &#123;</span><br><span class="line">            top: &#x27;4%&#x27;,</span><br><span class="line">            left: &#x27;2%&#x27;,</span><br><span class="line">            right: &#x27;4%&#x27;,</span><br><span class="line">            bottom: &#x27;0%&#x27;,</span><br><span class="line">            containLabel: true,</span><br><span class="line">          &#125;,</span><br><span class="line">          xAxis: [</span><br><span class="line">            &#123;</span><br><span class="line">              type: &#x27;category&#x27;,</span><br><span class="line">              data: [&quot;芳草地国际&quot;,&quot;实验小学&quot;,&quot;白家庄小学&quot;,&quot;外国语小学&quot;,&quot;师范学校附属&quot;,&quot;望京东园&quot;],</span><br><span class="line">              axisTick: &#123;</span><br><span class="line">                alignWithLabel: true,</span><br><span class="line">              &#125;,</span><br><span class="line">            &#125;,</span><br><span class="line">          ],</span><br><span class="line">          yAxis: [</span><br><span class="line">            &#123;</span><br><span class="line">              type: &#x27;value&#x27;,</span><br><span class="line">            &#125;,</span><br><span class="line">          ],</span><br><span class="line">          series: [</span><br><span class="line">            &#123;</span><br><span class="line">              name: &#x27;学校&#x27;,</span><br><span class="line">              type: &#x27;bar&#x27;,</span><br><span class="line">              barWidth: &#x27;40%&#x27;,</span><br><span class="line">              data: [260,680,360,460,150,320],</span><br><span class="line">            &#125;,</span><br><span class="line">          ],</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;)</span><br><span class="line">      const initeCharts = () =&gt; &#123;</span><br><span class="line">        let myChart = echarts.init(document.getElementById(&#x27;myChart&#x27;))</span><br><span class="line">        // 绘制图表</span><br><span class="line">        myChart.setOption(state.option)</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      onMounted(() =&gt; &#123;</span><br><span class="line">        initeCharts()</span><br><span class="line">      &#125;)</span><br><span class="line"></span><br><span class="line">      return &#123;</span><br><span class="line">        ...toRefs(state),</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">第二种方法  能传活数据</span><br><span class="line">&lt;script setup&gt;</span><br><span class="line">import * as echarts from &quot;echarts&quot;;</span><br><span class="line">import &#123; ref, reactive, onMounted, toRefs, computed, onUnmounted &#125; from &quot;vue&quot;;</span><br><span class="line">import &#123; reqReports &#125; from &quot;../axios/Api&quot;;</span><br><span class="line"></span><br><span class="line">const abc = reactive(&#123;</span><br><span class="line">  aa: [],</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">let myEcharts = echarts;</span><br><span class="line">const go = async () =&gt; &#123;</span><br><span class="line">  const &#123; data &#125; = await reqReports();</span><br><span class="line">  abc.aa = data;</span><br><span class="line">  console.log(abc.aa);</span><br><span class="line">  let chart = myEcharts.init(</span><br><span class="line">    document.getElementById(&quot;myEcharts&quot;),</span><br><span class="line">    &quot;purple-passion&quot;</span><br><span class="line">  );</span><br><span class="line">  chart.setOption(&#123;</span><br><span class="line">    title: &#123;</span><br><span class="line">      text: &quot;2021年各月份销售量（单位：件）&quot;,</span><br><span class="line">      left: &quot;center&quot;,</span><br><span class="line">    &#125;,</span><br><span class="line">    xAxis: &#123;</span><br><span class="line">      type: &quot;category&quot;,</span><br><span class="line">      data: [</span><br><span class="line">        &quot;一月&quot;,</span><br><span class="line">        &quot;二月&quot;,</span><br><span class="line">        &quot;三月&quot;,</span><br><span class="line">        &quot;四月&quot;,</span><br><span class="line">        &quot;五月&quot;,</span><br><span class="line">        &quot;六月&quot;,</span><br><span class="line">        &quot;七月&quot;,</span><br><span class="line">        &quot;八月&quot;,</span><br><span class="line">        &quot;九月&quot;,</span><br><span class="line">        &quot;十月&quot;,</span><br><span class="line">        &quot;十一月&quot;,</span><br><span class="line">        &quot;十二月&quot;,</span><br><span class="line">      ],</span><br><span class="line">    &#125;,</span><br><span class="line">    tooltip: &#123;</span><br><span class="line">      trigger: &quot;axis&quot;,</span><br><span class="line">    &#125;,</span><br><span class="line">    yAxis: &#123;</span><br><span class="line">      type: &quot;value&quot;,</span><br><span class="line">    &#125;,</span><br><span class="line">    series: [</span><br><span class="line">      &#123;</span><br><span class="line">        data: [606, 542, 985, 687, 501, 787, 339, 706, 383, 684, 669, 737],</span><br><span class="line">        type: &quot;line&quot;,</span><br><span class="line">        smooth: true,</span><br><span class="line">        itemStyle: &#123;</span><br><span class="line">          normal: &#123;</span><br><span class="line">            label: &#123;</span><br><span class="line">              show: true,</span><br><span class="line">              position: &quot;top&quot;,</span><br><span class="line">              formatter: &quot;&#123;c&#125;&quot;,</span><br><span class="line">            &#125;,</span><br><span class="line">          &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;);</span><br><span class="line">  window.onresize = function () &#123;</span><br><span class="line">    chart.resize();</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">onMounted(() =&gt; &#123;</span><br><span class="line">  go();</span><br><span class="line">&#125;);</span><br><span class="line">onUnmounted(() =&gt; &#123;</span><br><span class="line">  myEcharts.dispose;</span><br><span class="line">&#125;);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="ant-design-vue-a-table使用"><a href="#ant-design-vue-a-table使用" class="headerlink" title="ant design vue a-table使用"></a>ant design vue a-table使用</h1><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">参考：<span class="attr">https</span>:<span class="comment">//blog.csdn.net/weixin_45003732/article/details/126543519</span></span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">a-table</span> <span class="attr">:pagination</span>=<span class="string">&#x27;pagination&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">a-table</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="title function_">data</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">return</span>&#123;</span><br><span class="line">    <span class="attr">pagination</span>: &#123;</span><br><span class="line">       <span class="attr">disabled</span>: <span class="literal">false</span>,  <span class="comment">//禁用分页</span></span><br><span class="line">       <span class="attr">hideOnSinglePage</span>: <span class="literal">true</span>, <span class="comment">//只有一页时是否隐藏分页器</span></span><br><span class="line">       <span class="attr">pageSize</span>: <span class="number">10</span>, <span class="comment">//每页条数，所有页设置统一的条数</span></span><br><span class="line">       <span class="attr">pageSizeOptions</span>: [<span class="string">&#x27;10&#x27;</span>, <span class="string">&#x27;20&#x27;</span>, <span class="string">&#x27;30&#x27;</span>], <span class="comment">//每页显示的条数，每页设置不同的条数</span></span><br><span class="line">       <span class="attr">total</span>: <span class="number">100</span>, <span class="comment">//数据总数</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">title</span>: <span class="string">&#x27;更新时间&#x27;</span>,</span><br><span class="line">    <span class="attr">dataIndex</span>: <span class="string">&#x27;update_date&#x27;</span>,</span><br><span class="line">    <span class="attr">sorter</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">customRender</span>: <span class="function">(<span class="params">date</span>) =&gt;</span>&#123; <span class="keyword">return</span> <span class="title function_">moment</span>(date).<span class="title function_">format</span>(<span class="string">&quot;YYYY-MM-DD hh:mm&quot;</span>)&#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="Vant在uniapp的使用"><a href="#Vant在uniapp的使用" class="headerlink" title="Vant在uniapp的使用"></a>Vant在uniapp的使用</h1><blockquote><p>首先在<a href="https://gitee.com/vant-contrib/vant-weapp/进行一个下载">https://gitee.com/vant-contrib/vant-weapp/进行一个下载</a> 然后解压 在项目中（小程序） 创建wxcomponents 文件夹 把解压过来的vant-weapp-dev/dist 里的内容放进wxcomponents 文件夹里   官方文档：<a href="https://vant-contrib.gitee.io/vant/#/zh-CN">https://vant-contrib.gitee.io/vant/#/zh-CN</a></p><p><img src="C:\Users\19578\Desktop\vue3\images\vant使用.png" alt=""></p></blockquote><h1 id="vue3格式化时间"><a href="#vue3格式化时间" class="headerlink" title="vue3格式化时间"></a>vue3格式化时间</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"># npm install dayjs --save</span><br><span class="line"># 在页面中引入</span><br><span class="line"><span class="keyword">import</span> dayjs <span class="keyword">from</span> <span class="string">&quot;dayjs&quot;</span>;</span><br><span class="line"># 举例</span><br><span class="line">date_time.<span class="property">value</span> = <span class="title function_">dayjs</span>(<span class="keyword">new</span> <span class="title class_">Date</span>()).<span class="title function_">format</span>(<span class="string">&quot;YYYY-MM-DD hh:mm:ss&quot;</span>)</span><br><span class="line"></span><br><span class="line">获取当前时间，setup中</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> time = <span class="title function_">ref</span>();</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">getTime</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  time.<span class="property">value</span> = <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> timer = <span class="number">0</span>;</span><br><span class="line"><span class="title function_">onMounted</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  timer = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//设置定时器</span></span><br><span class="line">    <span class="title function_">getTime</span>(); <span class="comment">//自定义事件</span></span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="title function_">onBeforeUnmount</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">clearInterval</span>(timer); <span class="comment">//清除定时器</span></span><br><span class="line">  timer = <span class="number">0</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="补充：new-Dtae"><a href="#补充：new-Dtae" class="headerlink" title="补充：new Dtae()"></a>补充：new Dtae()</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> time = <span class="keyword">new</span> <span class="title class_">Date</span>();  </span><br><span class="line"><span class="keyword">let</span> year = time.<span class="title function_">getFullYear</span>();  <span class="comment">//获取年 2021</span></span><br><span class="line"><span class="keyword">let</span> month = time.<span class="title function_">getMonth</span>() + <span class="number">1</span>;  <span class="comment">//获取月  5</span></span><br><span class="line"><span class="keyword">let</span> day = time.<span class="title function_">getDate</span>();    <span class="comment">//获取天  11</span></span><br><span class="line"><span class="keyword">let</span> h = time.<span class="title function_">getHours</span>();   <span class="comment">//获取小时  18</span></span><br><span class="line"><span class="keyword">let</span> m = time.<span class="title function_">getMinutes</span>();  <span class="comment">//获取分钟  42</span></span><br><span class="line"><span class="keyword">let</span> s = time.<span class="title function_">getSeconds</span>();    <span class="comment">//获取秒  51</span></span><br><span class="line"><span class="keyword">let</span> weekDay = time.<span class="title function_">getDay</span>();  <span class="comment">//获取星期  2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> date = <span class="keyword">new</span> <span class="title class_">Date</span>();<span class="comment">//获取当前时间  Tue May 11 2021 18:42:51 GMT+0800 (中国标准时间)</span></span><br><span class="line">date .<span class="title function_">getYear</span>(); <span class="comment">//获取当前年份(2位)</span></span><br><span class="line">date .<span class="title function_">getFullYear</span>(); <span class="comment">//获取完整的年份(4位)</span></span><br><span class="line">date .<span class="title function_">getMonth</span>(); <span class="comment">//获取当前月份(0-11,0代表1月)</span></span><br><span class="line">date .<span class="title function_">getDate</span>(); <span class="comment">//获取当前日(1-31)</span></span><br><span class="line">date .<span class="title function_">getDay</span>(); <span class="comment">//获取当前星期X(0-6,0代表星期天)</span></span><br><span class="line">date .<span class="title function_">getTime</span>(); <span class="comment">//获取当前时间(从1970.1.1开始的毫秒数)</span></span><br><span class="line">date .<span class="title function_">getHours</span>(); <span class="comment">//获取当前小时数(0-23)</span></span><br><span class="line">date .<span class="title function_">getMinutes</span>(); <span class="comment">//获取当前分钟数(0-59)</span></span><br><span class="line">date .<span class="title function_">getSeconds</span>(); <span class="comment">//获取当前秒数(0-59)</span></span><br><span class="line">date .<span class="title function_">getMilliseconds</span>(); <span class="comment">//获取当前毫秒数(0-999)</span></span><br><span class="line">date .<span class="title function_">toLocaleDateString</span>(); <span class="comment">//获取当前日期</span></span><br><span class="line"><span class="keyword">var</span> mytime=date .<span class="title function_">toLocaleTimeString</span>(); <span class="comment">//获取当前时间</span></span><br><span class="line">date .<span class="title function_">toLocaleString</span>( ); <span class="comment">//获取日期与时间</span></span><br><span class="line"><span class="comment">// 获取当前月份</span></span><br><span class="line"><span class="keyword">var</span> nowMonth = date.<span class="title function_">getMonth</span>() + <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 获取当前是几号</span></span><br><span class="line"><span class="keyword">var</span> strDate = date.<span class="title function_">getDate</span>();</span><br><span class="line"><span class="comment">// 添加分隔符“-”</span></span><br><span class="line"><span class="keyword">var</span> seperator = <span class="string">&quot;-&quot;</span>;</span><br><span class="line"><span class="comment">// 对月份进行处理，1-9月在前面添加一个“0”</span></span><br><span class="line"><span class="keyword">if</span> (nowMonth &gt;= <span class="number">1</span> &amp;&amp; nowMonth &lt;= <span class="number">9</span>) &#123; </span><br><span class="line"></span><br><span class="line">nowMonth = <span class="string">&quot;0&quot;</span> + nowMonth;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 对月份进行处理，1-9号在前面添加一个“0”</span></span><br><span class="line"><span class="keyword">if</span> (strDate &gt;= <span class="number">0</span> &amp;&amp; strDate &lt;= <span class="number">9</span>) &#123; </span><br><span class="line"></span><br><span class="line">strDate = <span class="string">&quot;0&quot;</span> + strDate;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 最后拼接字符串，得到一个格式为(yyyy-MM-dd)的日期</span></span><br><span class="line"><span class="keyword">var</span> nowDate = date.<span class="title function_">getFullYear</span>() + seperator + nowMonth + seperator + strDate;</span><br><span class="line"><span class="comment">// 获取的是前一天日期</span></span><br><span class="line"><span class="keyword">var</span> time = (<span class="keyword">new</span> <span class="title class_">Date</span>).<span class="title function_">getTime</span>() - <span class="number">24</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">1000</span>;</span><br><span class="line"><span class="keyword">var</span> yesday = <span class="keyword">new</span> <span class="title class_">Date</span>(time); <span class="comment">// 获取的是前一天日期</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取某一天是周几</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">as</span>(<span class="params">dy</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="string">&#x27;日&#x27;</span>, <span class="string">&#x27;一&#x27;</span>, <span class="string">&#x27;二&#x27;</span>, <span class="string">&#x27;三&#x27;</span>, <span class="string">&#x27;四&#x27;</span>, <span class="string">&#x27;五&#x27;</span>, <span class="string">&#x27;六&#x27;</span>][<span class="keyword">new</span> <span class="title class_">Date</span>(<span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getFullYear</span>(), <span class="number">0</span>, dy % <span class="number">7</span>).<span class="title function_">getDay</span>()];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断这是一年的第几天</span></span><br><span class="line">      <span class="comment">//通过用if来把所有的条件都判断一遍（用if 并不用else if ：else if并不能把所有的条件都过一遍，天数无法累加）</span></span><br><span class="line">      <span class="comment">//输入年</span></span><br><span class="line">      <span class="comment">//输入月</span></span><br><span class="line">      <span class="comment">//输入日</span></span><br><span class="line">      <span class="keyword">var</span> year = <span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getFullYear</span>(); <span class="comment">//获取年</span></span><br><span class="line">      <span class="keyword">var</span> month = <span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getMonth</span>() + <span class="number">1</span>; <span class="comment">//&quot;请输入月份&quot;));</span></span><br><span class="line">      <span class="keyword">var</span> day = <span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getDate</span>()<span class="comment">//&quot;请输入日期&quot;));</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">//天数累加</span></span><br><span class="line">      <span class="comment">//闰年 2月29   平年2月28  通过平年闰年来判断月有多少天</span></span><br><span class="line">      <span class="comment">//1 3 5 7 8 10 12  31 天</span></span><br><span class="line">      <span class="comment">//4 6 9 11  30</span></span><br><span class="line">      <span class="comment">// 准备一个容器 来累加天数(if 语句)</span></span><br><span class="line">      <span class="keyword">var</span> date = day;</span><br><span class="line">      <span class="comment">//根据月份来进行判断  好知道是多少天</span></span><br><span class="line">      <span class="comment">//大于1 累加一月的天数（累加 +=）</span></span><br><span class="line">      <span class="comment">//大于2  累加一月和二月的天数</span></span><br><span class="line">      <span class="comment">//大于3  累加一 二 三月</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (month &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        date += <span class="number">30</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (month &gt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="comment">// 闰年的判断语句，如果为真29天 ，如果为假 28天</span></span><br><span class="line">        date += (year % <span class="number">4</span> == <span class="number">0</span> &amp;&amp; year % <span class="number">100</span> != <span class="number">0</span>) || year % <span class="number">400</span> == <span class="number">0</span> ? <span class="number">29</span> : <span class="number">28</span>; <span class="comment">//优先级  非 与 或</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (month &gt; <span class="number">3</span>) &#123;</span><br><span class="line">        date += <span class="number">31</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (month &gt; <span class="number">4</span>) &#123;</span><br><span class="line">        date += <span class="number">30</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (month &gt; <span class="number">5</span>) &#123;</span><br><span class="line">        date += <span class="number">31</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (month &gt; <span class="number">6</span>) &#123;</span><br><span class="line">        date += <span class="number">30</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (month &gt; <span class="number">7</span>) &#123;</span><br><span class="line">        date += <span class="number">31</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (month &gt; <span class="number">8</span>) &#123;</span><br><span class="line">        date += <span class="number">31</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (month &gt; <span class="number">9</span>) &#123;</span><br><span class="line">        date += <span class="number">30</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (month &gt; <span class="number">10</span>) &#123;</span><br><span class="line">        date += <span class="number">31</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (month &gt; <span class="number">11</span>) &#123;</span><br><span class="line">        date += <span class="number">30</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      date_day.<span class="property">value</span> =date</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(date+<span class="number">1</span>);</span><br><span class="line"><span class="comment">// 第二种方法</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Math</span>.<span class="title function_">ceil</span>(( <span class="keyword">new</span> <span class="title class_">Date</span>() - <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getFullYear</span>().<span class="title function_">toString</span>()))/(<span class="number">24</span>*<span class="number">60</span>*<span class="number">60</span>*<span class="number">1000</span>))+<span class="number">1</span>);</span><br></pre></td></tr></table></figure><h1 id="断点上传-和-分片上传区别"><a href="#断点上传-和-分片上传区别" class="headerlink" title="断点上传 和 分片上传区别"></a>断点上传 和 分片上传区别</h1><p>文件上传指的是将文件从本地电脑传输到服务器的过程。断点上传和分片上传是两种用于提高文件上传效率的方法。</p><p>断点续传 (Breakpoint Resume) 是一种用于恢复文件上传过程的技术。当文件上传过程中网络出现问题或者电脑意外关闭时，文件上传进程会中断。如果使用断点续传技术，在再次上传文件时会从上次中断的地方开始上传，这样就可以避免重新上传整个文件，节省时间。</p><p>分片上传 (Chunked Upload) 是将文件分成若干个小块（通常是几MB大小），然后将每一块单独上传。这样，当网络状态较差时，只会有一小部分的数据受到影响，而不是整个文件上传失败。分片上传还可以让服务器端并行处理多个分片，提高上传速度。</p><p>总结一下，断点续传是在文件上传过程中出现问题时恢复上传进度的技术，而分片上传是将文件分成若干小块上传的技术，用于提高上传效率。</p><p>学习next.js和three.js</p><h1 id="css"><a href="#css" class="headerlink" title="css"></a>css</h1><h2 id="文字渐变色"><a href="#文字渐变色" class="headerlink" title="文字渐变色"></a>文字渐变色</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.home-status</span> &#123;</span><br><span class="line">      <span class="attribute">background</span>: <span class="built_in">-webkit-linear-gradient</span>(<span class="number">0deg</span>, yellow, red <span class="number">10%</span>, green <span class="number">90%</span>);//红绿渐变区间（<span class="number">10%</span>-<span class="number">50%</span>）</span><br><span class="line">      -webkit-<span class="attribute">background-clip</span>: text; //用文本占据的空间来剪裁盒子背景</span><br><span class="line">      <span class="attribute">color</span>: transparent; //将文本颜色设置为透明，将空间背景颜色显示</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;vite-的基本使用&quot;&gt;&lt;a href=&quot;#vite-的基本使用&quot; class=&quot;headerlink&quot; title=&quot;vite 的基本使用&quot;&gt;&lt;/a&gt;vite 的基本使用&lt;/h1&gt;&lt;p&gt;首先，我们安装一下vite工具：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;npm inst</summary>
      
    
    
    
    
    <category term="笔记" scheme="https://admin741-cl.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
</feed>
